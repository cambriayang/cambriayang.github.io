I"<p>简单介绍一下这次模块化实践以及所遇到的一些问题</p>

<h1 id="数据结构">数据结构</h1>
<h2 id="分类">分类</h2>
<p>数据结构是算法基础，线性结构有 数组，栈，链表等，非线性结构有树，图等<strong>（树可以被看作半线性的）</strong>
需要注意的湿，线性和非线性<em>不代表存储结构湿线性和非线性的</em>，这两者没有任何关系，它只是一种逻辑上的划分。比如我们可以用数组去存储二叉树
<strong>一般而言，有前驱和后继的就是线性数据结构</strong>比如数组和链表。其实一叉树就是链表</p>
<h2 id="几种特殊数据结构的简单讲解">几种特殊数据结构的简单讲解</h2>
<p>默认大家是有一定基础的，所以讲的比较简单</p>

<ul>
  <li>队列
  队列是一种受限的序列，它只能操作队首和队尾，并且只能在队尾添加元素，在队首删除元素
    <blockquote>
      <p>“队列”这个名称,可类比为现实生活中排队（不插队的那种）</p>
    </blockquote>
  </li>
  <li>
    <p>栈
  栈也是一种受限的序列，它只能够操作栈顶。在计算机科学重，一个栈（stack）是一种抽象的数据类型，用作表示元素的集合，具有两种主要操作：push和pop。所以此处应该有个peek操作用于访问当前顶端的元素，只返回不弹出。</p>
  </li>
  <li>链表
  链表是一种最基本数据结构，熟练掌握链表的结构和常见操作是基础中的基础。</li>
</ul>

<h2 id="非线性结构">非线性结构</h2>
<p>有了线性结构，为什么我们还需要非线性结构呢？
阴我我们要高效的兼顾静态操作和动态操作。大家可以对照各种数据结构的操作的复杂度来直观感受下。</p>

<h3 id="树">树</h3>

<p>树的应用很广泛，小到文件系统，大到因特网，组织架构等都可以表示为树结构。DOM树就是一种树结构，而HTML作为一种DSL去描述这种树结构的表现形式。如果你接触过AST，那么AST也是一种树，XML也是树。</p>

<p>树其实是一种特殊的<em>图</em>，是一种无环连通图，是一种极大无环图，也是一种极小连通图。从另一个角度看，树是一种递归的数据结构。
树的基本算法有 <strong><em>前中后序遍历</em></strong> 和 <strong><em>层次遍历</em></strong>。
你只需要记住 <em>所谓的前中后指的是根节点的位置，其他位置按照先左后右排列即可。</em>
比如，前序遍历就是<code class="language-plaintext highlighter-rouge">根左右</code>，中序就是<code class="language-plaintext highlighter-rouge">左根右</code>，后续就是 <code class="language-plaintext highlighter-rouge">左右根</code></p>

<p>因为树是递归的数据结构，所以树的遍历算法使用递归去完成很简单，输的算法基本上都要依赖于树的遍历。但是递归在计算机中的性能一直都有问题，因此掌握不那么容易理解的“命令式迭代”遍历算法在某些情况下是有用的。如果你使用迭代方式去遍历的话，可以借助上面提到的<code class="language-plaintext highlighter-rouge">栈</code>来进行，可以极大的减少代码量。</p>

<blockquote>
  <p>如果使用栈来简化运算，由于栈是FILO的，因此一定要注意左右子树的推入顺序。</p>
</blockquote>

<p><strong>树的重要性质：</strong>
    * 如果树有n个顶点，那么其就有n-1条边，这说明了树的定点数和边数是同阶的。
    * 任何一个节点到根节点存在 <em>唯一</em> 路径，路径的长度为节点所处的深度。</p>

<h4 id="二叉树">二叉树</h4>
<p>二叉树是节点数不超过二的树，是树的一种特殊子集，有去的是二叉树这种被限制的树结构却能够表示和实现所有的树，它背后的原理正是 <code class="language-plaintext highlighter-rouge">长子+兄弟</code> 法
一个典型的二叉树：
标记为7的节点具有两个子节点，标记为2和6；一个父节点，标记为2，作为根节点，在顶部，没有父节点。</p>

<h4 id="二叉查找树">二叉查找树</h4>
<p>又称二叉搜索树
具备以下性质：</p>
<ul>
  <li>若左子树不空，则左子树上所有节点的值均小于它的根节点的值；</li>
  <li>若右子树不空，则右子树上所有节点的值均大于它的根节点的值；</li>
  <li>左右子树也分别为二叉排序树；</li>
  <li>没有键值相等的节点。</li>
</ul>

<p>对于一个二叉查找树，常规操作有插入，查找，删除，找父节点，求最大值，求最小值。</p>

<p>另外，二叉查找树有一个性质：<code class="language-plaintext highlighter-rouge">其中遍历的结果是一个有序数组。</code></p>

<h4 id="二叉平衡树">二叉平衡树</h4>
<p>改进的二叉查找树。一般的二叉查找树的查询复杂度取决于目标节点到树根的距离（即深度），因此当节点的深度普遍较大时，查询的均摊复杂度会上升。为了实现更高效的查询，产生了平衡树。</p>

<p><em>平衡指所有的叶子的深度趋于平衡，更广义的是指在树上所有可能查找的均摊复杂度偏低。</em></p>

<p>一些数据库的引擎内部就是用的这种数据结构，其目标也是讲查询的操作降低到logn（树的深度），可以简单理解为 <code class="language-plaintext highlighter-rouge">树在数据结构层面构造的二分查找算法</code>.
基本操作，<code class="language-plaintext highlighter-rouge">旋转</code> <code class="language-plaintext highlighter-rouge">插入</code> <code class="language-plaintext highlighter-rouge">删除</code> <code class="language-plaintext highlighter-rouge">查询前驱</code> <code class="language-plaintext highlighter-rouge">查询后继</code></p>

<h4 id="avl">AVL</h4>
<p>最早被发明的自平衡二叉查找树。在AVL树中，任一节点对应的两颗子树的最大高度差为1，因此它也被称为高度平衡树。查找，插入和删除在平均和最坏的情况下的时间复杂度都是O（logn）。增加和删除元素的操作则可能需要借由一次或多次树旋转，以实现树的重新平衡。</p>

<h4 id="红黑树">红黑树</h4>
<p>被称为“对称二叉B树”，红黑树的结构复杂，但它的操作有着良好的最坏情况运行时间，并且在实践中高效：它可以在O（logn）时间内完成查找，插入和删除，这里的n是树种元素的数目。</p>

<h3 id="堆">堆</h3>
<p>堆其实是一种优先级队列，在很多语言都有对应的内置数据结构。
<strong>堆的特点：</strong></p>
<ul>
  <li>在一个最小堆中，如果p是c的一个父级节点，那么p的key（或者value）应小于或等于c的对应值。正因为此，堆顶一定是最小的，我们会利用这个特点求最小值或者k小的值。</li>
  <li>在一个最大堆中，p的key（或者value）大于c的对应值。</li>
</ul>

<h3 id="图">图</h3>
<p>前面讲的数据结构都可以看成是图的特例。前面提到了二叉树完全可以实现其他树结构，其实有向图也完全可以实现无向图和混合图，因此有向图的研究一直都是重点考察对象。</p>

<h4 id="图的遍历">图的遍历</h4>
<p>图的遍历就是要找出图中所有的点，一般有以下两种方法：</p>
<ol>
  <li>深度优先（Depth First Search,DFS）
 深度优先遍历图的方法是，从图中某顶点v出发，不断访问邻居，邻居的邻居直到访问完毕。</li>
  <li>广度优先 (Breadth First Search,BFS)
 广度优先，可以被形象的描述为“浅尝辄止”，它也需要一个队列以保持遍历过的顶点顺序，以便按出队的顺序再去访问这些顶点的邻接顶点。</li>
</ol>

:ET