---
layout: article
mathjax: true
title: 算法-杂项
category: Algorithm
date: 2022-03-08 15:33:00 +0800
tags: [算法]
---
一些算法举例

## 杂项

### 产生不重复的随机数

+ 思路

设想一下，有n个苹果，有不同的编号，从1-n，每次拿一个出来。来产生不同的随机数

+ 实现

```swift
func randomNumberWithoutDuplication(_ number: Int) -> [Int] {
  var resultArr = Array(repeating: 0, count: number)
  var startArr = Array(1...number)

  for i in 0..<startArr.count {
    let currentCount = UInt32(startArr.count-i)
    let index = Int(arc4random_uniform(currentCount))
    resultArr[i] = startArr[index]
    startArr[index] = startArr[Int(currentCount) - 1]
  }

  return resultArr
}
```

+ 测试

>let aaa = solution.randomNumberWithoutDuplication(10)
>
>[1, 5, 8, 9, 4, 3, 10, 2, 6, 7]


### 求解n！的结果中有多少个0

+ 思路

  首先我们知道10=2*5，所以有多少个0取决于有多少个2*5。而n！中包含5的因子的个数，可以用下面的表达式来计算

  k= n/5+n/5^2+n/5^3+...

  同样的n！包含2的因子的个数可以用下面的表达式来计算

  m= n/2+n/2^2+n/2^3+...

  很显然m>k。所以末尾0的个数是min(m,k)也就是k了。

+ 实现

  
  ```swift
  func trailing_zero_num(number: Int) -> Int {
    var num = 0
    var n = number
    while Bool(truncating: n as NSNumber) {
      num += n/5
      n = n/5
    }
    return num
  }
  ```

### 多线程交替打印A，B分别10次

+ 实现

```swift
func outABWithGCD() {
  let queue1 = DispatchQueue(label: "com.queue1.a", qos: .utility)
  let queue2 = DispatchQueue(label: "com.queue2.b", qos: .utility)

  var change: Bool = true

  queue1.async {
    var count1 = 0
    while true {
      if change {
        print("queue1:A")
        change = false
        count1+=1
      }

      if count1 == 10 {
        break
      }
    }
  }

  queue2.async {
    var count2 = 0
    while true {
      if !change {
        print("queue2:B")
        change = true
        count2+=1
      }

      if count2 == 10 {
        break
      }
    }
  }
}
```

+ 示例

```swift
solution.outABWithGCD()
```

+ 结果

>**queue1:A**
>
>**queue2:B**
>
>**queue1:A**
>
>**queue2:B**
>
>**queue1:A**
>
>**queue2:B**
>
>**queue1:A**
>
>**queue2:B**
>
>**queue1:A**
>
>**queue2:B**
>
>**queue1:A**
>
>**queue2:B**
>
>**queue1:A**
>
>**queue2:B**
>
>**queue1:A**
>
>**queue2:B**
>
>**queue1:A**
>
>**queue2:B**
>
>**queue1:A**
>
>queue2:B

## 动态或贪心

### 买卖股票的最佳时机

给定一个数组，它的第i个元素是一支给定股票第i天的价格。

如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。

**注意**： 你不能再买入股票前卖出股票。

+ 示例

```markdown
输入：[7,1,5,3,6,4]
输出： 5
解释： 在第2天（股票价格=1）的时候买入，在第5天（=6），最大利润=6-1=5.注意利润不可能是7-1

输入： [7,6,4,3,1]
输出： 0
解释： 在这种情况下，没有交易完成，所以利润为0.
```

+ 思路

需要找到最小的谷之后的最大的峰。 我们可以维持两个变量——minprice 和 maxprofit，它们分别对应迄今为止所得到的最小的谷值和最大的利润（卖出价格与最低价格之间的最大差值）。

+ 解法

```swift
func maxProfit(_ prices: [Int]) -> Int {
  var minPrice = Int.max
  var maxProfit = 0
  for i in 0..<prices.count {
    if prices[i] < minPrice {
      minPrice = prices[i]
    } else if prices[i] - minPrice > maxProfit {
      maxProfit = prices[i]-minPrice
    }
  }

  return maxProfit
}
```

+ 结果

>print(solution.maxProfit([7,1,5,3,6,4]))
>
>5

### 买卖股票的最佳时机II

+ 示例

```markdown
输入：[7,1,5,3,6,4]
输出：7
解释：在第2天（=1）买入，第三天（=5）卖出，利润4，然后在第4天（=3）买入，第5天（=6）卖出，利润3
总利润3+4=7
```

+ 思路

在斜坡上爬升并持续增加从交易中获得的利润

![leetcode_maxprofit]({{site.url}}/assets/images/posts/leetcode_maxprofit.jpg)

+ 解法

```swift
func maxProfitII(_ prices: [Int]) -> Int {
  if prices.count < 2 {
    return 0
  }

  var maxProfit = 0
  for i in 1..<prices.count {
    if prices[i] > prices[i-1] {
      maxProfit += prices[i]-prices[i-1]
    }
  }
  return maxProfit
}
```

+ 结果

>print(solution.maxProfitII([7,1,5,3,6,4]))
>
>7

### 滑动窗口最大值

给定一个Int窗口，实时的输出窗口最大的元素

+ 示例

```markdown
输入：k=3，nums=[1,3,-1,-3,5,3,6]
输出：[3,3,5,5,6]
```

+ 思路

窗口为3个位置，只要有一个最大值进来，比他早的元素永远没有出头之日，所以可以直接忽略掉。

+ 解法

```swift
func findMaxInWindow(_ count: Int, _ nums: [Int]) -> [Int] {
  var res = [Int]()

  if nums.count < 0 {
    return []
  }

  var maxNum = Int.min

  if nums.count < count {
    for i in 0..<nums.count {
      if nums[i] > maxNum {
        maxNum = nums[i]
      }
    }

    res.append(maxNum)

    return res
  }

  for i in 0..<count {
    if nums[i] > maxNum {
      maxNum = nums[i]
    }
  }

  res.append(maxNum)

  for j in (nums.count-count-1)..<nums.count {
    if nums[j] > maxNum {
      maxNum = nums[j]
    }

    res.append(maxNum)
  }

  return res
}
```

+ 结果

>let r15 = solution.findMaxInWindow(3, [1,3,-1,-3,5,3,6])
>
>print(r15)
>
>**[3, 3, 5, 5, 6]**

### 生成小括号字符串

给定固定长度，比如n，生成所有合法的小括号组成形式

+ 示例

```markdown
输入: n=3
输出: ["((()))", "(()())", "(())()", "()(())", "()()()"]
```

+ 思路

采用递归，但是要注意，左右括号肯定都是为n个，并且左括号可以随意加（不超过n），但是右括号必须要在左括号大于右括号的时候才可以输入，然后递归即可

+ 解法

```swift
func generateParenthesis(_ count: Int) -> [String] {
  var res: [String] = [String]()
  _gen(0, 0, count, "", &res)
  return res
}

func _gen(_ left: Int, _ right: Int, _ count: Int, _ result: String, _ res: inout [String]) {
  //递归出口
  if left == count && right == count {
    res.append(result)
  }

  if left < count {
    _gen(left+1, right, count, result+"(", &res)
  }

  if left > right && right < count {
    _gen(left, right+1, count, result+")", &res)
  }
}
```

+ 结果

>let r16 = solution.generateParenthesis(3)
>
>print(r16)
>
>**["((()))", "(()())", "(())()", "()(())", "()()()"]**

