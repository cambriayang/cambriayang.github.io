---
layout: article
mathjax: true
mathjax_autoNumber: true
title: LeetCode随笔
category: Algorithm
date: 2024-03-10 12:00:00 +0800
tags: [算法]
---

这是一篇关于一些LeetCode经典或者热题的随笔记录，旨在保持自己活跃的大脑和思维，要勤思考，多实践

## 数组/字符串

### 删除有序数组中的重复项
- 题目

26：给定一个非严格递增排列的数组nums，请你原地删除重复出现的元素，使每个元素只出现一次，返回删除后的数组的新长度，元素的相对顺序应该保持一致，然后返回nums中唯一元素的个数。

- 示例

    >输入：nums = [1,1,2]
    >输出：2, nums = [1,2]
    >解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。
    >
    >输入：nums = [0,0,1,1,1,2,2,3,3,4]
    > 输出：5, nums = [0,1,2,3,4]
    > 解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。

- 思路
    - 暴力法

    不考虑时间和空间问题，由于数组已经排过需了，那么只需要一个指针循环旧数组，一个新数组，第一个元素肯定放入新数组，然后从第二个元素开始遍历到旧数组结尾，如果和第一个元素相同则跳过，不同则记录入新数组，最后将新数组放入老数组即可，也可不放入。
    如果旧数组为空，不处理，长度＜＝2，则肯定是原数组了，直接返回原数组个数。
    
    ```swift
    func removeDuplicates1(_ nums: inout [Int]) -> Int {
        if nums.count < 2 {
            return nums.count
        }
        
        var rt = 0
        
        var tmpArr = [Int]()
        
        var tmp = nums[0]
        
        tmpArr.append(tmp)
        
        for i in 1..<nums.count {
            if nums[i] > tmp {
                //说明不同，否则至少相等，因为已经排过序
                tmp = nums[i]
                tmpArr.append(tmp)
            }
        }
        
        rt = tmpArr.count
        
        print("不同的元素数组是1：\(tmpArr)")
        
        return rt
    }
    ```
    
    >     var nums = [0,0,1,1,1,2,2,3,3,4]
    >     let _ = solution.removeDuplicates1(&nums)
    >     
    >     不同的元素数组是：[0, 1, 2, 3, 4]
    
    - 双指针法
    
    由于数组是排过序的，后面的元素只可能存在等于或者大于前一个元素两种状态，由于可以改变原数组，所以所有重复位置的元素都可以被后来不重复的元素替换，所以可以定义快慢2个指针，快指针用于扫描，找出不同的元素，慢指针指向可以替换的位置（也就是重复元素的位置）
    
    ```swift
    func removeDuplicates2(nums: inout [Int]) -> Int {
        if nums.count < 2 {
            return nums.count
        }
        
        var rt = 0
        
        //直接从第二个元素开始遍历
        var slow = 1
        
        for fast in 1..<nums.count {
            if nums[fast] > nums[fast-1] {
                nums[slow] = nums[fast]
                slow = slow + 1
            }
        }
        
        rt = slow
        
        print("不同的元素数组是2：\(nums) num is: \(rt)")

        return rt
    }
    ```
    
    >   var nums = [0,0,1,1,1,2,2,3,3,4]
    >   let _ = solution.removeDuplicates2(nums: &nums)
    >    
    >   不同的元素数组是2：[0, 1, 2, 3, 4, 2, 2, 3, 3, 4] num is: 5
    
     
### 接雨水
+ 题目

42：
给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水，
如下所示：

![rain]({{site.url}}/assets/images/posts/rain.jpg)

上图中，盛水量为3.

+ 示例

```markdown
输入：height = [3,1,2,4]
输出：3
```

+ 思路
    + 暴力法
    
    每个i位置，都前后遍历，从i位置向前和向后遍历，找到前后max值较小的减去当前i位置的值就是能装的水，要是前或者后没有找到比i位置小的，那么就不能装水，复杂度为O(n2)
    
    ```swift
    //柱状图接水(暴力法)
    func getWaterByViolence(src: [Int]) -> Int {
        var rt = 0
        
        if src.isEmpty || src.count < 3 {
            return rt
        }
        
        
        for i in 1..<src.count-1 {
            var leftMax = src[0]
            
    //        获取作则最大值
            for j in 0..<i {
                if src[j] > leftMax {
                    leftMax = src[j]
                }
            }
            
    //        获取右侧最大值
            var rightMax = src[src.count-1]
            
            for k in (i+1...src.count-1).reversed() {
                if src[k] > rightMax {
                    rightMax = src[k]
                }
            }
            
    //        左右两个大值中的较小者和src[i]的差值就是当条柱状图所能储水的值
    //        且如果他们都比src[i]小的话就储不了水
            rt += max(0, min(leftMax, rightMax) - src[i])
        }
        
        print("\(src)'s 柱状图接水(暴力法) is \(rt)")
    
        return rt
    }
    ```
    
    控制台
    >let _ = getWaterByViolence(src: [3, 1, 2, 4])
    >
    >[3, 1, 2, 4]'s 柱状图接水(暴力法) is 3

    
    + 双指针法
    
    定义一个双指针，分别为左右指针，分别指向arr[1]和arr[count-2]，因为第一个和最后一个肯定不能储水，同时定义2个最值，leftMax和rightMax分别为第二个元素和倒数第二个元素。
    当左最值小于右最值时，右滑左指针，左指针上能储的水就是：左最值＞左指针，相减，左最值<左指针，不减，更新左最值；
    同样的逻辑对于左最值大于右最值时，也来一遍。
    时间复杂度为O(n),空间复杂度为O(1)
    
    ```swift
            //柱状图接水(左右指针法)，时间复杂度O(n2)，空间复杂度O(1)
        func getWaterBy2P(arr: [Int]) -> Int {
            var rt = 0
            
            if arr.isEmpty || arr.count < 3 {
                return rt
            }
            
            var leftMax = arr[0]
            var rightMax = arr[arr.count-1]
            
            var leftP = 1
            var rightP = arr.count-2
            
            while leftP <= rightP {
                if leftMax <= rightMax {
        //            rt += leftMax-arr[leftP] > 0 ? leftMax-arr[leftP] : 0
                    rt += max(0, leftMax-arr[leftP])
                    leftMax = max(leftMax, arr[leftP])
                    
                    leftP+=1
                } else {
        //            rt += rightMax-arr[rightP] > 0 ? rightMax-arr[rightP] : 0
                    rt += max(0, rightMax-arr[rightP])
                    rightMax = max(rightMax, arr[rightP])
                    
                    rightP -= 1
                }
            }
            
            print("\(arr)'s 柱状图接水(左右指针法) is \(rt)")
        
            return rt
        }
    ```

控制台
>let _ = getWaterBy2P(arr: [3, 1, 2, 4])
>
>[3, 1, 2, 4]'s 柱状图接水(左右指针法) is 3
