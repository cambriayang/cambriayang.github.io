---
layout: article
mathjax: true
mathjax_autoNumber: true
title: LeetCode随笔
category: Algorithm
date: 2024-03-10 12:00:00 +0800
tags: [算法]
---

这是一篇关于一些LeetCode经典或者热题的随笔记录，旨在保持自己活跃的大脑和思维，要勤思考，多实践

## 数组/字符串

### 删除有序数组中的重复项 II

- 题目

80：给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使得出现次数超过两次的元素只出现两次 ，返回删除后数组的新长度。

不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。

- 示例

> 输入：nums = [1,1,1,2,2,3]
> 输出：5, nums = [1,1,2,2,3]
> 解释：函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3。 不需要考虑数组中超出新长度后面的元素。
> 
> 输入：nums = [0,0,1,1,1,1,2,3,3]
输出：7, nums = [0,0,1,1,2,3,3]
解释：函数应返回新长度 length = 7, 并且原数组的前七个元素被修改为 0, 0, 1, 1, 2, 3, 3。不需要考虑数组中超出新长度后面的元素。

- 思路

首先，非严格递增的数组nums，则和之前一样，后面的元素必然 >= 前面的元素，由于题目要求出现次数超过两次的元素只保留两次，且空间复杂度为O(1)，所以采用双指针法。
由于相同的元素必然是连续的，假设有一段连续相同的number，所以会从第3个相同元素可以替换，前面2个保留下来。根据26题的思路，nums[fast]和nums[slow-2]不同时，nums[fast]需要被替换，也就是更新为slow，slow表明是需要被替换的位置，fast是遍历的位置。

```swift
func removeDuplicates3(nums: inout [Int]) -> Int {
    let len = nums.count
    
    if len <= 2 {
        return len
    }
    
    var rt = 0
    
    var slow = 2
    
    //slow是需要替换的位置，那么slow-2自然就是需要保留的位置
    for fast in 2..<len {
        if nums[fast] != nums[slow - 2] {
            nums[slow] = nums[fast]
            slow = slow + 1
        }
    }
            
    rt = slow
    
    print("不同的元素数组是3：\(nums) num is: \(rt)")
    
    return rt
}
```

> var nums = [0,0,1,1,1,1,2,3,3]
> let _ = solution.removeDuplicates3(nums: &nums)
> > 不同的元素数组是3：[0, 0, 1, 1, 2, 3, 3, 3, 3] num is: 7

### 删除有序数组中的重复项
- 题目

26：给定一个非严格递增排列的数组nums，请你原地删除重复出现的元素，使每个元素只出现一次，返回删除后的数组的新长度，元素的相对顺序应该保持一致，然后返回nums中唯一元素的个数。

- 示例

    >输入：nums = [1,1,2]
    >输出：2, nums = [1,2]
    >解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。
    >
    >输入：nums = [0,0,1,1,1,2,2,3,3,4]
    > 输出：5, nums = [0,1,2,3,4]
    > 解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。

- 思路
    - 暴力法

    不考虑时间和空间问题，由于数组已经排过需了，那么只需要一个指针循环旧数组，一个新数组，第一个元素肯定放入新数组，然后从第二个元素开始遍历到旧数组结尾，如果和第一个元素相同则跳过，不同则记录入新数组，最后将新数组放入老数组即可，也可不放入。
    如果旧数组为空，不处理，长度＜＝2，则肯定是原数组了，直接返回原数组个数。
    时间复杂度为O(n)，空间复杂度为O(n)。
    
    ```swift
    func removeDuplicates1(_ nums: inout [Int]) -> Int {
        if nums.count < 2 {
            return nums.count
        }
        
        var rt = 0
        
        var tmpArr = [Int]()
        
        var tmp = nums[0]
        
        tmpArr.append(tmp)
        
        for i in 1..<nums.count {
            if nums[i] > tmp {
                //说明不同，否则至少相等，因为已经排过序
                tmp = nums[i]
                tmpArr.append(tmp)
            }
        }
        
        rt = tmpArr.count
        
        print("不同的元素数组是1：\(tmpArr)")
        
        return rt
    }
    ```
    
    > var nums = [0,0,1,1,1,2,2,3,3,4]
    > let _ = solution.removeDuplicates1(&nums)
    >> 不同的元素数组是：[0, 1, 2, 3, 4]
    
    - 双指针法
    
    由于数组是排过序的，后面的元素只可能存在等于或者大于前一个元素两种状态，由于可以改变原数组，所以所有重复位置的元素都可以被后来不重复的元素替换，所以可以定义快慢2个指针，快指针用于扫描，找出不同的元素，慢指针指向可以替换的位置（也就是重复元素的位置）
    时间复杂度为O(n)，空间复杂度为O(1)。
    
    ```swift
    func removeDuplicates2(nums: inout [Int]) -> Int {
        if nums.count < 2 {
            return nums.count
        }
        
        var rt = 0
        
        //直接从第二个元素开始遍历
        var slow = 1
        
        for fast in 1..<nums.count {
            if nums[fast] > nums[slow-1] {
                nums[slow] = nums[fast]
                slow = slow + 1
            }
        }
        
        rt = slow
        
        print("不同的元素数组是2：\(nums) num is: \(rt)")

        return rt
    }
    ```
    
    > var nums = [0,0,1,1,1,2,2,3,3,4]
    > let _ = solution.removeDuplicates2(nums: &nums)
    >> 不同的元素数组是2：[0, 1, 2, 3, 4, 2, 2, 3, 3, 4] num is: 5
    
     
### 接雨水
+ 题目

42：
给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水，
如下所示：

![rain]({{site.url}}/assets/images/posts/rain.jpg)

上图中，盛水量为3.

+ 示例

```markdown
输入：height = [3,1,2,4]
输出：3
```

+ 思路
    + 暴力法
    
    每个i位置，都前后遍历，从i位置向前和向后遍历，找到前后max值较小的减去当前i位置的值就是能装的水，要是前或者后没有找到比i位置小的，那么就不能装水，复杂度为O(n2)
    
    ```swift
    //柱状图接水(暴力法)
    func getWaterByViolence(src: [Int]) -> Int {
        var rt = 0
        
        if src.isEmpty || src.count < 3 {
            return rt
        }
        
        
        for i in 1..<src.count-1 {
            var leftMax = src[0]
            
    //        获取作则最大值
            for j in 0..<i {
                if src[j] > leftMax {
                    leftMax = src[j]
                }
            }
            
    //        获取右侧最大值
            var rightMax = src[src.count-1]
            
            for k in (i+1...src.count-1).reversed() {
                if src[k] > rightMax {
                    rightMax = src[k]
                }
            }
            
    //        左右两个大值中的较小者和src[i]的差值就是当条柱状图所能储水的值
    //        且如果他们都比src[i]小的话就储不了水
            rt += max(0, min(leftMax, rightMax) - src[i])
        }
        
        print("\(src)'s 柱状图接水(暴力法) is \(rt)")
    
        return rt
    }
    ```
    
    控制台
    >let _ = getWaterByViolence(src: [3, 1, 2, 4])
    >
    >[3, 1, 2, 4]'s 柱状图接水(暴力法) is 3

    
    + 双指针法
    
    定义一个双指针，分别为左右指针，分别指向arr[1]和arr[count-2]，因为第一个和最后一个肯定不能储水，同时定义2个最值，leftMax和rightMax分别为第二个元素和倒数第二个元素。
    当左最值小于右最值时，右滑左指针，左指针上能储的水就是：左最值＞左指针，相减，左最值<左指针，不减，更新左最值；
    同样的逻辑对于左最值大于右最值时，也来一遍。
    时间复杂度为O(n),空间复杂度为O(1)
    
    ```swift
            //柱状图接水(左右指针法)，时间复杂度O(n2)，空间复杂度O(1)
        func getWaterBy2P(arr: [Int]) -> Int {
            var rt = 0
            
            if arr.isEmpty || arr.count < 3 {
                return rt
            }
            
            var leftMax = arr[0]
            var rightMax = arr[arr.count-1]
            
            var leftP = 1
            var rightP = arr.count-2
            
            while leftP <= rightP {
                if leftMax <= rightMax {
        //            rt += leftMax-arr[leftP] > 0 ? leftMax-arr[leftP] : 0
                    rt += max(0, leftMax-arr[leftP])
                    leftMax = max(leftMax, arr[leftP])
                    
                    leftP+=1
                } else {
        //            rt += rightMax-arr[rightP] > 0 ? rightMax-arr[rightP] : 0
                    rt += max(0, rightMax-arr[rightP])
                    rightMax = max(rightMax, arr[rightP])
                    
                    rightP -= 1
                }
            }
            
            print("\(arr)'s 柱状图接水(左右指针法) is \(rt)")
        
            return rt
        }
    ```

控制台
>let _ = getWaterBy2P(arr: [3, 1, 2, 4])
>
>[3, 1, 2, 4]'s 柱状图接水(左右指针法) is 3
