---
layout: post
title: 算法举例
category: Algorithm
date: 2020-07-20 20:33:00 +0800
tags: [算法]
---
一些算法举例

## 排序算法
首先看一张图：

![sort_algorithm]({{site.url}}/assets/images/posts/sort_algorithm.jpg)

这里就不多解释了，下面抽几个排序简单讲下。

### 冒泡排序
* 算法步骤

比较相邻的元素。如果第一个比第二个大，就交换他们两个。
对每一对相邻元素作同样的工作，从开始第一队到结尾的最后一对。这步做完后，最后的元素会是最大的数。
针对所有的元素重复以上的步骤，除了最后一个。
持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。

* 动图演示

![bubbleSort]({{site.url}}/assets/images/posts/bubbleSort.gif)

* 代码实现：

```swift
    func bubbleSort(arr: inout [Int]) {
        for i in 0..<arr.count-1 {
            for j in 0..<arr.count-1-i {
                if arr[j] > arr[j+1] {
                    arr.swapAt(j, j+1)
                }
            }
        }
    }
```

i的循环是计数用，j的循环是当次将最大的数放到最后。

### 插入排序
* 算法步骤

将第一待排序的第一个元素看过一个有序序列，把第二个元素到最后一个元素当成未排序序列。
从头到位以此扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面）

* 动图演示

由于很好理解就不放动图演示了。

* 代码实现

```swift
    func insertSort(arr: inout [Int]) {
        for i in 1..<arr.endIndex {
            let temp = arr[i]
            for j in (0..<i).reversed() {
                if arr[j] > temp {
                    arr.swapAt(j, j+1)
                }
            }
        }
    }
```

### 快速排序
平均状况下，排序n个项目要O（nlogn）次比较。在最坏的状况下则需要O（n^2）次比较，但这种状况并不多见。事实上，快排通常明显比其他O（nlogn）算法更快一个，因为它的内部循环可以在大部分的架构上很有效率地被实现出来。
快排使用分治法（Divide and conquer）策略来把一个串行（list）分为两个子串行（sub-lists）。
快速排序本质上市冒泡排序基础上的递归分治法。它是处理大数据排序最快的算法之一了。
《算法艺术与信息学竞赛》上说：
> 快速排序最坏的情况是O（n^2），比如顺序数列额快排。但它的平摊期望时间是O（nlogn），且O（nlogn）记号中隐含的常数因子很小，比复杂度稳定等于O（nlogn）的归并排序要小很多。所以，对绝大多数树顺序性较弱的随机数列而言，快速排序总是优于归并排序。

+ 算法步骤

1. 从数列中挑出一个元素，称为“基准”（pivot）；
2. 重新排序数列，所有元素比基准值晓得摆放在基准面前，所有比基准大的摆在基准后面（相同的可以放到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；
3. 递归的（recursive）把小于基准值的元素的子数列和大于基准值元素的子数列排序。

+ 动图演示

![quickSort]({{site.url}}/assets/images/posts/quickSort.gif)

+ 代码实现

```swift
    //寻找pivot的函数
    func partition(arr: inout [Int], left: Int, right: Int) -> Int {
        let pivot = left
        var index = pivot+1
        for i in index...right {
            if arr[i] < arr[pivot] {
                arr.swapAt(i, index)
                index+=1
                //i和index都更新，以pivot为分隔，两边都冒泡，后面再将假设的pivot替换为真正的pivot，然后继续递归
            }
        }
        //此处相当于pivot需要更新
        arr.swapAt(pivot, index-1)
        return index-1
    }
    
    func quickSort(arr: inout [Int], left: Int, right: Int) {
        if arr.count <= 1 {
            //nothing, live it alone
        }
        
        let left = left
        let right = right
        if left < right {
            let partitionIndex = partition(arr: &arr, left: left, right: right)
            quickSort(arr: &arr, left: left, right: partitionIndex-1)
            quickSort(arr: &arr, left: partitionIndex+1, right: right)
        }
    }
```


## 字符串
### 有一个字符串和一组子字符串，请返回覆盖率最高，单词最多的子字符串列表
示例：

```markdown
字符串: abcdefg
子字符串: ((ab，0, 1), (cd, 2, 3)，(efg，4, 6), (abc，0，2)，(abcd, 0, 3), (cdef, 2, 5))
期望: {ab, cd, efg}
```

* 分析


### 最长不重复子串
给定一个字符串，请你找出其中不含有重复字符的 **最长子串** 的长度。
示例：
```markdown
 输入："adbdeacdmmm"
 输出：5
 解释：因为无重复的最长子串是"bdeac"或者"eacdm"
```

* 分析

首先本体如果使用两层for循环当然可以轻松搞定，但是时间复杂度也是O（n^2），显然不是很满意，所以需要想个法子将复杂度调整到O（n）。
因为是子串，不是子序列，所以肯定是一串连续的字符区域。头设定为start，尾设定为end。那么在仅仅遍历一遍的情况下，start是会不断往后涨的，end就是当前遍历的位置。
    1. 如果当前遍历的字符在start后面没有出现过，则接着遍历，start往后移
    2. 如果当前遍历的字符已经出现了（这里可以使用hash表记录，key是character，value是index），则说明肯定有字符重复，需要将start移到这个重复字符处，也就是遍历的字符上一次出现的位置的下一个位置（index）
    3. 在这个过程中，时刻更新最大长度
    
* 解法

代码实现：

```swift
//code1
extension String {
    subscript(_ i: Int)->Character {
        get {return self[index(startIndex, offsetBy: i)]}
    }
}
```

code1是为了给string添加subscript操作，真正功能代码是：  
```swift
    //code2
    func lengthOfLongestSubstring(_ s: String) -> (Int, String?) {
        if s.isEmpty {
            return (0, nil)
        }
        var maxLength = 0
        var start = maxLength
        
        var retString: String? = " "
        
        var hashTable: Dictionary<Character, Int> = [Character:Int]()
                
        for i in 0..<s.count {
            if hashTable.keys.contains(s[i]) && hashTable[s[i]]! >= start {
                start = hashTable[s[i]]!+1
            }
            
            hashTable[s[i]] = i
            
            maxLength = max(maxLength, i+1-start)
        }
        
        return (maxLength, retString!)
    }
```
当然code2实际上只是输出长度并没有输出子字符串，我们尝试着输出长度和子字符串，其实就是在code2的基础上稍微改一下：
```swift
    //code3
    func lengthOfLongestSubstring(_ s: String) -> (Int, String?) {
        if s.isEmpty {
            return (0, nil)
        }
        
        var maxLength = 0
        var start = maxLength
        
        var retString: String? = " "
        let strArray = Array(s)
        
        var hashTable: Dictionary<Character, Int> = [Character:Int]()
                
        for i in 0..<s.count {
            if hashTable.keys.contains(s[i]) && hashTable[s[i]]! >= start {
                start = hashTable[s[i]]!+1
            }
            
            hashTable[s[i]] = i
            
            //此处就是获取子串，由于会一直遍历到最后，所以如果有多个相等长度的子串，会停留在最后一个子串，返回
            if i+1-start >= maxLength {
                let subArr = strArray[start..<i+1]
                let subStr: String = subArr.map{String.init($0)}.joined()
                retString = subStr
            }
            
            maxLength = max(maxLength, i+1-start)
        }

        return (maxLength, retString!)
    }
```

示例代码如下:
```swift
var solution = Solution()
var turple1 = solution.lengthOfLongestSubstring("adbdeacdmmm")

print(turple1)
```
以“adbdeacdmmm”为例，则长度为5，子串为："bdeac"或者"eacdm"，但是由于“eacdm”在后面，所以输出的是“eacdm”
可以看到：

![lengthOfLongestSubstring]({{site.url}}/assets/images/posts/leetcode_lengthOfLongestSubstring.jpg)

### 最长公共前缀
编写一个函数来查找字符串数组中的最长公共前缀。
如果不存在公共前缀，返回空字符串"" 
示例：
```markdown
输入：["flower","flow","flight"]
输出："fl"
```
*说明*
所有的输入只包含小写字母`a-z`
* 解法一

暴力循环法，从题目可知：**最长公共前缀的长度一定是字符串数组中长度最短的哪个字符串**
1. 首先找出长度最短的字符串str，比如str="abcf"。
2. 以此对'abcf','abc','ab','a'进行筛选，判断哪个是所有的其他字符串的前缀。

* 解法二

看下图：

![longestCommonPrefix]({{site.url}}/assets/images/posts/leetcode_longestCommonPrefix.jpg)

对str[0]按照字符遍历，与其他字符串以此比较对应位置上的字符，并记录查找位置，如果找到不相等或者对应字符串的长度到了限制，就找到了。

代码如下：
```swift
    func longestCommonPrefix(_ strs: [String]) -> String {
        if strs.count <= 0 {
            return ""
        }
        
        if strs.count == 1 {
            return strs[0]
        }
        
        let str = strs[0]
        for i in 0..<str.count {
            let c: Character = str[i]
            for j in 1..<strs.count {
                if i == strs[j].count || c != strs[j][i] {
                    let rightIndex = strs[0].index(strs[0].startIndex, offsetBy: i)
                    return String(strs[0][strs[0].startIndex..<rightIndex])
                }
            }
        }
        
        return strs[0]
    }
```
测试：

```swift
let strs2: [String] = ["abcdfj", "abc", "abcmnihiuh", "abcmunh"]
let str2: String = solution.longestCommonPrefix(strs2)
print(str2)
```

结果：
> abc

## 数组
### 按频率对整数数组进行排序
应该按频率对数组排序，如果相同的频率则对整数排序
示例：

```markdown
输入：1 1 1 1 1 2 1 2 3 3 3 3 3
输出：1 1 1 1 1 1 3 3 3 3 3 2 2
```

思路：
用hashmap存放数字出现的次数，然后对hashmap的value进行排序

代码实现：

```swift
    func sortFrequencyArray(source: [Int]) -> [Int] {
        if source.count <= 1 {
            return source
        }
        
        //key是数字，value是出现的频率
        var hashTable: Dictionary<Int, Int> = [Int:Int]()
        for i in 0..<source.count {
            let key: Int = source[i]
            
            if hashTable.keys.contains(key) {
                //更新数值
                var value = hashTable[key]
                value! += 1
                hashTable[key] = value
            } else {
                hashTable[key] = 1
            }
        }
        
        let values = hashTable.sorted{
            if $0.1 == $1.1 {
                //如果value（频率）相等，则按照key倒序
                return $0.0 > $1.0
            }
            
            //如果value（频率）不等，则按照value倒序
            return $0.1 > $1.1
        }
        
        var result: [Int] = [Int]()
        
        for i in 0..<values.count {
            for _ in 0..<values[i].1 {
                result.append(values[i].0)
            }
        }
        
        return result
    }
```

测试：

```swift
let array6 = [8,8,8,8,8,8,8,8,8,8,8,8,8,7,7,1,1,6,6,1,1,1,2,1,2,4,4,3,3,5,5]
let array7 = solution.sortFrequencyArray(source: array6)
print(array7)
```

结果：
> [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 1, 1, 1, 1, 1, 1, 7, 7, 6, 6, 5, 5, 4, 4, 3, 3, 2, 2]

## 链表
### 合并两个排过序的链表，并将其作为新链表

示例：
```markdown
输入：1-＞2-＞4,1-＞3-＞4
输出：1-＞1-＞2-＞3-＞4-＞4
```

思路：
很简单，就是链表遍历，然后变换next就可以了

代码实现：

链表构造
```swift
class Node<T> {
    var value: T
    var next: Node<T>?
    init(_ val: T) {
        self.value = val
        self.next = nil
    }
}

class IntLinkList {
    var head: Node<Int>?
    var tail: Node<Int>?
    
    init() {
        tail = nil
        head = tail
    }
    
    var isEmpty: Bool {
        get {
            return head == nil
        }
    }
    
    func append(value: Int) {
        let node = Node(value)
        if tail == nil {
            tail = node
            head = tail
        } else {
            tail!.next = node
            tail = tail!.next
        }
    }
    
    func appendToHead(value: Int) {
        let node = Node(value)
        if head == nil {
            head = node
            tail = head
        } else {
            node.next = head?.next
            head = node
        }
    }
    
    func insertAt(index: Int, value: Int) {
        if index == 0 {
            self.appendToHead(value: value)
        }
        
        var tmp = head
        
        var i: Int = 0
        
        while i != index && tmp == nil {
            tmp = tmp?.next
            i+=1
        }
        
        if i == index {
            let node = Node(value)
            node.next = tmp?.next
            tmp?.next = node
        } else {
            //说明index太大，还没到，链表就走完了
            self.append(value: value)
        }
    }
}
```

功能

```swift
//left和right是已经排好序的链表
    func bindTwoLink(firstList left: IntLinkList, second right: IntLinkList) -> IntLinkList {
        guard !left.isEmpty else {return right}
        
        guard !left.isEmpty else {return right}
        
        let list = IntLinkList()
        
        var currentLeft = left.head
        var currentRight = right.head
        
        if let leftNode = currentLeft , let rightNode = currentRight {
            if leftNode.value < rightNode.value {
                list.head = leftNode
                currentLeft = leftNode.next
            } else {
                list.head = rightNode
                currentRight = rightNode.next
            }
            list.tail = list.head
        }
        
        while let leftNode = currentLeft, let rightNode = currentRight {
            if leftNode.value < rightNode.value {
                list.tail?.next = leftNode
                currentLeft = leftNode.next
            } else {
                list.tail?.next = rightNode
                currentRight = rightNode.next
            }
            list.tail = list.tail?.next
        }
        
        //此处还有最后两个尾端没有遍历到
        if let leftNode = currentLeft {list.tail?.next = leftNode}
        if let rightNode = currentRight {list.tail?.next = rightNode}
        
        return list
    }
```

测试：

```swift
let list1 = IntLinkList()
list1.append(value: 1)
list1.append(value: 2)
list1.append(value: 4)
list1.append(value: 5)
list1.append(value: 22)

let list2 = IntLinkList()
list2.append(value: 1)
list2.append(value: 3)
list2.append(value: 4)
list2.append(value: 5)
list2.append(value: 6)
list2.append(value: 7)
list2.append(value: 8)

let list = solution.bindTwoLink(firstList: list1, second: list2)

var head = list.head

while head?.next != nil  {
    print(head!.value as Any, terminator: " ")
    head = head!.next
}

print(head!.value)
```

结果：
> 1 1 2 3 4 4 5 5 6 7 8 22

## 树
树是最常用且非常有用的数据结构之一，通过下图可以很容易理解树的概念。

![leetcode_tree]({{site.url}}/assets/images/posts/leetcode_tree.jpg)

上图展示的是一个拥有5个层级数的树结构。树根root是第0层，从树最外层开始每深入一层，其层级树相应的减1。
树能帮你解决很多问题，包括：
* 表示对象的层级关系
* 使查询快速高效
* 能提供有序的数据链
* 文本的前缀匹配搜索

### swift构造树

```swift
class TreeNode<T> {
    var value: T
    var children: [TreeNode] = []
    weak var parent: TreeNode?
    
    init(value: T) {
        self.value = value
    }
    
    func add(child: TreeNode) {
        children.append(child)
        child.parent = self
    }
}
```

但是这种是没办法被print打印出来的。需要：

```swift
extension TreeNode: CustomStringConvertible {
    var description: String {
        var text = "\(value)"
        if !children.isEmpty {
            text += "{"+children.map{$0.description}.joined(separator: ", ")+"}"
        }
        return text
    }
}
```

搜索：

```swift
extension TreeNode where T: Equatable {
    func search(value: T) -> TreeNode? {
        if value == self.value {
            return self
        }
        
        for child in children {
            if let found = child.search(value: value) {
                return found
            }
        }
        
        return nil
    }
}
```

### 为数组建立二进制搜索树，并搜索范围内的节点
示例：

```markdown
输入：int型数组[7, 20，9，10，25，16，2，40]
范围：[9,35]
输出：9，10，20, 25, 16
```

思路：

构建BST：

```swift
class BinarySearchTree<T: Comparable> {
    private(set) public var value: T
    private(set) public var parent: BinarySearchTree?
    private(set) public var left: BinarySearchTree?
    private(set) public var right: BinarySearchTree?
    
    init(value: T) {
        self.value = value
    }
    
    var isRoot: Bool {
        return parent == nil
    }
    
    var isLeaf: Bool {
        return left == nil && right == nil
    }
    
    var isLeftChild: Bool {
        return parent?.left === self
    }
    
    var isRightChild: Bool {
        return parent?.right === self
    }
    
    var hasLeftChild: Bool {
        return left != nil
    }
    
    var hasRightChild: Bool {
        return right != nil
    }
    
    var hasBothChildren: Bool {
        return hasLeftChild && hasRightChild
    }
    
    var count: Int {
        return (left?.count ?? 0)+1+(right?.count ?? 0)
    }
  
    func insert(value: T) {
        if value < self.value {
            if let left = left {
                left.insert(value: value)
            } else {
                left = BinarySearchTree(value: value)
                left?.parent = self
            }
        } else {
            if let right = right {
                right.insert(value: value)
            } else {
                right = BinarySearchTree(value: value)
                right?.parent = self
            }
        }
    }
}
```

功能函数：

```swift
//获取[9,35]
    func findTree(tree: BinarySearchTree<Int>) {
        if tree.value <= 9 {
            //在右边找
            if tree.value == 9 {
                print(tree.value, terminator: " ")
            }
            
            if tree.hasRightChild {
                findTree(tree: tree.right!)
            }
        } else if tree.value >= 35 {
            //在左边找
            if tree.value == 35 {
                print(tree.value, terminator: " ")
            }
            
            if tree.hasLeftChild {
                findTree(tree: tree.left!)
            }
        } else if tree.value > 9 && tree.value < 35 {
            print(tree.value, terminator: " ")
            if tree.hasLeftChild {
                findTree(tree: tree.left!)
            }
            if tree.hasRightChild {
                findTree(tree: tree.right!)
            }
        }
    }
```



测试：

```swift
let tree = BinarySearchTree<Int>(value: 7)
tree.insert(value: 20)
tree.insert(value: 9)
tree.insert(value: 10)
tree.insert(value: 25)
tree.insert(value: 16)
tree.insert(value: 2)
tree.insert(value: 40)
print(tree)
```

> **(2) <- 7 -> ((9 -> (10 -> (16))) <- 20 -> (25 -> (40)))**
>
> **20 9 10 16 25** 



## 杂项

### 求解n！的结果中有多少个0

+ 思路

  首先我们知道10=2*5，所以有多少个0取决于有多少个2*5。而n！中包含5的因子的个数，可以用下面的表达式来计算

  k= n/5+n/5^2+n/5^3+...

  同样的n！包含2的因子的个数可以用下面的表达式来计算

  m= n/2+n/2^2+n/2^3+...

  很显然m>k。所以末尾0的个数是min(m,k)也就是k了。

+ 实现

  
  
  ```swift
func trailing_zero_num(number: Int) -> Int {
          var num = 0
          var n = number
          while Bool(truncating: n as NSNumber) {
              num += n/5
              n = n/5
          }
          return num
   }
  ```
  
  
  
  

