<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="zh-Hans"><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" hreflang="zh-Hans" /><updated>2022-05-02T03:34:03+00:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Argost’s Home</title><subtitle>My personal Blog Site
</subtitle><author><name>Cambria Yang</name><email>cambriayang@qq.com</email></author><entry><title type="html">杂项算法</title><link href="http://localhost:4000/algorithm/2022/03/08/%E6%9D%82%E9%A1%B9%E7%AE%97%E6%B3%95.html" rel="alternate" type="text/html" title="杂项算法" /><published>2022-03-08T07:00:00+00:00</published><updated>2022-03-08T07:00:00+00:00</updated><id>http://localhost:4000/algorithm/2022/03/08/%E6%9D%82%E9%A1%B9%E7%AE%97%E6%B3%95</id><content type="html" xml:base="http://localhost:4000/algorithm/2022/03/08/%E6%9D%82%E9%A1%B9%E7%AE%97%E6%B3%95.html"><![CDATA[<p>一些算法举例</p>

<h2 id="杂项">杂项</h2>

<h3 id="产生不重复的随机数">产生不重复的随机数</h3>

<ul>
  <li>思路</li>
</ul>

<p>设想一下，有n个苹果，有不同的编号，从1-n，每次拿一个出来。来产生不同的随机数</p>

<ul>
  <li>实现</li>
</ul>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">randomNumberWithoutDuplication</span><span class="p">(</span><span class="n">_</span> <span class="nv">number</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span> <span class="p">{</span>
  <span class="k">var</span> <span class="nv">resultArr</span> <span class="o">=</span> <span class="kt">Array</span><span class="p">(</span><span class="nv">repeating</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="nv">count</span><span class="p">:</span> <span class="n">number</span><span class="p">)</span>
  <span class="k">var</span> <span class="nv">startArr</span> <span class="o">=</span> <span class="kt">Array</span><span class="p">(</span><span class="mi">1</span><span class="o">...</span><span class="n">number</span><span class="p">)</span>

  <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..&lt;</span><span class="n">startArr</span><span class="o">.</span><span class="n">count</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">currentCount</span> <span class="o">=</span> <span class="kt">UInt32</span><span class="p">(</span><span class="n">startArr</span><span class="o">.</span><span class="n">count</span><span class="o">-</span><span class="n">i</span><span class="p">)</span>
    <span class="k">let</span> <span class="nv">index</span> <span class="o">=</span> <span class="kt">Int</span><span class="p">(</span><span class="nf">arc4random_uniform</span><span class="p">(</span><span class="n">currentCount</span><span class="p">))</span>
    <span class="n">resultArr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">startArr</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
    <span class="n">startArr</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">startArr</span><span class="p">[</span><span class="kt">Int</span><span class="p">(</span><span class="n">currentCount</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">resultArr</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>测试</li>
</ul>

<blockquote>
  <p>let aaa = solution.randomNumberWithoutDuplication(10)</p>

  <p>[1, 5, 8, 9, 4, 3, 10, 2, 6, 7]</p>
</blockquote>

<h3 id="求解n的结果中有多少个0">求解n！的结果中有多少个0</h3>

<ul>
  <li>
    <p>思路</p>

    <p>首先我们知道10=2<em>5，所以有多少个0取决于有多少个2</em>5。而n！中包含5的因子的个数，可以用下面的表达式来计算</p>

    <p>k= n/5+n/5^2+n/5^3+…</p>

    <p>同样的n！包含2的因子的个数可以用下面的表达式来计算</p>

    <p>m= n/2+n/2^2+n/2^3+…</p>

    <p>很显然m&gt;k。所以末尾0的个数是min(m,k)也就是k了。</p>
  </li>
  <li>
    <p>实现</p>

    <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">trailing_zero_num</span><span class="p">(</span><span class="nv">number</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="p">{</span>
  <span class="k">var</span> <span class="nv">num</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="k">var</span> <span class="nv">n</span> <span class="o">=</span> <span class="n">number</span>
  <span class="k">while</span> <span class="kt">Bool</span><span class="p">(</span><span class="nv">truncating</span><span class="p">:</span> <span class="n">n</span> <span class="k">as</span> <span class="kt">NSNumber</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">num</span> <span class="o">+=</span> <span class="n">n</span><span class="o">/</span><span class="mi">5</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">n</span><span class="o">/</span><span class="mi">5</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">num</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
</ul>

<h3 id="多线程交替打印ab分别10次">多线程交替打印A，B分别10次</h3>

<ul>
  <li>实现</li>
</ul>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">outABWithGCD</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">let</span> <span class="nv">queue1</span> <span class="o">=</span> <span class="kt">DispatchQueue</span><span class="p">(</span><span class="nv">label</span><span class="p">:</span> <span class="s">"com.queue1.a"</span><span class="p">,</span> <span class="nv">qos</span><span class="p">:</span> <span class="o">.</span><span class="n">utility</span><span class="p">)</span>
  <span class="k">let</span> <span class="nv">queue2</span> <span class="o">=</span> <span class="kt">DispatchQueue</span><span class="p">(</span><span class="nv">label</span><span class="p">:</span> <span class="s">"com.queue2.b"</span><span class="p">,</span> <span class="nv">qos</span><span class="p">:</span> <span class="o">.</span><span class="n">utility</span><span class="p">)</span>

  <span class="k">var</span> <span class="nv">change</span><span class="p">:</span> <span class="kt">Bool</span> <span class="o">=</span> <span class="kc">true</span>

  <span class="n">queue1</span><span class="o">.</span><span class="k">async</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">count1</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="kc">true</span> <span class="p">{</span>
      <span class="k">if</span> <span class="n">change</span> <span class="p">{</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"queue1:A"</span><span class="p">)</span>
        <span class="n">change</span> <span class="o">=</span> <span class="kc">false</span>
        <span class="n">count1</span><span class="o">+=</span><span class="mi">1</span>
      <span class="p">}</span>

      <span class="k">if</span> <span class="n">count1</span> <span class="o">==</span> <span class="mi">10</span> <span class="p">{</span>
        <span class="k">break</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="n">queue2</span><span class="o">.</span><span class="k">async</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">count2</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="kc">true</span> <span class="p">{</span>
      <span class="k">if</span> <span class="o">!</span><span class="n">change</span> <span class="p">{</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"queue2:B"</span><span class="p">)</span>
        <span class="n">change</span> <span class="o">=</span> <span class="kc">true</span>
        <span class="n">count2</span><span class="o">+=</span><span class="mi">1</span>
      <span class="p">}</span>

      <span class="k">if</span> <span class="n">count2</span> <span class="o">==</span> <span class="mi">10</span> <span class="p">{</span>
        <span class="k">break</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>示例</li>
</ul>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">solution</span><span class="o">.</span><span class="nf">outABWithGCD</span><span class="p">()</span>
</code></pre></div></div>

<ul>
  <li>结果</li>
</ul>

<blockquote>
  <p><strong>queue1:A</strong></p>

  <p><strong>queue2:B</strong></p>

  <p><strong>queue1:A</strong></p>

  <p><strong>queue2:B</strong></p>

  <p><strong>queue1:A</strong></p>

  <p><strong>queue2:B</strong></p>

  <p><strong>queue1:A</strong></p>

  <p><strong>queue2:B</strong></p>

  <p><strong>queue1:A</strong></p>

  <p><strong>queue2:B</strong></p>

  <p><strong>queue1:A</strong></p>

  <p><strong>queue2:B</strong></p>

  <p><strong>queue1:A</strong></p>

  <p><strong>queue2:B</strong></p>

  <p><strong>queue1:A</strong></p>

  <p><strong>queue2:B</strong></p>

  <p><strong>queue1:A</strong></p>

  <p><strong>queue2:B</strong></p>

  <p><strong>queue1:A</strong></p>

  <p>queue2:B</p>
</blockquote>

<h2 id="动态或贪心">动态或贪心</h2>

<h3 id="买卖股票的最佳时机">买卖股票的最佳时机</h3>

<p>给定一个数组，它的第i个元素是一支给定股票第i天的价格。</p>

<p>如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。</p>

<p><strong>注意</strong>： 你不能再买入股票前卖出股票。</p>

<ul>
  <li>示例</li>
</ul>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code>输入：[7,1,5,3,6,4]
输出： 5
解释： 在第2天（股票价格=1）的时候买入，在第5天（=6），最大利润=6-1=5.注意利润不可能是7-1

输入： [7,6,4,3,1]
输出： 0
解释： 在这种情况下，没有交易完成，所以利润为0.
</code></pre></div></div>

<ul>
  <li>思路</li>
</ul>

<p>需要找到最小的谷之后的最大的峰。 我们可以维持两个变量——minprice 和 maxprofit，它们分别对应迄今为止所得到的最小的谷值和最大的利润（卖出价格与最低价格之间的最大差值）。</p>

<ul>
  <li>解法</li>
</ul>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">maxProfit</span><span class="p">(</span><span class="n">_</span> <span class="nv">prices</span><span class="p">:</span> <span class="p">[</span><span class="kt">Int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="p">{</span>
  <span class="k">var</span> <span class="nv">minPrice</span> <span class="o">=</span> <span class="kt">Int</span><span class="o">.</span><span class="n">max</span>
  <span class="k">var</span> <span class="nv">maxProfit</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..&lt;</span><span class="n">prices</span><span class="o">.</span><span class="n">count</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">minPrice</span> <span class="p">{</span>
      <span class="n">minPrice</span> <span class="o">=</span> <span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">minPrice</span> <span class="o">&gt;</span> <span class="n">maxProfit</span> <span class="p">{</span>
      <span class="n">maxProfit</span> <span class="o">=</span> <span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="n">minPrice</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">maxProfit</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>结果</li>
</ul>

<blockquote>
  <p>print(solution.maxProfit([7,1,5,3,6,4]))</p>

  <p>5</p>
</blockquote>

<h3 id="买卖股票的最佳时机ii">买卖股票的最佳时机II</h3>

<ul>
  <li>示例</li>
</ul>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code>输入：[7,1,5,3,6,4]
输出：7
解释：在第2天（=1）买入，第三天（=5）卖出，利润4，然后在第4天（=3）买入，第5天（=6）卖出，利润3
总利润3+4=7
</code></pre></div></div>

<ul>
  <li>思路</li>
</ul>

<p>在斜坡上爬升并持续增加从交易中获得的利润</p>

<p><img src="http://localhost:4000/assets/images/posts/leetcode_maxprofit.jpg" alt="leetcode_maxprofit" /></p>

<ul>
  <li>解法</li>
</ul>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">maxProfitII</span><span class="p">(</span><span class="n">_</span> <span class="nv">prices</span><span class="p">:</span> <span class="p">[</span><span class="kt">Int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="p">{</span>
  <span class="k">if</span> <span class="n">prices</span><span class="o">.</span><span class="n">count</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">0</span>
  <span class="p">}</span>

  <span class="k">var</span> <span class="nv">maxProfit</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">1</span><span class="o">..&lt;</span><span class="n">prices</span><span class="o">.</span><span class="n">count</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="p">{</span>
      <span class="n">maxProfit</span> <span class="o">+=</span> <span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">maxProfit</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>结果</li>
</ul>

<blockquote>
  <p>print(solution.maxProfitII([7,1,5,3,6,4]))</p>

  <p>7</p>
</blockquote>

<h3 id="滑动窗口最大值">滑动窗口最大值</h3>

<p>给定一个Int窗口，实时的输出窗口最大的元素</p>

<ul>
  <li>示例</li>
</ul>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code>输入：k=3，nums=[1,3,-1,-3,5,3,6]
输出：[3,3,5,5,6]
</code></pre></div></div>

<ul>
  <li>思路</li>
</ul>

<p>窗口为3个位置，只要有一个最大值进来，比他早的元素永远没有出头之日，所以可以直接忽略掉。</p>

<ul>
  <li>解法</li>
</ul>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">findMaxInWindow</span><span class="p">(</span><span class="n">_</span> <span class="nv">count</span><span class="p">:</span> <span class="kt">Int</span><span class="p">,</span> <span class="n">_</span> <span class="nv">nums</span><span class="p">:</span> <span class="p">[</span><span class="kt">Int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span> <span class="p">{</span>
  <span class="k">var</span> <span class="nv">res</span> <span class="o">=</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]()</span>

  <span class="k">if</span> <span class="n">nums</span><span class="o">.</span><span class="n">count</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">[]</span>
  <span class="p">}</span>

  <span class="k">var</span> <span class="nv">maxNum</span> <span class="o">=</span> <span class="kt">Int</span><span class="o">.</span><span class="n">min</span>

  <span class="k">if</span> <span class="n">nums</span><span class="o">.</span><span class="n">count</span> <span class="o">&lt;</span> <span class="n">count</span> <span class="p">{</span>
    <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..&lt;</span><span class="n">nums</span><span class="o">.</span><span class="n">count</span> <span class="p">{</span>
      <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">maxNum</span> <span class="p">{</span>
        <span class="n">maxNum</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">res</span><span class="o">.</span><span class="nf">append</span><span class="p">(</span><span class="n">maxNum</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">res</span>
  <span class="p">}</span>

  <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..&lt;</span><span class="n">count</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">maxNum</span> <span class="p">{</span>
      <span class="n">maxNum</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="n">res</span><span class="o">.</span><span class="nf">append</span><span class="p">(</span><span class="n">maxNum</span><span class="p">)</span>

  <span class="k">for</span> <span class="n">j</span> <span class="nf">in</span> <span class="p">(</span><span class="n">nums</span><span class="o">.</span><span class="n">count</span><span class="o">-</span><span class="n">count</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">..&lt;</span><span class="n">nums</span><span class="o">.</span><span class="n">count</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">maxNum</span> <span class="p">{</span>
      <span class="n">maxNum</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
    <span class="p">}</span>

    <span class="n">res</span><span class="o">.</span><span class="nf">append</span><span class="p">(</span><span class="n">maxNum</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">res</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>结果</li>
</ul>

<blockquote>
  <p>let r15 = solution.findMaxInWindow(3, [1,3,-1,-3,5,3,6])</p>

  <p>print(r15)</p>

  <p><strong>[3, 3, 5, 5, 6]</strong></p>
</blockquote>

<h3 id="生成小括号字符串">生成小括号字符串</h3>

<p>给定固定长度，比如n，生成所有合法的小括号组成形式</p>

<ul>
  <li>示例</li>
</ul>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code>输入: n=3
输出: ["((()))", "(()())", "(())()", "()(())", "()()()"]
</code></pre></div></div>

<ul>
  <li>思路</li>
</ul>

<p>采用递归，但是要注意，左右括号肯定都是为n个，并且左括号可以随意加（不超过n），但是右括号必须要在左括号大于右括号的时候才可以输入，然后递归即可</p>

<ul>
  <li>解法</li>
</ul>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">generateParenthesis</span><span class="p">(</span><span class="n">_</span> <span class="nv">count</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="kt">String</span><span class="p">]</span> <span class="p">{</span>
  <span class="k">var</span> <span class="nv">res</span><span class="p">:</span> <span class="p">[</span><span class="kt">String</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="kt">String</span><span class="p">]()</span>
  <span class="nf">_gen</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="s">""</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">res</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">res</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">_gen</span><span class="p">(</span><span class="n">_</span> <span class="nv">left</span><span class="p">:</span> <span class="kt">Int</span><span class="p">,</span> <span class="n">_</span> <span class="nv">right</span><span class="p">:</span> <span class="kt">Int</span><span class="p">,</span> <span class="n">_</span> <span class="nv">count</span><span class="p">:</span> <span class="kt">Int</span><span class="p">,</span> <span class="n">_</span> <span class="nv">result</span><span class="p">:</span> <span class="kt">String</span><span class="p">,</span> <span class="n">_</span> <span class="nv">res</span><span class="p">:</span> <span class="k">inout</span> <span class="p">[</span><span class="kt">String</span><span class="p">])</span> <span class="p">{</span>
  <span class="c1">//递归出口</span>
  <span class="k">if</span> <span class="n">left</span> <span class="o">==</span> <span class="n">count</span> <span class="o">&amp;&amp;</span> <span class="n">right</span> <span class="o">==</span> <span class="n">count</span> <span class="p">{</span>
    <span class="n">res</span><span class="o">.</span><span class="nf">append</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="n">left</span> <span class="o">&lt;</span> <span class="n">count</span> <span class="p">{</span>
    <span class="nf">_gen</span><span class="p">(</span><span class="n">left</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">result</span><span class="o">+</span><span class="s">"("</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">res</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="n">left</span> <span class="o">&gt;</span> <span class="n">right</span> <span class="o">&amp;&amp;</span> <span class="n">right</span> <span class="o">&lt;</span> <span class="n">count</span> <span class="p">{</span>
    <span class="nf">_gen</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">result</span><span class="o">+</span><span class="s">")"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">res</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>结果</li>
</ul>

<blockquote>
  <p>let r16 = solution.generateParenthesis(3)</p>

  <p>print(r16)</p>

  <p><strong>[”((()))”, “(()())”, “(())()”, “()(())”, “()()()”]</strong></p>
</blockquote>]]></content><author><name>Cambria Yang</name><email>cambriayang@qq.com</email></author><category term="Algorithm" /><category term="算法" /><summary type="html"><![CDATA[一些算法举例 杂项 产生不重复的随机数 思路 设想一下，有n个苹果，有不同的编号，从1-n，每次拿一个出来。来产生不同的随机数 实现 func randomNumberWithoutDuplication(_ number: Int) -&gt; [Int] { var resultArr = Array(repeating: 0, count: number) var startArr = Array(1...number) for i in 0..&lt;startArr.count { let currentCount = UInt32(startArr.count-i) let index = Int(arc4random_uniform(currentCount)) resultArr[i] = startArr[index] startArr[index] = startArr[Int(currentCount) - 1] } return resultArr } 测试 let aaa = solution.randomNumberWithoutDuplication(10) [1, 5, 8, 9, 4, 3, 10, 2, 6, 7] 求解n！的结果中有多少个0 思路 首先我们知道10=25，所以有多少个0取决于有多少个25。而n！中包含5的因子的个数，可以用下面的表达式来计算 k= n/5+n/5^2+n/5^3+… 同样的n！包含2的因子的个数可以用下面的表达式来计算 m= n/2+n/2^2+n/2^3+… 很显然m&gt;k。所以末尾0的个数是min(m,k)也就是k了。 实现 func trailing_zero_num(number: Int) -&gt; Int { var num = 0 var n = number while Bool(truncating: n as NSNumber) { num += n/5 n = n/5 } return num } 多线程交替打印A，B分别10次 实现 func outABWithGCD() { let queue1 = DispatchQueue(label: "com.queue1.a", qos: .utility) let queue2 = DispatchQueue(label: "com.queue2.b", qos: .utility) var change: Bool = true queue1.async { var count1 = 0 while true { if change { print("queue1:A") change = false count1+=1 } if count1 == 10 { break } } } queue2.async { var count2 = 0 while true { if !change { print("queue2:B") change = true count2+=1 } if count2 == 10 { break } } } } 示例 solution.outABWithGCD() 结果 queue1:A queue2:B queue1:A queue2:B queue1:A queue2:B queue1:A queue2:B queue1:A queue2:B queue1:A queue2:B queue1:A queue2:B queue1:A queue2:B queue1:A queue2:B queue1:A queue2:B 动态或贪心 买卖股票的最佳时机 给定一个数组，它的第i个元素是一支给定股票第i天的价格。 如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。 注意： 你不能再买入股票前卖出股票。 示例 输入：[7,1,5,3,6,4] 输出： 5 解释： 在第2天（股票价格=1）的时候买入，在第5天（=6），最大利润=6-1=5.注意利润不可能是7-1 输入： [7,6,4,3,1] 输出： 0 解释： 在这种情况下，没有交易完成，所以利润为0. 思路 需要找到最小的谷之后的最大的峰。 我们可以维持两个变量——minprice 和 maxprofit，它们分别对应迄今为止所得到的最小的谷值和最大的利润（卖出价格与最低价格之间的最大差值）。 解法 func maxProfit(_ prices: [Int]) -&gt; Int { var minPrice = Int.max var maxProfit = 0 for i in 0..&lt;prices.count { if prices[i] &lt; minPrice { minPrice = prices[i] } else if prices[i] - minPrice &gt; maxProfit { maxProfit = prices[i]-minPrice } } return maxProfit } 结果 print(solution.maxProfit([7,1,5,3,6,4])) 5 买卖股票的最佳时机II 示例 输入：[7,1,5,3,6,4] 输出：7 解释：在第2天（=1）买入，第三天（=5）卖出，利润4，然后在第4天（=3）买入，第5天（=6）卖出，利润3 总利润3+4=7 思路 在斜坡上爬升并持续增加从交易中获得的利润 解法 func maxProfitII(_ prices: [Int]) -&gt; Int { if prices.count &lt; 2 { return 0 } var maxProfit = 0 for i in 1..&lt;prices.count { if prices[i] &gt; prices[i-1] { maxProfit += prices[i]-prices[i-1] } } return maxProfit } 结果 print(solution.maxProfitII([7,1,5,3,6,4])) 7 滑动窗口最大值 给定一个Int窗口，实时的输出窗口最大的元素 示例 输入：k=3，nums=[1,3,-1,-3,5,3,6] 输出：[3,3,5,5,6] 思路 窗口为3个位置，只要有一个最大值进来，比他早的元素永远没有出头之日，所以可以直接忽略掉。 解法 func findMaxInWindow(_ count: Int, _ nums: [Int]) -&gt; [Int] { var res = [Int]() if nums.count &lt; 0 { return [] } var maxNum = Int.min if nums.count &lt; count { for i in 0..&lt;nums.count { if nums[i] &gt; maxNum { maxNum = nums[i] } } res.append(maxNum) return res } for i in 0..&lt;count { if nums[i] &gt; maxNum { maxNum = nums[i] } } res.append(maxNum) for j in (nums.count-count-1)..&lt;nums.count { if nums[j] &gt; maxNum { maxNum = nums[j] } res.append(maxNum) } return res } 结果 let r15 = solution.findMaxInWindow(3, [1,3,-1,-3,5,3,6]) print(r15) [3, 3, 5, 5, 6] 生成小括号字符串 给定固定长度，比如n，生成所有合法的小括号组成形式 示例 输入: n=3 输出: ["((()))", "(()())", "(())()", "()(())", "()()()"] 思路 采用递归，但是要注意，左右括号肯定都是为n个，并且左括号可以随意加（不超过n），但是右括号必须要在左括号大于右括号的时候才可以输入，然后递归即可 解法 func generateParenthesis(_ count: Int) -&gt; [String] { var res: [String] = [String]() _gen(0, 0, count, "", &amp;res) return res } func _gen(_ left: Int, _ right: Int, _ count: Int, _ result: String, _ res: inout [String]) { //递归出口 if left == count &amp;&amp; right == count { res.append(result) } if left &lt; count { _gen(left+1, right, count, result+"(", &amp;res) } if left &gt; right &amp;&amp; right &lt; count { _gen(left, right+1, count, result+")", &amp;res) } } 结果 let r16 = solution.generateParenthesis(3) print(r16) [”((()))”, “(()())”, “(())()”, “()(())”, “()()()”]]]></summary></entry><entry><title type="html">树算法</title><link href="http://localhost:4000/algorithm/2022/03/08/%E6%A0%91%E7%AE%97%E6%B3%95.html" rel="alternate" type="text/html" title="树算法" /><published>2022-03-08T06:00:00+00:00</published><updated>2022-03-08T06:00:00+00:00</updated><id>http://localhost:4000/algorithm/2022/03/08/%E6%A0%91%E7%AE%97%E6%B3%95</id><content type="html" xml:base="http://localhost:4000/algorithm/2022/03/08/%E6%A0%91%E7%AE%97%E6%B3%95.html"><![CDATA[<p>一些算法举例</p>

<h2 id="树">树</h2>

<p>树是最常用且非常有用的数据结构之一，通过下图可以很容易理解树的概念。</p>

<p><img src="http://localhost:4000/assets/images/posts/leetcode_tree.jpg" alt="leetcode_tree" /></p>

<p>上图展示的是一个拥有5个层级数的树结构。树根root是第0层，从树最外层开始每深入一层，其层级树相应的减1。
树能帮你解决很多问题，包括：</p>

<ul>
  <li>表示对象的层级关系</li>
  <li>使查询快速高效</li>
  <li>能提供有序的数据链</li>
  <li>文本的前缀匹配搜索</li>
</ul>

<h3 id="swift构造树">swift构造树</h3>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">TreeNode</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">T</span>
    <span class="k">var</span> <span class="nv">children</span><span class="p">:</span> <span class="p">[</span><span class="kt">TreeNode</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">weak</span> <span class="k">var</span> <span class="nv">parent</span><span class="p">:</span> <span class="kt">TreeNode</span><span class="p">?</span>
    
    <span class="nf">init</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="kt">T</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>
    <span class="p">}</span>
    
    <span class="kd">func</span> <span class="nf">add</span><span class="p">(</span><span class="nv">child</span><span class="p">:</span> <span class="kt">TreeNode</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">children</span><span class="o">.</span><span class="nf">append</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
        <span class="n">child</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="k">self</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>但是这种是没办法被print打印出来的。需要：</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">extension</span> <span class="kt">TreeNode</span><span class="p">:</span> <span class="kt">CustomStringConvertible</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">description</span><span class="p">:</span> <span class="kt">String</span> <span class="p">{</span>
        <span class="k">var</span> <span class="nv">text</span> <span class="o">=</span> <span class="s">"</span><span class="se">\(</span><span class="n">value</span><span class="se">)</span><span class="s">"</span>
        <span class="k">if</span> <span class="o">!</span><span class="n">children</span><span class="o">.</span><span class="n">isEmpty</span> <span class="p">{</span>
            <span class="n">text</span> <span class="o">+=</span> <span class="s">"{"</span><span class="o">+</span><span class="n">children</span><span class="o">.</span><span class="n">map</span><span class="p">{</span><span class="nv">$0</span><span class="o">.</span><span class="n">description</span><span class="p">}</span><span class="o">.</span><span class="nf">joined</span><span class="p">(</span><span class="nv">separator</span><span class="p">:</span> <span class="s">", "</span><span class="p">)</span><span class="o">+</span><span class="s">"}"</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">text</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>搜索：</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">extension</span> <span class="kt">TreeNode</span> <span class="k">where</span> <span class="kt">T</span><span class="p">:</span> <span class="kt">Equatable</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">search</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="kt">T</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">TreeNode</span><span class="p">?</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">value</span> <span class="o">==</span> <span class="k">self</span><span class="o">.</span><span class="n">value</span> <span class="p">{</span>
            <span class="k">return</span> <span class="k">self</span>
        <span class="p">}</span>
        
        <span class="k">for</span> <span class="n">child</span> <span class="k">in</span> <span class="n">children</span> <span class="p">{</span>
            <span class="k">if</span> <span class="k">let</span> <span class="nv">found</span> <span class="o">=</span> <span class="n">child</span><span class="o">.</span><span class="nf">search</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="n">found</span>
            <span class="p">}</span>
        <span class="p">}</span>
        
        <span class="k">return</span> <span class="kc">nil</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="为数组建立二进制搜索树并搜索范围内的节点">为数组建立二进制搜索树，并搜索范围内的节点</h3>
<ul>
  <li>示例：</li>
</ul>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code>输入：int型数组[7, 20，9，10，25，16，2，40，16，6]
范围：[9,35]
输出：9，10，20, 25, 16
</code></pre></div></div>

<ul>
  <li>
    <p>思路：</p>
  </li>
  <li>
    <p>构建BST：</p>
  </li>
</ul>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">BinaryTree</span><span class="o">&lt;</span><span class="kt">T</span><span class="p">:</span> <span class="kt">Comparable</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="kd">public</span> <span class="k">var</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">T</span>
    <span class="kd">public</span> <span class="k">var</span> <span class="nv">parent</span><span class="p">:</span> <span class="kt">BinaryTree</span><span class="p">?</span>
    <span class="kd">public</span> <span class="k">var</span> <span class="nv">left</span><span class="p">:</span> <span class="kt">BinaryTree</span><span class="p">?</span>
    <span class="kd">public</span> <span class="k">var</span> <span class="nv">right</span><span class="p">:</span> <span class="kt">BinaryTree</span><span class="p">?</span>

    <span class="nf">init</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="kt">T</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>
    <span class="p">}</span>
    
    <span class="k">var</span> <span class="nv">isRoot</span><span class="p">:</span> <span class="kt">Bool</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">parent</span> <span class="o">==</span> <span class="kc">nil</span>
    <span class="p">}</span>
    
    <span class="k">var</span> <span class="nv">isLeaf</span><span class="p">:</span> <span class="kt">Bool</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">left</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="n">right</span> <span class="o">==</span> <span class="kc">nil</span>
    <span class="p">}</span>
    
    <span class="k">var</span> <span class="nv">isLeftChild</span><span class="p">:</span> <span class="kt">Bool</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">parent</span><span class="p">?</span><span class="o">.</span><span class="n">left</span> <span class="o">===</span> <span class="k">self</span>
    <span class="p">}</span>
    
    <span class="k">var</span> <span class="nv">isRightChild</span><span class="p">:</span> <span class="kt">Bool</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">parent</span><span class="p">?</span><span class="o">.</span><span class="n">right</span> <span class="o">===</span> <span class="k">self</span>
    <span class="p">}</span>
    
    <span class="k">var</span> <span class="nv">hasLeftChild</span><span class="p">:</span> <span class="kt">Bool</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">left</span> <span class="o">!=</span> <span class="kc">nil</span>
    <span class="p">}</span>
    
    <span class="k">var</span> <span class="nv">hasRightChild</span><span class="p">:</span> <span class="kt">Bool</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">right</span> <span class="o">!=</span> <span class="kc">nil</span>
    <span class="p">}</span>
    
    <span class="k">var</span> <span class="nv">hasBothChildren</span><span class="p">:</span> <span class="kt">Bool</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">hasLeftChild</span> <span class="o">&amp;&amp;</span> <span class="n">hasRightChild</span>
    <span class="p">}</span>
    
    <span class="k">var</span> <span class="nv">count</span><span class="p">:</span> <span class="kt">Int</span> <span class="p">{</span>
        <span class="nf">return</span> <span class="p">(</span><span class="n">left</span><span class="p">?</span><span class="o">.</span><span class="n">count</span> <span class="p">??</span> <span class="mi">0</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="o">+</span><span class="p">(</span><span class="n">right</span><span class="p">?</span><span class="o">.</span><span class="n">count</span> <span class="p">??</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="kt">BinarySearchTree</span><span class="o">&lt;</span><span class="kt">T</span><span class="p">:</span> <span class="kt">Comparable</span><span class="o">&gt;</span> <span class="p">:</span> <span class="kt">BinaryTree</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">insert</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="kt">T</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">value</span> <span class="o">&lt;</span> <span class="k">self</span><span class="o">.</span><span class="n">value</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">hasLeftChild</span> <span class="p">{</span>
                <span class="p">(</span><span class="n">left</span> <span class="k">as!</span> <span class="kt">BinarySearchTree</span><span class="p">)</span><span class="o">.</span><span class="nf">insert</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="n">value</span><span class="p">)</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">left</span> <span class="o">=</span> <span class="kt">BinarySearchTree</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="n">value</span><span class="p">)</span>
                <span class="n">left</span><span class="p">?</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="k">self</span>
            <span class="p">}</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">hasRightChild</span> <span class="p">{</span>
                <span class="p">(</span><span class="n">right</span> <span class="k">as!</span> <span class="kt">BinarySearchTree</span><span class="p">)</span><span class="o">.</span><span class="nf">insert</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="n">value</span><span class="p">)</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">right</span> <span class="o">=</span> <span class="kt">BinarySearchTree</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="n">value</span><span class="p">)</span>
                <span class="n">right</span><span class="p">?</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="k">self</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>功能函数：</li>
</ul>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//获取[9,35]</span>
    <span class="kd">func</span> <span class="nf">findTree</span><span class="p">(</span><span class="nv">tree</span><span class="p">:</span> <span class="kt">BinarySearchTree</span><span class="o">&lt;</span><span class="kt">Int</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">tree</span><span class="o">.</span><span class="n">value</span> <span class="o">&lt;=</span> <span class="mi">9</span> <span class="p">{</span>
            <span class="c1">//在右边找</span>
            <span class="k">if</span> <span class="n">tree</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="mi">9</span> <span class="p">{</span>
                <span class="nf">print</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="nv">terminator</span><span class="p">:</span> <span class="s">" "</span><span class="p">)</span>
            <span class="p">}</span>
            
            <span class="k">if</span> <span class="n">tree</span><span class="o">.</span><span class="n">hasRightChild</span> <span class="p">{</span>
                <span class="nf">findTree</span><span class="p">(</span><span class="nv">tree</span><span class="p">:</span> <span class="n">tree</span><span class="o">.</span><span class="n">right</span><span class="o">!</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">tree</span><span class="o">.</span><span class="n">value</span> <span class="o">&gt;=</span> <span class="mi">35</span> <span class="p">{</span>
            <span class="c1">//在左边找</span>
            <span class="k">if</span> <span class="n">tree</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="mi">35</span> <span class="p">{</span>
                <span class="nf">print</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="nv">terminator</span><span class="p">:</span> <span class="s">" "</span><span class="p">)</span>
            <span class="p">}</span>
            
            <span class="k">if</span> <span class="n">tree</span><span class="o">.</span><span class="n">hasLeftChild</span> <span class="p">{</span>
                <span class="nf">findTree</span><span class="p">(</span><span class="nv">tree</span><span class="p">:</span> <span class="n">tree</span><span class="o">.</span><span class="n">left</span><span class="o">!</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">tree</span><span class="o">.</span><span class="n">value</span> <span class="o">&gt;</span> <span class="mi">9</span> <span class="o">&amp;&amp;</span> <span class="n">tree</span><span class="o">.</span><span class="n">value</span> <span class="o">&lt;</span> <span class="mi">35</span> <span class="p">{</span>
            <span class="nf">print</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="nv">terminator</span><span class="p">:</span> <span class="s">" "</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">tree</span><span class="o">.</span><span class="n">hasLeftChild</span> <span class="p">{</span>
                <span class="nf">findTree</span><span class="p">(</span><span class="nv">tree</span><span class="p">:</span> <span class="n">tree</span><span class="o">.</span><span class="n">left</span><span class="o">!</span><span class="p">)</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="n">tree</span><span class="o">.</span><span class="n">hasRightChild</span> <span class="p">{</span>
                <span class="nf">findTree</span><span class="p">(</span><span class="nv">tree</span><span class="p">:</span> <span class="n">tree</span><span class="o">.</span><span class="n">right</span><span class="o">!</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>测试：</li>
</ul>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">tree</span> <span class="o">=</span> <span class="kt">BinarySearchTree</span><span class="o">&lt;</span><span class="kt">Int</span><span class="o">&gt;</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="mi">7</span><span class="p">)</span>
<span class="n">tree</span><span class="o">.</span><span class="nf">insert</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="mi">20</span><span class="p">)</span>
<span class="n">tree</span><span class="o">.</span><span class="nf">insert</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="mi">9</span><span class="p">)</span>
<span class="n">tree</span><span class="o">.</span><span class="nf">insert</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="mi">10</span><span class="p">)</span>
<span class="n">tree</span><span class="o">.</span><span class="nf">insert</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="mi">25</span><span class="p">)</span>
<span class="n">tree</span><span class="o">.</span><span class="nf">insert</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="mi">16</span><span class="p">)</span>
<span class="n">tree</span><span class="o">.</span><span class="nf">insert</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">tree</span><span class="o">.</span><span class="nf">insert</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="mi">40</span><span class="p">)</span>
<span class="n">tree</span><span class="o">.</span><span class="nf">insert</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="mi">16</span><span class="p">)</span>
<span class="n">tree</span><span class="o">.</span><span class="nf">insert</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="mi">6</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
</code></pre></div></div>

<blockquote>
  <p><strong>(2 -&gt; (6)) &lt;- 7 -&gt; ((9 -&gt; (10 -&gt; (16))) &lt;- 20 -&gt; (25 -&gt; (40)))</strong></p>

  <p><strong>20 9 10 16 25</strong></p>
</blockquote>

<h3 id="输出一颗树所有的到叶子节点的路径">输出一颗树所有的到叶子节点的路径</h3>

<ul>
  <li>示例：</li>
</ul>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code>输入：int型数组[7, 20，9，10，25，16，2，40，16，6]
输出：["7-&gt;2-&gt;6", "7-&gt;20-&gt;9-&gt;10-&gt;16", "7-&gt;20-&gt;25-&gt;40"]
</code></pre></div></div>
<ul>
  <li>
    <p>思路
很简单，递归，先去实现左子树的路径，而后实现右子树的路径</p>
  </li>
  <li>
    <p>实现
  沿用上述的二叉搜索树结构（自定义的二叉树结构也测试过，此处不展示了）</p>

    <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">public</span> <span class="kd">func</span> <span class="nf">outputAllPathInBTree</span><span class="p">(</span><span class="nv">root</span><span class="p">:</span> <span class="kt">BinaryTree</span><span class="o">&lt;</span><span class="kt">Int</span><span class="o">&gt;</span><span class="p">?,</span> <span class="nv">path</span><span class="p">:</span> <span class="kt">String</span><span class="p">,</span> <span class="nv">paths</span><span class="p">:</span> <span class="k">inout</span> <span class="p">[</span><span class="kt">String</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kt">Void</span> <span class="p">{</span>
      <span class="k">if</span> <span class="n">root</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
          <span class="k">return</span>
      <span class="p">}</span>
	
      <span class="k">var</span> <span class="nv">p</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="nf">appending</span><span class="p">(</span><span class="kt">String</span><span class="p">(</span><span class="n">root</span><span class="o">!.</span><span class="n">value</span><span class="p">))</span>
	
      <span class="k">if</span> <span class="n">root</span><span class="p">?</span><span class="o">.</span><span class="n">left</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="n">root</span><span class="p">?</span><span class="o">.</span><span class="n">right</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
          <span class="n">paths</span><span class="o">.</span><span class="nf">append</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
          <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="nf">appending</span><span class="p">(</span><span class="s">"-&gt;"</span><span class="p">)</span>
          <span class="nf">outputAllPathInBTree</span><span class="p">(</span><span class="nv">root</span><span class="p">:</span> <span class="n">root</span><span class="p">?</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="nv">path</span><span class="p">:</span> <span class="n">p</span><span class="p">,</span> <span class="nv">paths</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">paths</span><span class="p">)</span>
          <span class="nf">outputAllPathInBTree</span><span class="p">(</span><span class="nv">root</span><span class="p">:</span> <span class="n">root</span><span class="p">?</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="nv">path</span><span class="p">:</span> <span class="n">p</span><span class="p">,</span> <span class="nv">paths</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">paths</span><span class="p">)</span>
      <span class="p">}</span>
  <span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>测试</p>

    <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code>      <span class="k">let</span> <span class="nv">bsTree</span> <span class="o">=</span> <span class="nf">generateBSTree</span><span class="p">()</span>
  <span class="k">let</span> <span class="nv">bTree</span> <span class="o">=</span> <span class="nf">generateBTree</span><span class="p">()</span>
  
  <span class="k">let</span> <span class="nv">bstpath</span> <span class="o">=</span> <span class="s">""</span>
  <span class="k">var</span> <span class="nv">bstpaths</span><span class="p">:</span> <span class="p">[</span><span class="kt">String</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
  
  <span class="nf">outputAllPathInBTree</span><span class="p">(</span><span class="nv">root</span><span class="p">:</span> <span class="n">bsTree</span><span class="p">,</span> <span class="nv">path</span><span class="p">:</span> <span class="n">bstpath</span><span class="p">,</span> <span class="nv">paths</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">bstpaths</span><span class="p">)</span>
  
  <span class="nf">print</span><span class="p">(</span><span class="s">"outputAllPathInBTree is: "</span><span class="p">)</span>
  <span class="nf">print</span><span class="p">(</span><span class="n">bstpaths</span><span class="p">)</span>
    
  <span class="kd">public</span> <span class="kd">func</span> <span class="nf">generateBTree</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">BinaryTree</span><span class="o">&lt;</span><span class="kt">Int</span><span class="o">&gt;</span> <span class="p">{</span>
      <span class="k">let</span> <span class="nv">bTree</span> <span class="o">=</span> <span class="kt">BinaryTree</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="mi">1</span><span class="p">)</span>
	
      <span class="n">bTree</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="kt">BinaryTree</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="mi">3</span><span class="p">)</span>
	
      <span class="k">let</span> <span class="nv">bl</span> <span class="o">=</span> <span class="kt">BinaryTree</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="mi">2</span><span class="p">)</span>
      <span class="n">bl</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="kt">BinaryTree</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="mi">5</span><span class="p">)</span>
	
      <span class="n">bTree</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">bl</span>
	
      <span class="nf">print</span><span class="p">(</span><span class="s">"binary tree is: "</span><span class="p">)</span>
      <span class="nf">print</span><span class="p">(</span><span class="n">bTree</span><span class="p">)</span>
      <span class="nf">print</span><span class="p">(</span><span class="s">"</span><span class="se">\r</span><span class="s">"</span><span class="p">)</span>
	
      <span class="k">return</span> <span class="n">bTree</span>
  <span class="p">}</span>
</code></pre></div>    </div>
  </li>
</ul>

<blockquote>
  <p>outputAllPathInBTree is: 
[“7-&gt;2-&gt;6”, “7-&gt;20-&gt;9-&gt;10-&gt;16”, “7-&gt;20-&gt;25-&gt;40”]</p>

  <p>outputAllPathInBTree is: 
[“1-&gt;2-&gt;5”, “1-&gt;3”]</p>
</blockquote>]]></content><author><name>Cambria Yang</name><email>cambriayang@qq.com</email></author><category term="Algorithm" /><category term="算法" /><summary type="html"><![CDATA[一些算法举例 树 树是最常用且非常有用的数据结构之一，通过下图可以很容易理解树的概念。 上图展示的是一个拥有5个层级数的树结构。树根root是第0层，从树最外层开始每深入一层，其层级树相应的减1。 树能帮你解决很多问题，包括： 表示对象的层级关系 使查询快速高效 能提供有序的数据链 文本的前缀匹配搜索 swift构造树 class TreeNode&lt;T&gt; { var value: T var children: [TreeNode] = [] weak var parent: TreeNode? init(value: T) { self.value = value } func add(child: TreeNode) { children.append(child) child.parent = self } } 但是这种是没办法被print打印出来的。需要： extension TreeNode: CustomStringConvertible { var description: String { var text = "\(value)" if !children.isEmpty { text += "{"+children.map{$0.description}.joined(separator: ", ")+"}" } return text } } 搜索： extension TreeNode where T: Equatable { func search(value: T) -&gt; TreeNode? { if value == self.value { return self } for child in children { if let found = child.search(value: value) { return found } } return nil } } 为数组建立二进制搜索树，并搜索范围内的节点 示例： 输入：int型数组[7, 20，9，10，25，16，2，40，16，6] 范围：[9,35] 输出：9，10，20, 25, 16 思路： 构建BST： class BinaryTree&lt;T: Comparable&gt; { public var value: T public var parent: BinaryTree? public var left: BinaryTree? public var right: BinaryTree? init(value: T) { self.value = value } var isRoot: Bool { return parent == nil } var isLeaf: Bool { return left == nil &amp;&amp; right == nil } var isLeftChild: Bool { return parent?.left === self } var isRightChild: Bool { return parent?.right === self } var hasLeftChild: Bool { return left != nil } var hasRightChild: Bool { return right != nil } var hasBothChildren: Bool { return hasLeftChild &amp;&amp; hasRightChild } var count: Int { return (left?.count ?? 0)+1+(right?.count ?? 0) } } class BinarySearchTree&lt;T: Comparable&gt; : BinaryTree&lt;T&gt; { func insert(value: T) { if value &lt; self.value { if hasLeftChild { (left as! BinarySearchTree).insert(value: value) } else { left = BinarySearchTree(value: value) left?.parent = self } } else { if hasRightChild { (right as! BinarySearchTree).insert(value: value) } else { right = BinarySearchTree(value: value) right?.parent = self } } } } 功能函数： //获取[9,35] func findTree(tree: BinarySearchTree&lt;Int&gt;) { if tree.value &lt;= 9 { //在右边找 if tree.value == 9 { print(tree.value, terminator: " ") } if tree.hasRightChild { findTree(tree: tree.right!) } } else if tree.value &gt;= 35 { //在左边找 if tree.value == 35 { print(tree.value, terminator: " ") } if tree.hasLeftChild { findTree(tree: tree.left!) } } else if tree.value &gt; 9 &amp;&amp; tree.value &lt; 35 { print(tree.value, terminator: " ") if tree.hasLeftChild { findTree(tree: tree.left!) } if tree.hasRightChild { findTree(tree: tree.right!) } } } 测试： let tree = BinarySearchTree&lt;Int&gt;(value: 7) tree.insert(value: 20) tree.insert(value: 9) tree.insert(value: 10) tree.insert(value: 25) tree.insert(value: 16) tree.insert(value: 2) tree.insert(value: 40) tree.insert(value: 16) tree.insert(value: 6) print(tree) (2 -&gt; (6)) &lt;- 7 -&gt; ((9 -&gt; (10 -&gt; (16))) &lt;- 20 -&gt; (25 -&gt; (40))) 20 9 10 16 25 输出一颗树所有的到叶子节点的路径 示例： 输入：int型数组[7, 20，9，10，25，16，2，40，16，6] 输出：["7-&gt;2-&gt;6", "7-&gt;20-&gt;9-&gt;10-&gt;16", "7-&gt;20-&gt;25-&gt;40"] 思路 很简单，递归，先去实现左子树的路径，而后实现右子树的路径 实现 沿用上述的二叉搜索树结构（自定义的二叉树结构也测试过，此处不展示了） public func outputAllPathInBTree(root: BinaryTree&lt;Int&gt;?, path: String, paths: inout [String]) -&gt; Void { if root == nil { return } var p = path.appending(String(root!.value)) if root?.left == nil &amp;&amp; root?.right == nil { paths.append(p) } else { p = p.appending("-&gt;") outputAllPathInBTree(root: root?.left, path: p, paths: &amp;paths) outputAllPathInBTree(root: root?.right, path: p, paths: &amp;paths) } } 测试 let bsTree = generateBSTree() let bTree = generateBTree() let bstpath = "" var bstpaths: [String] = [] outputAllPathInBTree(root: bsTree, path: bstpath, paths: &amp;bstpaths) print("outputAllPathInBTree is: ") print(bstpaths) public func generateBTree() -&gt; BinaryTree&lt;Int&gt; { let bTree = BinaryTree(value: 1) bTree.right = BinaryTree(value: 3) let bl = BinaryTree(value: 2) bl.right = BinaryTree(value: 5) bTree.left = bl print("binary tree is: ") print(bTree) print("\r") return bTree } outputAllPathInBTree is: [“7-&gt;2-&gt;6”, “7-&gt;20-&gt;9-&gt;10-&gt;16”, “7-&gt;20-&gt;25-&gt;40”] outputAllPathInBTree is: [“1-&gt;2-&gt;5”, “1-&gt;3”]]]></summary></entry><entry><title type="html">链表算法</title><link href="http://localhost:4000/algorithm/2022/03/08/%E9%93%BE%E8%A1%A8%E7%AE%97%E6%B3%95.html" rel="alternate" type="text/html" title="链表算法" /><published>2022-03-08T05:00:00+00:00</published><updated>2022-03-08T05:00:00+00:00</updated><id>http://localhost:4000/algorithm/2022/03/08/%E9%93%BE%E8%A1%A8%E7%AE%97%E6%B3%95</id><content type="html" xml:base="http://localhost:4000/algorithm/2022/03/08/%E9%93%BE%E8%A1%A8%E7%AE%97%E6%B3%95.html"><![CDATA[<p>一些算法举例</p>

<h2 id="链表">链表</h2>
<h3 id="合并两个排过序的链表并将其作为新链表">合并两个排过序的链表，并将其作为新链表</h3>

<p>示例：</p>
<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code>输入：1-＞2-＞4,1-＞3-＞4
输出：1-＞1-＞2-＞3-＞4-＞4
</code></pre></div></div>

<p>思路：
很简单，就是链表遍历，然后变换next就可以了</p>

<p>代码实现：</p>

<p>链表构造</p>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">Node</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">T</span>
    <span class="k">var</span> <span class="nv">next</span><span class="p">:</span> <span class="kt">Node</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span><span class="p">?</span>
    <span class="nf">init</span><span class="p">(</span><span class="n">_</span> <span class="nv">val</span><span class="p">:</span> <span class="kt">T</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">val</span>
        <span class="k">self</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="kc">nil</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="kt">IntLinkList</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">head</span><span class="p">:</span> <span class="kt">Node</span><span class="o">&lt;</span><span class="kt">Int</span><span class="o">&gt;</span><span class="p">?</span>
    <span class="k">var</span> <span class="nv">tail</span><span class="p">:</span> <span class="kt">Node</span><span class="o">&lt;</span><span class="kt">Int</span><span class="o">&gt;</span><span class="p">?</span>
    
    <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">tail</span> <span class="o">=</span> <span class="kc">nil</span>
        <span class="n">head</span> <span class="o">=</span> <span class="n">tail</span>
    <span class="p">}</span>
    
    <span class="k">var</span> <span class="nv">isEmpty</span><span class="p">:</span> <span class="kt">Bool</span> <span class="p">{</span>
        <span class="k">get</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">head</span> <span class="o">==</span> <span class="kc">nil</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="kd">func</span> <span class="nf">append</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">node</span> <span class="o">=</span> <span class="kt">Node</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">tail</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="n">tail</span> <span class="o">=</span> <span class="n">node</span>
            <span class="n">head</span> <span class="o">=</span> <span class="n">tail</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">tail</span><span class="o">!.</span><span class="n">next</span> <span class="o">=</span> <span class="n">node</span>
            <span class="n">tail</span> <span class="o">=</span> <span class="n">tail</span><span class="o">!.</span><span class="n">next</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="kd">func</span> <span class="nf">appendToHead</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">node</span> <span class="o">=</span> <span class="kt">Node</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">head</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="n">head</span> <span class="o">=</span> <span class="n">node</span>
            <span class="n">tail</span> <span class="o">=</span> <span class="n">head</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">node</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">head</span><span class="p">?</span><span class="o">.</span><span class="n">next</span>
            <span class="n">head</span> <span class="o">=</span> <span class="n">node</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="kd">func</span> <span class="nf">insertAt</span><span class="p">(</span><span class="nv">index</span><span class="p">:</span> <span class="kt">Int</span><span class="p">,</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="k">self</span><span class="o">.</span><span class="nf">appendToHead</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="n">value</span><span class="p">)</span>
        <span class="p">}</span>
        
        <span class="k">var</span> <span class="nv">tmp</span> <span class="o">=</span> <span class="n">head</span>
        
        <span class="k">var</span> <span class="nv">i</span><span class="p">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">0</span>
        
        <span class="k">while</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">index</span> <span class="o">&amp;&amp;</span> <span class="n">tmp</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">?</span><span class="o">.</span><span class="n">next</span>
            <span class="n">i</span><span class="o">+=</span><span class="mi">1</span>
        <span class="p">}</span>
        
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">index</span> <span class="p">{</span>
            <span class="k">let</span> <span class="nv">node</span> <span class="o">=</span> <span class="kt">Node</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="n">node</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">?</span><span class="o">.</span><span class="n">next</span>
            <span class="n">tmp</span><span class="p">?</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">node</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="c1">//说明index太大，还没到，链表就走完了</span>
            <span class="k">self</span><span class="o">.</span><span class="nf">append</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="n">value</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>功能</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//left和right是已经排好序的链表</span>
    <span class="kd">func</span> <span class="nf">bindTwoLink</span><span class="p">(</span><span class="n">firstList</span> <span class="nv">left</span><span class="p">:</span> <span class="kt">IntLinkList</span><span class="p">,</span> <span class="n">second</span> <span class="nv">right</span><span class="p">:</span> <span class="kt">IntLinkList</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">IntLinkList</span> <span class="p">{</span>
        <span class="k">guard</span> <span class="o">!</span><span class="n">left</span><span class="o">.</span><span class="n">isEmpty</span> <span class="k">else</span> <span class="p">{</span><span class="k">return</span> <span class="n">right</span><span class="p">}</span>
        
        <span class="k">guard</span> <span class="o">!</span><span class="n">left</span><span class="o">.</span><span class="n">isEmpty</span> <span class="k">else</span> <span class="p">{</span><span class="k">return</span> <span class="n">right</span><span class="p">}</span>
        
        <span class="k">let</span> <span class="nv">list</span> <span class="o">=</span> <span class="kt">IntLinkList</span><span class="p">()</span>
        
        <span class="k">var</span> <span class="nv">currentLeft</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="n">head</span>
        <span class="k">var</span> <span class="nv">currentRight</span> <span class="o">=</span> <span class="n">right</span><span class="o">.</span><span class="n">head</span>
        
        <span class="k">if</span> <span class="k">let</span> <span class="nv">leftNode</span> <span class="o">=</span> <span class="n">currentLeft</span> <span class="p">,</span> <span class="k">let</span> <span class="nv">rightNode</span> <span class="o">=</span> <span class="n">currentRight</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">leftNode</span><span class="o">.</span><span class="n">value</span> <span class="o">&lt;</span> <span class="n">rightNode</span><span class="o">.</span><span class="n">value</span> <span class="p">{</span>
                <span class="n">list</span><span class="o">.</span><span class="n">head</span> <span class="o">=</span> <span class="n">leftNode</span>
                <span class="n">currentLeft</span> <span class="o">=</span> <span class="n">leftNode</span><span class="o">.</span><span class="n">next</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">list</span><span class="o">.</span><span class="n">head</span> <span class="o">=</span> <span class="n">rightNode</span>
                <span class="n">currentRight</span> <span class="o">=</span> <span class="n">rightNode</span><span class="o">.</span><span class="n">next</span>
            <span class="p">}</span>
            <span class="n">list</span><span class="o">.</span><span class="n">tail</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="n">head</span>
        <span class="p">}</span>
        
        <span class="k">while</span> <span class="k">let</span> <span class="nv">leftNode</span> <span class="o">=</span> <span class="n">currentLeft</span><span class="p">,</span> <span class="k">let</span> <span class="nv">rightNode</span> <span class="o">=</span> <span class="n">currentRight</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">leftNode</span><span class="o">.</span><span class="n">value</span> <span class="o">&lt;</span> <span class="n">rightNode</span><span class="o">.</span><span class="n">value</span> <span class="p">{</span>
                <span class="n">list</span><span class="o">.</span><span class="n">tail</span><span class="p">?</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">leftNode</span>
                <span class="n">currentLeft</span> <span class="o">=</span> <span class="n">leftNode</span><span class="o">.</span><span class="n">next</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">list</span><span class="o">.</span><span class="n">tail</span><span class="p">?</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">rightNode</span>
                <span class="n">currentRight</span> <span class="o">=</span> <span class="n">rightNode</span><span class="o">.</span><span class="n">next</span>
            <span class="p">}</span>
            <span class="n">list</span><span class="o">.</span><span class="n">tail</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="n">tail</span><span class="p">?</span><span class="o">.</span><span class="n">next</span>
        <span class="p">}</span>
        
        <span class="c1">//此处还有最后两个尾端没有遍历到</span>
        <span class="k">if</span> <span class="k">let</span> <span class="nv">leftNode</span> <span class="o">=</span> <span class="n">currentLeft</span> <span class="p">{</span><span class="n">list</span><span class="o">.</span><span class="n">tail</span><span class="p">?</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">leftNode</span><span class="p">}</span>
        <span class="k">if</span> <span class="k">let</span> <span class="nv">rightNode</span> <span class="o">=</span> <span class="n">currentRight</span> <span class="p">{</span><span class="n">list</span><span class="o">.</span><span class="n">tail</span><span class="p">?</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">rightNode</span><span class="p">}</span>
        
        <span class="k">return</span> <span class="n">list</span>
    <span class="p">}</span>
</code></pre></div></div>

<p>测试：</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">list1</span> <span class="o">=</span> <span class="kt">IntLinkList</span><span class="p">()</span>
<span class="n">list1</span><span class="o">.</span><span class="nf">append</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">list1</span><span class="o">.</span><span class="nf">append</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">list1</span><span class="o">.</span><span class="nf">append</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="mi">4</span><span class="p">)</span>
<span class="n">list1</span><span class="o">.</span><span class="nf">append</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="mi">5</span><span class="p">)</span>
<span class="n">list1</span><span class="o">.</span><span class="nf">append</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="mi">22</span><span class="p">)</span>

<span class="k">let</span> <span class="nv">list2</span> <span class="o">=</span> <span class="kt">IntLinkList</span><span class="p">()</span>
<span class="n">list2</span><span class="o">.</span><span class="nf">append</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">list2</span><span class="o">.</span><span class="nf">append</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">list2</span><span class="o">.</span><span class="nf">append</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="mi">4</span><span class="p">)</span>
<span class="n">list2</span><span class="o">.</span><span class="nf">append</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="mi">5</span><span class="p">)</span>
<span class="n">list2</span><span class="o">.</span><span class="nf">append</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="mi">6</span><span class="p">)</span>
<span class="n">list2</span><span class="o">.</span><span class="nf">append</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="mi">7</span><span class="p">)</span>
<span class="n">list2</span><span class="o">.</span><span class="nf">append</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="mi">8</span><span class="p">)</span>

<span class="k">let</span> <span class="nv">list</span> <span class="o">=</span> <span class="n">solution</span><span class="o">.</span><span class="nf">bindTwoLink</span><span class="p">(</span><span class="nv">firstList</span><span class="p">:</span> <span class="n">list1</span><span class="p">,</span> <span class="nv">second</span><span class="p">:</span> <span class="n">list2</span><span class="p">)</span>

<span class="k">var</span> <span class="nv">head</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="n">head</span>

<span class="k">while</span> <span class="n">head</span><span class="p">?</span><span class="o">.</span><span class="n">next</span> <span class="o">!=</span> <span class="kc">nil</span>  <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="n">head</span><span class="o">!.</span><span class="n">value</span> <span class="k">as</span> <span class="kt">Any</span><span class="p">,</span> <span class="nv">terminator</span><span class="p">:</span> <span class="s">" "</span><span class="p">)</span>
    <span class="n">head</span> <span class="o">=</span> <span class="n">head</span><span class="o">!.</span><span class="n">next</span>
<span class="p">}</span>

<span class="nf">print</span><span class="p">(</span><span class="n">head</span><span class="o">!.</span><span class="n">value</span><span class="p">)</span>
</code></pre></div></div>

<p>结果：</p>
<blockquote>
  <p>1 1 2 3 4 4 5 5 6 7 8 22</p>
</blockquote>

<h3 id="反转链表">反转链表</h3>

<ul>
  <li>示例</li>
</ul>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL
输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL
</code></pre></div></div>

<ul>
  <li>思路</li>
</ul>

<p>将节点的next指向pre即可</p>

<ul>
  <li>解法</li>
</ul>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">reverseList</span><span class="p">(</span><span class="n">_</span> <span class="nv">head</span><span class="p">:</span> <span class="kt">Node</span><span class="o">&lt;</span><span class="kt">Int</span><span class="o">&gt;</span><span class="p">?)</span> <span class="o">-&gt;</span> <span class="kt">Node</span><span class="o">&lt;</span><span class="kt">Int</span><span class="o">&gt;</span><span class="p">?</span> <span class="p">{</span>
  <span class="k">var</span> <span class="nv">cur</span> <span class="o">=</span> <span class="n">head</span>
  <span class="k">var</span> <span class="nv">last</span><span class="p">:</span> <span class="kt">Node</span><span class="o">&lt;</span><span class="kt">Int</span><span class="o">&gt;</span><span class="p">?</span>
  <span class="k">var</span> <span class="nv">next</span><span class="p">:</span> <span class="kt">Node</span><span class="o">&lt;</span><span class="kt">Int</span><span class="o">&gt;</span><span class="p">?</span>

  <span class="k">while</span> <span class="p">(</span><span class="n">cur</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">next</span> <span class="o">=</span> <span class="n">cur</span><span class="p">?</span><span class="o">.</span><span class="n">next</span>
    <span class="n">cur</span><span class="p">?</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">last</span>
    <span class="n">last</span> <span class="o">=</span> <span class="n">cur</span>
    <span class="n">cur</span> <span class="o">=</span> <span class="n">next</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">last</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>结果</li>
</ul>

<blockquote>
  <p><strong>let</strong> <strong>list3</strong> <strong>=</strong> <strong>IntLinkList</strong><strong>()</strong></p>

  <p><strong>list3</strong><strong>.</strong><strong>append</strong><strong>(value:</strong> <strong>10</strong><strong>)</strong></p>

  <p><strong>list3</strong><strong>.</strong><strong>append</strong><strong>(value:</strong> <strong>12</strong><strong>)</strong></p>

  <p><strong>list3</strong><strong>.</strong><strong>append</strong><strong>(value:</strong> <strong>4</strong><strong>)</strong></p>

  <p><strong>list3</strong><strong>.</strong><strong>append</strong><strong>(value:</strong> <strong>5</strong><strong>)</strong></p>

  <p><strong>list3</strong><strong>.</strong><strong>append</strong><strong>(value:</strong> <strong>2</strong><strong>)</strong></p>

  <p><strong>var</strong> <strong>prev</strong> <strong>=</strong> <strong>solution</strong><strong>.</strong><strong>reverseList</strong><strong>(</strong><strong>list3</strong><strong>.</strong><strong>head</strong><strong>)</strong></p>

  <p><strong>while</strong> <strong>prev</strong><strong>?.</strong><strong>next</strong> <strong>!=</strong> <strong>nil</strong> <strong>{</strong></p>

  <p><strong>print</strong><strong>(</strong><strong>prev</strong><strong>!.</strong><strong>value</strong> <strong>as</strong> <strong>Any</strong><strong>, terminator:</strong> <strong>” “</strong><strong>)</strong></p>

  <p><strong>prev</strong> <strong>=</strong> <strong>prev</strong><strong>!.</strong><strong>next</strong></p>

  <p><strong>}</strong></p>

  <p><strong>print</strong><strong>(</strong><strong>prev</strong><strong>!.</strong><strong>value</strong><strong>)</strong></p>
</blockquote>

<blockquote>
  <p><strong>2 5 4 12 10</strong></p>
</blockquote>]]></content><author><name>Cambria Yang</name><email>cambriayang@qq.com</email></author><category term="Algorithm" /><category term="算法" /><summary type="html"><![CDATA[一些算法举例 链表 合并两个排过序的链表，并将其作为新链表 示例： 输入：1-＞2-＞4,1-＞3-＞4 输出：1-＞1-＞2-＞3-＞4-＞4 思路： 很简单，就是链表遍历，然后变换next就可以了 代码实现： 链表构造 class Node&lt;T&gt; { var value: T var next: Node&lt;T&gt;? init(_ val: T) { self.value = val self.next = nil } } class IntLinkList { var head: Node&lt;Int&gt;? var tail: Node&lt;Int&gt;? init() { tail = nil head = tail } var isEmpty: Bool { get { return head == nil } } func append(value: Int) { let node = Node(value) if tail == nil { tail = node head = tail } else { tail!.next = node tail = tail!.next } } func appendToHead(value: Int) { let node = Node(value) if head == nil { head = node tail = head } else { node.next = head?.next head = node } } func insertAt(index: Int, value: Int) { if index == 0 { self.appendToHead(value: value) } var tmp = head var i: Int = 0 while i != index &amp;&amp; tmp == nil { tmp = tmp?.next i+=1 } if i == index { let node = Node(value) node.next = tmp?.next tmp?.next = node } else { //说明index太大，还没到，链表就走完了 self.append(value: value) } } } 功能 //left和right是已经排好序的链表 func bindTwoLink(firstList left: IntLinkList, second right: IntLinkList) -&gt; IntLinkList { guard !left.isEmpty else {return right} guard !left.isEmpty else {return right} let list = IntLinkList() var currentLeft = left.head var currentRight = right.head if let leftNode = currentLeft , let rightNode = currentRight { if leftNode.value &lt; rightNode.value { list.head = leftNode currentLeft = leftNode.next } else { list.head = rightNode currentRight = rightNode.next } list.tail = list.head } while let leftNode = currentLeft, let rightNode = currentRight { if leftNode.value &lt; rightNode.value { list.tail?.next = leftNode currentLeft = leftNode.next } else { list.tail?.next = rightNode currentRight = rightNode.next } list.tail = list.tail?.next } //此处还有最后两个尾端没有遍历到 if let leftNode = currentLeft {list.tail?.next = leftNode} if let rightNode = currentRight {list.tail?.next = rightNode} return list } 测试： let list1 = IntLinkList() list1.append(value: 1) list1.append(value: 2) list1.append(value: 4) list1.append(value: 5) list1.append(value: 22) let list2 = IntLinkList() list2.append(value: 1) list2.append(value: 3) list2.append(value: 4) list2.append(value: 5) list2.append(value: 6) list2.append(value: 7) list2.append(value: 8) let list = solution.bindTwoLink(firstList: list1, second: list2) var head = list.head while head?.next != nil { print(head!.value as Any, terminator: " ") head = head!.next } print(head!.value) 结果： 1 1 2 3 4 4 5 5 6 7 8 22 反转链表 示例 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL 输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL 思路 将节点的next指向pre即可 解法 func reverseList(_ head: Node&lt;Int&gt;?) -&gt; Node&lt;Int&gt;? { var cur = head var last: Node&lt;Int&gt;? var next: Node&lt;Int&gt;? while (cur != nil) { next = cur?.next cur?.next = last last = cur cur = next } return last } 结果 let list3 = IntLinkList() list3.append(value: 10) list3.append(value: 12) list3.append(value: 4) list3.append(value: 5) list3.append(value: 2) var prev = solution.reverseList(list3.head) while prev?.next != nil { print(prev!.value as Any, terminator: ” “) prev = prev!.next } print(prev!.value) 2 5 4 12 10]]></summary></entry><entry><title type="html">数组算法</title><link href="http://localhost:4000/algorithm/2022/03/08/%E6%95%B0%E7%BB%84%E7%AE%97%E6%B3%95.html" rel="alternate" type="text/html" title="数组算法" /><published>2022-03-08T04:00:00+00:00</published><updated>2022-03-08T04:00:00+00:00</updated><id>http://localhost:4000/algorithm/2022/03/08/%E6%95%B0%E7%BB%84%E7%AE%97%E6%B3%95</id><content type="html" xml:base="http://localhost:4000/algorithm/2022/03/08/%E6%95%B0%E7%BB%84%E7%AE%97%E6%B3%95.html"><![CDATA[<p>一些算法举例</p>

<h2 id="数组">数组</h2>

<h3 id="寻找中间数">寻找中间数</h3>

<p>给出一个无序数组，求出一个数，使得其左边的数都小于它，右边的数都大于等于它。要求时间复杂度为n</p>

<ul>
  <li>示例</li>
</ul>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code>输入：[4,3,2,7,9,10,11,10]
输出：7,9
</code></pre></div></div>

<ul>
  <li>思路</li>
</ul>

<p>两次遍历，第一次遍历，记录下每个位置和它之后的那个元素的最小值（当然这个最小值会一直更新，所以这一次遍历完，就是整个数组的最小值），需要一个n的数组，存放的是这个位置和它后面一个位置的较小值，当然如果已经遇到了，最小值，因为会和最小值进行判断，所以后续这个新的数组里存放的都是这个最小值了。</p>

<p>第二次遍历是正常的从左向右遍历，寻找左边大且比右边小的数，也会记住一个最大值。</p>

<ul>
  <li>解法</li>
</ul>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">findTheMidNumber</span><span class="p">(</span><span class="n">_</span> <span class="nv">data</span><span class="p">:</span> <span class="p">[</span><span class="kt">Int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span> <span class="p">{</span>
  <span class="k">var</span> <span class="nv">res</span> <span class="o">=</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]()</span>

  <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span><span class="k">return</span> <span class="n">res</span><span class="p">}</span>
  <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">count</span> <span class="o">&lt;=</span> <span class="mi">2</span> <span class="p">{</span><span class="k">return</span> <span class="n">res</span><span class="p">}</span>

  <span class="k">var</span> <span class="nv">rightMin</span> <span class="o">=</span> <span class="p">[</span><span class="kt">Int</span><span class="p">](</span><span class="nv">repeating</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="nv">count</span><span class="p">:</span> <span class="n">data</span><span class="o">.</span><span class="n">count</span><span class="p">)</span>
  <span class="k">var</span> <span class="nv">r_min</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">data</span><span class="o">.</span><span class="n">count</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

  <span class="c1">//从右往左，寻找每个位置及其之后的最小数</span>
  <span class="k">for</span> <span class="n">i</span> <span class="nf">in</span> <span class="p">(</span><span class="mi">0</span><span class="o">..&lt;</span><span class="n">data</span><span class="o">.</span><span class="n">count</span><span class="p">)</span><span class="o">.</span><span class="nf">reversed</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">r_min</span> <span class="p">{</span>
      <span class="n">r_min</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="p">}</span>
    <span class="n">rightMin</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">r_min</span>
  <span class="p">}</span>

  <span class="c1">//从左往右，寻找左边大且比右边小的数</span>
  <span class="k">var</span> <span class="nv">l_max</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
  <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..&lt;</span><span class="n">data</span><span class="o">.</span><span class="n">count</span><span class="o">-</span><span class="mi">1</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">l_max</span> <span class="p">{</span>
      <span class="n">l_max</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
      <span class="k">if</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">rightMin</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="p">{</span>
        <span class="n">res</span><span class="o">.</span><span class="nf">append</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="nf">print</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">res</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>测试</li>
</ul>

<blockquote>
  <p>_ = findTheMidNumber([4,3,2,7,9,10,11,10])</p>

  <p><strong>[7, 9]</strong></p>
</blockquote>

<h3 id="三数之和">三数之和</h3>

<p>一个包含n个整数的数组nums，判断nums中是否存在三个元素a，b，c，使得a+b+c=0？请找出所有满足条件且不重复的三元组</p>

<p><em>注意</em>：不可以包含重复的三元组</p>

<ul>
  <li>示例</li>
</ul>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code>输入：nums=[-1,0,1,2,-1,-4]
输出：[[-1,0,1], [-1,-1,2]]
</code></pre></div></div>

<ul>
  <li>思路</li>
</ul>

<p>除非三个数全是0，否则肯定会有正数和负数，所以假定选择一个数，然后再去找另外两个数，这样只要找到两个数且和为第一个选择的数的相反数。</p>

<ol>
  <li>从小到大排序</li>
  <li>循环</li>
  <li>如果最小的数大于0，直接结束（因为必须要有负数）</li>
</ol>

<p><img src="http://localhost:4000/assets/images/posts/leetcode_three_sums.jpg" alt="sort_algorithm" /></p>

<p>相当于两数之和问题：a+b=target，因为是排好序的，选定了i，那么j+k需要是i的相反数，如果j+k&lt;target，则j++,否则k–，j和k是右边数组的首末两端</p>

<ul>
  <li>解法</li>
</ul>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">threeSum</span><span class="p">(</span><span class="n">_</span> <span class="nv">nums</span><span class="p">:</span> <span class="p">[</span><span class="kt">Int</span><span class="p">])</span><span class="o">-&gt;</span><span class="p">[[</span><span class="kt">Int</span><span class="p">]]?</span> <span class="p">{</span>
  <span class="k">var</span> <span class="nv">tempNums</span> <span class="o">=</span> <span class="n">nums</span>

  <span class="k">if</span> <span class="n">nums</span><span class="o">.</span><span class="n">count</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="p">{</span><span class="k">return</span> <span class="kc">nil</span><span class="p">}</span>
  <span class="c1">//排序</span>
  <span class="nf">insertSort</span><span class="p">(</span><span class="nv">arr</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">tempNums</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">tempNums</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">{</span><span class="k">return</span> <span class="kc">nil</span><span class="p">}</span>

  <span class="k">var</span> <span class="nv">res</span> <span class="o">=</span> <span class="p">[[</span><span class="kt">Int</span><span class="p">]]()</span>

  <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..&lt;</span><span class="n">tempNums</span><span class="o">.</span><span class="n">count</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">target</span> <span class="o">=</span> <span class="o">-</span><span class="n">tempNums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

    <span class="k">var</span> <span class="nv">j</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span>
    <span class="k">var</span> <span class="nv">k</span> <span class="o">=</span> <span class="n">tempNums</span><span class="o">.</span><span class="n">count</span><span class="o">-</span><span class="mi">1</span>

    <span class="k">while</span> <span class="n">k</span><span class="o">-</span><span class="n">j</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
      <span class="k">let</span> <span class="nv">numj</span> <span class="o">=</span> <span class="n">tempNums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
      <span class="k">let</span> <span class="nv">numk</span> <span class="o">=</span> <span class="n">tempNums</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>

      <span class="k">if</span> <span class="n">numj</span><span class="o">+</span><span class="n">numk</span> <span class="o">&lt;</span> <span class="n">target</span> <span class="p">{</span>
        <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
      <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">numj</span><span class="o">+</span><span class="n">numk</span> <span class="o">&gt;</span> <span class="n">target</span> <span class="p">{</span>
        <span class="n">k</span> <span class="o">-=</span> <span class="mi">1</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c1">//找到，返回i，j，k</span>
        <span class="n">res</span><span class="o">.</span><span class="nf">append</span><span class="p">([</span><span class="n">tempNums</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">numj</span><span class="p">,</span><span class="n">numk</span><span class="p">])</span>
        <span class="k">break</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">res</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>测试</li>
</ul>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">res</span> <span class="o">=</span> <span class="n">solution</span><span class="o">.</span><span class="nf">threeSum</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">4</span><span class="p">])</span>
</code></pre></div></div>

<ul>
  <li>结果</li>
</ul>

<blockquote>
  <p>[[-1, -1, 2], [-1, 0, 1]]</p>
</blockquote>

<h3 id="岛屿最大面积">岛屿最大面积</h3>

<p>给定一个包含了一些 <code class="language-plaintext highlighter-rouge">0</code> 和 <code class="language-plaintext highlighter-rouge">1</code> 的非空二维数组 <code class="language-plaintext highlighter-rouge">grid</code> 。</p>

<p>一个 <strong>岛屿</strong> 是由一些相邻的 <code class="language-plaintext highlighter-rouge">1</code> (代表土地) 构成的组合，这里的「相邻」要求两个 <code class="language-plaintext highlighter-rouge">1</code> 必须在水平或者竖直方向上相邻。你可以假设 <code class="language-plaintext highlighter-rouge">grid</code> 的四个边缘都被 <code class="language-plaintext highlighter-rouge">0</code>（代表水）包围着。</p>

<p>找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为 <code class="language-plaintext highlighter-rouge">0</code> 。)</p>

<ul>
  <li>示例</li>
</ul>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[[0,0,1,0,0,0,0,1,0,0,0,0,0],
 [0,0,0,0,0,0,0,1,1,1,0,0,0],
 [0,1,1,0,1,0,0,0,0,0,0,0,0],
 [0,1,0,0,1,1,0,0,1,0,1,0,0],
 [0,1,0,0,1,1,0,0,1,1,1,0,0],
 [0,0,0,0,0,0,0,0,0,0,1,0,0],
 [0,0,0,0,0,0,0,1,1,1,0,0,0],
 [0,0,0,0,0,0,0,1,1,0,0,0,0]]
</code></pre></div></div>

<p>对于上面这个给定矩阵应返回 <code class="language-plaintext highlighter-rouge">6</code>。注意答案不应该是 <code class="language-plaintext highlighter-rouge">11</code> ，因为岛屿只能包含水平或垂直的四个方向的 <code class="language-plaintext highlighter-rouge">1</code> 。</p>

<p><strong>注意:</strong> 给定的矩阵<code class="language-plaintext highlighter-rouge">grid</code> 的长度和宽度都不超过 50。</p>

<ul>
  <li>解法</li>
</ul>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">_</span> <span class="nv">i</span><span class="p">:</span> <span class="kt">Int</span><span class="p">,</span><span class="n">_</span> <span class="nv">j</span><span class="p">:</span> <span class="kt">Int</span><span class="p">,</span><span class="n">_</span> <span class="nv">m</span><span class="p">:</span> <span class="kt">Int</span><span class="p">,</span><span class="n">_</span> <span class="nv">n</span><span class="p">:</span><span class="kt">Int</span><span class="p">,</span><span class="n">_</span> <span class="nv">grid</span><span class="p">:</span> <span class="k">inout</span> <span class="p">[[</span><span class="kt">Int</span><span class="p">]],</span><span class="n">_</span> <span class="nv">tempArea</span><span class="p">:</span> <span class="k">inout</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="p">{</span>
  <span class="k">if</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">0</span> <span class="o">||</span> <span class="n">i</span><span class="o">&gt;=</span><span class="n">m</span> <span class="o">||</span> <span class="n">j</span><span class="o">&lt;</span><span class="mi">0</span> <span class="o">||</span> <span class="n">j</span><span class="o">&gt;=</span><span class="n">n</span> <span class="o">||</span> <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">tempArea</span>
  <span class="p">}</span>
  <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="n">tempArea</span> <span class="o">+=</span> <span class="mi">1</span>
  <span class="n">tempArea</span> <span class="o">=</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">grid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tempArea</span><span class="p">)</span>
  <span class="n">tempArea</span> <span class="o">=</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">grid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tempArea</span><span class="p">)</span>
  <span class="n">tempArea</span> <span class="o">=</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">grid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tempArea</span><span class="p">)</span>
  <span class="n">tempArea</span> <span class="o">=</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">grid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tempArea</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">tempArea</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">maxAreaOfIsland</span><span class="p">(</span><span class="n">_</span> <span class="nv">grid</span><span class="p">:</span> <span class="p">[[</span><span class="kt">Int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="p">{</span>
  <span class="k">var</span> <span class="nv">tempGrid</span> <span class="o">=</span> <span class="n">grid</span>
  <span class="k">var</span> <span class="nv">area</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="k">let</span> <span class="nv">m</span> <span class="o">=</span> <span class="n">tempGrid</span><span class="o">.</span><span class="n">count</span>
  <span class="k">var</span> <span class="nv">n</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="k">var</span> <span class="nv">islandMax</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..&lt;</span><span class="n">m</span> <span class="p">{</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">tempGrid</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">count</span>
    <span class="k">for</span> <span class="n">j</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..&lt;</span><span class="n">n</span> <span class="p">{</span>
      <span class="n">area</span> <span class="o">=</span> <span class="mi">0</span>
      <span class="n">area</span> <span class="o">=</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tempGrid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">area</span><span class="p">)</span>
      <span class="n">islandMax</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span><span class="n">islandMax</span><span class="p">,</span> <span class="n">area</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">islandMax</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="最长递增子序列非连续">最长递增子序列（非连续）</h3>

<p>给定一个未经排序的整数数组，找到最长递增子序列</p>

<ul>
  <li>示例</li>
</ul>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code>输入：10，9，2，5，3，7，101，18，20
输出：2，3，7，18，20
</code></pre></div></div>

<ul>
  <li>思路</li>
</ul>

<p>一个巧妙的方法，一般来说第一遍for i-&gt;n-1(n),第二遍for j-&gt;i-1(n).这里可以加速的是第二个循环，因为第一个循环肯定是不能加速的，所以只能加速第二个循环。</p>

<p>可以维护一个数组LIS（最后的结果数组），一开始数组是空的，当第一个数10进来，毫无疑问，它就是最长递增子序列，9进来的时候，如果它比10大则直接append，否则用二分查找法去找到数组中比它大的最小的数，<strong>替换掉</strong>，</p>

<p>因为我们相当于要不断让更小的数进来，所以很好理解。这个复杂度是logn的，所以整体是nlogn的时间复杂度。</p>

<ul>
  <li>实现</li>
</ul>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
</code></pre></div></div>

<h3 id="最长连续递增序列">最长连续递增序列</h3>

<p>给定一个未经排序的整数数组，找到最长且连续的递增序列，并返回该序列的长度。</p>

<ul>
  <li>示例</li>
</ul>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code>输入：[1,3,5,4,7]
输出：3
解释：最长递增序列是[1,3,5], 长度为3

输入：[2,2,2,2]
输出：1
解释：最长连续递增序列是[2], 长度为1
</code></pre></div></div>

<p><strong>注</strong>：数组长度不超过10000</p>

<ul>
  <li>思路
    <ul>
      <li>count 为当前元素峰值，ans为最大峰值</li>
      <li>初始化 count=1</li>
      <li>从0位置开始遍历，遍历是根据前后元素状态判断是否递增，递增则count++，递减count=1</li>
      <li>如果count&gt;ans，则更新ans</li>
      <li>直到循环结束</li>
    </ul>
  </li>
  <li>解法</li>
</ul>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">findLengthOfLCIS</span><span class="p">(</span><span class="n">_</span> <span class="nv">nums</span><span class="p">:</span> <span class="p">[</span><span class="kt">Int</span><span class="p">])</span><span class="o">-&gt;</span><span class="kt">Int</span> <span class="p">{</span>
  <span class="k">if</span> <span class="n">nums</span><span class="o">.</span><span class="n">count</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="p">{</span><span class="k">return</span> <span class="n">nums</span><span class="o">.</span><span class="n">count</span><span class="p">}</span>
  <span class="k">var</span> <span class="nv">ans</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="k">var</span> <span class="nv">count</span> <span class="o">=</span> <span class="mi">1</span>

  <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..&lt;</span><span class="n">nums</span><span class="o">.</span><span class="n">count</span><span class="o">-</span><span class="mi">1</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">{</span>
      <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="n">count</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="p">}</span>

    <span class="n">ans</span> <span class="o">=</span> <span class="n">count</span><span class="o">&gt;</span><span class="n">ans</span> <span class="p">?</span> <span class="nv">count</span> <span class="p">:</span> <span class="n">ans</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">ans</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>结果</li>
</ul>

<blockquote>
  <p>print(solution.findLengthOfLCIS([1,3,5,4,7]))</p>

  <p>3</p>
</blockquote>

<h3 id="数组中的第k大的元素">数组中的第K大的元素</h3>

<p>在未排序的数组中找到第k大的元素。</p>

<ul>
  <li>示例</li>
</ul>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code>输入： [3,2,1,5,6,4], k=2
输出：5

输入： [3,2,3,1,2,4,5,5,6], k=4
输出：4
</code></pre></div></div>

<p>假设k总是有效的，且1&lt;=k&lt;=数组长度</p>

<ul>
  <li>思路</li>
</ul>

<p>改进快速排序算法，求得第k大的元素，不需要将快速排序完全进行完，只需要进行一遍的递归，如果q刚好是第k大，则打完收工。</p>

<ul>
  <li>解法</li>
</ul>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//寻找pivot的函数</span>
<span class="kd">func</span> <span class="nf">partition</span><span class="p">(</span><span class="nv">arr</span><span class="p">:</span> <span class="k">inout</span> <span class="p">[</span><span class="kt">Int</span><span class="p">],</span> <span class="nv">left</span><span class="p">:</span> <span class="kt">Int</span><span class="p">,</span> <span class="nv">right</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="p">{</span>
  <span class="k">let</span> <span class="nv">pivot</span> <span class="o">=</span> <span class="n">left</span>
  <span class="k">var</span> <span class="nv">index</span> <span class="o">=</span> <span class="n">pivot</span><span class="o">+</span><span class="mi">1</span>
  <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="n">index</span><span class="o">...</span><span class="n">right</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">pivot</span><span class="p">]</span> <span class="p">{</span>
      <span class="n">arr</span><span class="o">.</span><span class="nf">swapAt</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
      <span class="n">index</span><span class="o">+=</span><span class="mi">1</span>
      <span class="c1">//i和index都更新，以pivot为分隔，两边都冒泡，后面再将假设的pivot替换为真正的pivot，然后继续递归</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="c1">//此处相当于pivot需要更新</span>
  <span class="n">arr</span><span class="o">.</span><span class="nf">swapAt</span><span class="p">(</span><span class="n">pivot</span><span class="p">,</span> <span class="n">index</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">index</span><span class="o">-</span><span class="mi">1</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">findKthLargest</span><span class="p">(</span><span class="n">_</span> <span class="nv">nums</span><span class="p">:</span> <span class="k">inout</span> <span class="p">[</span><span class="kt">Int</span><span class="p">],</span> <span class="n">_</span> <span class="nv">k</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nf">quickSelect</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nums</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">nums</span><span class="o">.</span><span class="n">count</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">nums</span><span class="o">.</span><span class="n">count</span><span class="o">-</span><span class="n">k</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">quickSelect</span><span class="p">(</span><span class="n">_</span> <span class="nv">a</span><span class="p">:</span> <span class="k">inout</span> <span class="p">[</span><span class="kt">Int</span><span class="p">],</span> <span class="n">_</span> <span class="nv">l</span><span class="p">:</span> <span class="kt">Int</span><span class="p">,</span> <span class="n">_</span> <span class="nv">r</span><span class="p">:</span> <span class="kt">Int</span><span class="p">,</span> <span class="n">_</span> <span class="nv">index</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="p">{</span>
  <span class="k">let</span> <span class="nv">q</span> <span class="o">=</span> <span class="nf">partition</span><span class="p">(</span><span class="nv">arr</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="nv">left</span><span class="p">:</span> <span class="n">l</span><span class="p">,</span> <span class="nv">right</span><span class="p">:</span> <span class="n">r</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">q</span> <span class="o">==</span> <span class="n">index</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">a</span><span class="p">[</span><span class="n">q</span><span class="p">]</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">q</span><span class="o">&lt;</span><span class="n">index</span> <span class="p">?</span> <span class="nf">quickSelect</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="n">q</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span> <span class="p">:</span> <span class="nf">quickSelect</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">q</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>结果</li>
</ul>

<blockquote>
  <p>var nums = [3,2,3,1,2,4,5,5,6]</p>

  <p>let r10 = solution.findKthLargest(&amp;nums, 4)</p>

  <p>4</p>
</blockquote>

<h3 id="最长连续增序列">最长连续增序列</h3>

<p>给定一个未排序的整数数组，找出最长连续增序列的长度。</p>

<p>要求算法复杂度O（n）</p>

<ul>
  <li>示例</li>
</ul>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code>输入：[100,4,200,1,3,2]
输出：4
解释：最长连续序列是[1,2,3,4]。长度为4
</code></pre></div></div>

<ul>
  <li>思路</li>
</ul>

<p>使用hashmap来保存数组中已经遍历过的元素，key对应元素的值，value表示该元素所在的连续子数组的长度。如果hash中存在此元素，则遍历下一个元素。如果不存在，则看hashmap中是否存在在此元素的前一个元素，比如如果遍历到5时，看看hash中是否存在4，如果存在则取该连续子数组的子一个元素，将它value值+1，并将该元素放到hashmap中，value值与第一个元素值相同，都表示该连续子数组的长度。如果hashmap中存在的该元素遍历到5时，hashmap中是否存在6，将次元素加入到最后一个连续的子数组中，并且和2中一样，找到子数组的第一个和最后一个元素，将它们的value值更新为子数组的长度。</p>

<p>swift解法简单，先排好序，然后判断i-1的值+1是否等于i的值，是的话，则继续向后，否则，当前和记录的最大值比较，currentstreak=1初始化</p>

<ul>
  <li>解法</li>
</ul>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">longestConsecutive</span><span class="p">(</span><span class="n">_</span> <span class="nv">nums</span><span class="p">:</span> <span class="p">[</span><span class="kt">Int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="p">{</span>
  <span class="k">guard</span> <span class="n">nums</span><span class="o">.</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span> <span class="p">}</span>
  <span class="k">let</span> <span class="nv">nums</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="nf">sorted</span><span class="p">(){</span><span class="nv">$0</span> <span class="o">&lt;</span> <span class="nv">$1</span><span class="p">}</span>
  
  <span class="k">var</span> <span class="nv">longestStreak</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="k">var</span> <span class="nv">currentStreak</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">1</span><span class="o">..&lt;</span><span class="n">nums</span><span class="o">.</span><span class="n">count</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="p">{</span>
      <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">{</span>
        <span class="n">currentStreak</span> <span class="o">+=</span> <span class="mi">1</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">longestStreak</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span><span class="n">longestStreak</span><span class="p">,</span> <span class="n">currentStreak</span><span class="p">)</span>
        <span class="n">currentStreak</span> <span class="o">=</span> <span class="mi">1</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nf">max</span><span class="p">(</span><span class="n">longestStreak</span><span class="p">,</span> <span class="n">currentStreak</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="按频率对整数数组进行排序">按频率对整数数组进行排序</h3>

<p>应该按频率对数组排序，如果相同的频率则对整数排序</p>

<ul>
  <li>示例</li>
</ul>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code>输入：1 1 1 1 1 2 1 2 3 3 3 3 3
输出：1 1 1 1 1 1 3 3 3 3 3 2 2
</code></pre></div></div>

<ul>
  <li>思路</li>
</ul>

<p>用hashmap存放数字出现的次数，然后对hashmap的value进行排序</p>

<p>代码实现：</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">sortFrequencyArray</span><span class="p">(</span><span class="nv">source</span><span class="p">:</span> <span class="p">[</span><span class="kt">Int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span> <span class="p">{</span>
  <span class="k">if</span> <span class="n">source</span><span class="o">.</span><span class="n">count</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">source</span>
  <span class="p">}</span>

  <span class="c1">//key是数字，value是出现的频率</span>
  <span class="k">var</span> <span class="nv">hashTable</span><span class="p">:</span> <span class="kt">Dictionary</span><span class="o">&lt;</span><span class="kt">Int</span><span class="p">,</span> <span class="kt">Int</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">[</span><span class="kt">Int</span><span class="p">:</span><span class="kt">Int</span><span class="p">]()</span>
  <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..&lt;</span><span class="n">source</span><span class="o">.</span><span class="n">count</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">source</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">hashTable</span><span class="o">.</span><span class="n">keys</span><span class="o">.</span><span class="nf">contains</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">//更新数值</span>
      <span class="k">var</span> <span class="nv">value</span> <span class="o">=</span> <span class="n">hashTable</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
      <span class="n">value</span><span class="o">!</span> <span class="o">+=</span> <span class="mi">1</span>
      <span class="n">hashTable</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="n">hashTable</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">let</span> <span class="nv">values</span> <span class="o">=</span> <span class="n">hashTable</span><span class="o">.</span><span class="n">sorted</span><span class="p">{</span>
    <span class="k">if</span> <span class="nv">$0</span><span class="o">.</span><span class="mi">1</span> <span class="o">==</span> <span class="nv">$1</span><span class="o">.</span><span class="mi">1</span> <span class="p">{</span>
      <span class="c1">//如果value（频率）相等，则按照key倒序</span>
      <span class="k">return</span> <span class="nv">$0</span><span class="o">.</span><span class="mi">0</span> <span class="o">&gt;</span> <span class="nv">$1</span><span class="o">.</span><span class="mi">0</span>
    <span class="p">}</span>

    <span class="c1">//如果value（频率）不等，则按照value倒序</span>
    <span class="k">return</span> <span class="nv">$0</span><span class="o">.</span><span class="mi">1</span> <span class="o">&gt;</span> <span class="nv">$1</span><span class="o">.</span><span class="mi">1</span>
  <span class="p">}</span>

  <span class="k">var</span> <span class="nv">result</span><span class="p">:</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]()</span>

  <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..&lt;</span><span class="n">values</span><span class="o">.</span><span class="n">count</span> <span class="p">{</span>
    <span class="k">for</span> <span class="n">_</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..&lt;</span><span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="mi">1</span> <span class="p">{</span>
      <span class="n">result</span><span class="o">.</span><span class="nf">append</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="mi">0</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">result</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>测试</li>
</ul>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">array6</span> <span class="o">=</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
<span class="k">let</span> <span class="nv">array7</span> <span class="o">=</span> <span class="n">solution</span><span class="o">.</span><span class="nf">sortFrequencyArray</span><span class="p">(</span><span class="nv">source</span><span class="p">:</span> <span class="n">array6</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">array7</span><span class="p">)</span>
</code></pre></div></div>

<ul>
  <li>结果</li>
</ul>

<blockquote>
  <p>[8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 1, 1, 1, 1, 1, 1, 7, 7, 6, 6, 5, 5, 4, 4, 3, 3, 2, 2]</p>
</blockquote>]]></content><author><name>Cambria Yang</name><email>cambriayang@qq.com</email></author><category term="Algorithm" /><category term="算法" /><summary type="html"><![CDATA[一些算法举例 数组 寻找中间数 给出一个无序数组，求出一个数，使得其左边的数都小于它，右边的数都大于等于它。要求时间复杂度为n 示例 输入：[4,3,2,7,9,10,11,10] 输出：7,9 思路 两次遍历，第一次遍历，记录下每个位置和它之后的那个元素的最小值（当然这个最小值会一直更新，所以这一次遍历完，就是整个数组的最小值），需要一个n的数组，存放的是这个位置和它后面一个位置的较小值，当然如果已经遇到了，最小值，因为会和最小值进行判断，所以后续这个新的数组里存放的都是这个最小值了。 第二次遍历是正常的从左向右遍历，寻找左边大且比右边小的数，也会记住一个最大值。 解法 func findTheMidNumber(_ data: [Int]) -&gt; [Int] { var res = [Int]() if data.count == 0 {return res} if data.count &lt;= 2 {return res} var rightMin = [Int](repeating: 0, count: data.count) var r_min = data[data.count-1] //从右往左，寻找每个位置及其之后的最小数 for i in (0..&lt;data.count).reversed() { if data[i] &lt; r_min { r_min = data[i] } rightMin[i] = r_min } //从左往右，寻找左边大且比右边小的数 var l_max = data[0] for i in 0..&lt;data.count-1 { if data[i] &gt; l_max { l_max = data[i] if data[i] &lt; rightMin[i+1] { res.append(data[i]) } } } print(res) return res } 测试 _ = findTheMidNumber([4,3,2,7,9,10,11,10]) [7, 9] 三数之和 一个包含n个整数的数组nums，判断nums中是否存在三个元素a，b，c，使得a+b+c=0？请找出所有满足条件且不重复的三元组 注意：不可以包含重复的三元组 示例 输入：nums=[-1,0,1,2,-1,-4] 输出：[[-1,0,1], [-1,-1,2]] 思路 除非三个数全是0，否则肯定会有正数和负数，所以假定选择一个数，然后再去找另外两个数，这样只要找到两个数且和为第一个选择的数的相反数。 从小到大排序 循环 如果最小的数大于0，直接结束（因为必须要有负数） 相当于两数之和问题：a+b=target，因为是排好序的，选定了i，那么j+k需要是i的相反数，如果j+k&lt;target，则j++,否则k–，j和k是右边数组的首末两端 解法 func threeSum(_ nums: [Int])-&gt;[[Int]]? { var tempNums = nums if nums.count &lt;= 0 {return nil} //排序 insertSort(arr: &amp;tempNums) if tempNums[0] &gt; 0 {return nil} var res = [[Int]]() for i in 0..&lt;tempNums.count { let target = -tempNums[i] var j = i+1 var k = tempNums.count-1 while k-j &gt; 0 { let numj = tempNums[j] let numk = tempNums[k] if numj+numk &lt; target { j += 1 } else if numj+numk &gt; target { k -= 1 } else { //找到，返回i，j，k res.append([tempNums[i],numj,numk]) break } } } return res } 测试 let res = solution.threeSum([-1,0,1,2,-1,-4]) 结果 [[-1, -1, 2], [-1, 0, 1]] 岛屿最大面积 给定一个包含了一些 0 和 1 的非空二维数组 grid 。 一个 岛屿 是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在水平或者竖直方向上相邻。你可以假设 grid 的四个边缘都被 0（代表水）包围着。 找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为 0 。) 示例 [[0,0,1,0,0,0,0,1,0,0,0,0,0], [0,0,0,0,0,0,0,1,1,1,0,0,0], [0,1,1,0,1,0,0,0,0,0,0,0,0], [0,1,0,0,1,1,0,0,1,0,1,0,0], [0,1,0,0,1,1,0,0,1,1,1,0,0], [0,0,0,0,0,0,0,0,0,0,1,0,0], [0,0,0,0,0,0,0,1,1,1,0,0,0], [0,0,0,0,0,0,0,1,1,0,0,0,0]] 对于上面这个给定矩阵应返回 6。注意答案不应该是 11 ，因为岛屿只能包含水平或垂直的四个方向的 1 。 注意: 给定的矩阵grid 的长度和宽度都不超过 50。 解法 func dfs(_ i: Int,_ j: Int,_ m: Int,_ n:Int,_ grid: inout [[Int]],_ tempArea: inout Int) -&gt; Int { if i&lt;0 || i&gt;=m || j&lt;0 || j&gt;=n || grid[i][j] == 0 { return tempArea } grid[i][j] = 0 tempArea += 1 tempArea = dfs(i+1, j, m, n, &amp;grid, &amp;tempArea) tempArea = dfs(i-1, j, m, n, &amp;grid, &amp;tempArea) tempArea = dfs(i, j+1, m, n, &amp;grid, &amp;tempArea) tempArea = dfs(i, j-1, m, n, &amp;grid, &amp;tempArea) return tempArea } func maxAreaOfIsland(_ grid: [[Int]]) -&gt; Int { var tempGrid = grid var area = 0 let m = tempGrid.count var n = 0 var islandMax = 0 for i in 0..&lt;m { n = tempGrid[i].count for j in 0..&lt;n { area = 0 area = dfs(i, j, m, n, &amp;tempGrid, &amp;area) islandMax = max(islandMax, area) } } return islandMax } 最长递增子序列（非连续） 给定一个未经排序的整数数组，找到最长递增子序列 示例 输入：10，9，2，5，3，7，101，18，20 输出：2，3，7，18，20 思路 一个巧妙的方法，一般来说第一遍for i-&gt;n-1(n),第二遍for j-&gt;i-1(n).这里可以加速的是第二个循环，因为第一个循环肯定是不能加速的，所以只能加速第二个循环。 可以维护一个数组LIS（最后的结果数组），一开始数组是空的，当第一个数10进来，毫无疑问，它就是最长递增子序列，9进来的时候，如果它比10大则直接append，否则用二分查找法去找到数组中比它大的最小的数，替换掉， 因为我们相当于要不断让更小的数进来，所以很好理解。这个复杂度是logn的，所以整体是nlogn的时间复杂度。 实现 最长连续递增序列 给定一个未经排序的整数数组，找到最长且连续的递增序列，并返回该序列的长度。 示例 输入：[1,3,5,4,7] 输出：3 解释：最长递增序列是[1,3,5], 长度为3 输入：[2,2,2,2] 输出：1 解释：最长连续递增序列是[2], 长度为1 注：数组长度不超过10000 思路 count 为当前元素峰值，ans为最大峰值 初始化 count=1 从0位置开始遍历，遍历是根据前后元素状态判断是否递增，递增则count++，递减count=1 如果count&gt;ans，则更新ans 直到循环结束 解法 func findLengthOfLCIS(_ nums: [Int])-&gt;Int { if nums.count &lt;= 1 {return nums.count} var ans = 1 var count = 1 for i in 0..&lt;nums.count-1 { if nums[i+1] &gt; nums[i] { count += 1 } else { count = 1 } ans = count&gt;ans ? count : ans } return ans } 结果 print(solution.findLengthOfLCIS([1,3,5,4,7])) 3 数组中的第K大的元素 在未排序的数组中找到第k大的元素。 示例 输入： [3,2,1,5,6,4], k=2 输出：5 输入： [3,2,3,1,2,4,5,5,6], k=4 输出：4 假设k总是有效的，且1&lt;=k&lt;=数组长度 思路 改进快速排序算法，求得第k大的元素，不需要将快速排序完全进行完，只需要进行一遍的递归，如果q刚好是第k大，则打完收工。 解法 //寻找pivot的函数 func partition(arr: inout [Int], left: Int, right: Int) -&gt; Int { let pivot = left var index = pivot+1 for i in index...right { if arr[i] &lt; arr[pivot] { arr.swapAt(i, index) index+=1 //i和index都更新，以pivot为分隔，两边都冒泡，后面再将假设的pivot替换为真正的pivot，然后继续递归 } } //此处相当于pivot需要更新 arr.swapAt(pivot, index-1) return index-1 } func findKthLargest(_ nums: inout [Int], _ k: Int) -&gt; Int { return quickSelect(&amp;nums, 0, nums.count-1, nums.count-k) } func quickSelect(_ a: inout [Int], _ l: Int, _ r: Int, _ index: Int) -&gt; Int { let q = partition(arr: &amp;a, left: l, right: r) if q == index { return a[q] } else { return q&lt;index ? quickSelect(&amp;a, q+1, r, index) : quickSelect(&amp;a, l, q-1, index) } } 结果 var nums = [3,2,3,1,2,4,5,5,6] let r10 = solution.findKthLargest(&amp;nums, 4) 4 最长连续增序列 给定一个未排序的整数数组，找出最长连续增序列的长度。 要求算法复杂度O（n） 示例 输入：[100,4,200,1,3,2] 输出：4 解释：最长连续序列是[1,2,3,4]。长度为4 思路 使用hashmap来保存数组中已经遍历过的元素，key对应元素的值，value表示该元素所在的连续子数组的长度。如果hash中存在此元素，则遍历下一个元素。如果不存在，则看hashmap中是否存在在此元素的前一个元素，比如如果遍历到5时，看看hash中是否存在4，如果存在则取该连续子数组的子一个元素，将它value值+1，并将该元素放到hashmap中，value值与第一个元素值相同，都表示该连续子数组的长度。如果hashmap中存在的该元素遍历到5时，hashmap中是否存在6，将次元素加入到最后一个连续的子数组中，并且和2中一样，找到子数组的第一个和最后一个元素，将它们的value值更新为子数组的长度。 swift解法简单，先排好序，然后判断i-1的值+1是否等于i的值，是的话，则继续向后，否则，当前和记录的最大值比较，currentstreak=1初始化 解法 func longestConsecutive(_ nums: [Int]) -&gt; Int { guard nums.count &gt; 0 else { return 0 } let nums = nums.sorted(){$0 &lt; $1} var longestStreak = 1 var currentStreak = 1 for i in 1..&lt;nums.count { if nums[i] != nums[i - 1] { if nums[i - 1] + 1 == nums[i] { currentStreak += 1 } else { longestStreak = max(longestStreak, currentStreak) currentStreak = 1 } } } return max(longestStreak, currentStreak) } 按频率对整数数组进行排序 应该按频率对数组排序，如果相同的频率则对整数排序 示例 输入：1 1 1 1 1 2 1 2 3 3 3 3 3 输出：1 1 1 1 1 1 3 3 3 3 3 2 2 思路 用hashmap存放数字出现的次数，然后对hashmap的value进行排序 代码实现： func sortFrequencyArray(source: [Int]) -&gt; [Int] { if source.count &lt;= 1 { return source } //key是数字，value是出现的频率 var hashTable: Dictionary&lt;Int, Int&gt; = [Int:Int]() for i in 0..&lt;source.count { let key: Int = source[i] if hashTable.keys.contains(key) { //更新数值 var value = hashTable[key] value! += 1 hashTable[key] = value } else { hashTable[key] = 1 } } let values = hashTable.sorted{ if $0.1 == $1.1 { //如果value（频率）相等，则按照key倒序 return $0.0 &gt; $1.0 } //如果value（频率）不等，则按照value倒序 return $0.1 &gt; $1.1 } var result: [Int] = [Int]() for i in 0..&lt;values.count { for _ in 0..&lt;values[i].1 { result.append(values[i].0) } } return result } 测试 let array6 = [8,8,8,8,8,8,8,8,8,8,8,8,8,7,7,1,1,6,6,1,1,1,2,1,2,4,4,3,3,5,5] let array7 = solution.sortFrequencyArray(source: array6) print(array7) 结果 [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 1, 1, 1, 1, 1, 1, 7, 7, 6, 6, 5, 5, 4, 4, 3, 3, 2, 2]]]></summary></entry><entry><title type="html">字符串算法</title><link href="http://localhost:4000/algorithm/2022/03/08/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AE%97%E6%B3%95.html" rel="alternate" type="text/html" title="字符串算法" /><published>2022-03-08T03:00:00+00:00</published><updated>2022-03-08T03:00:00+00:00</updated><id>http://localhost:4000/algorithm/2022/03/08/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AE%97%E6%B3%95</id><content type="html" xml:base="http://localhost:4000/algorithm/2022/03/08/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AE%97%E6%B3%95.html"><![CDATA[<p>一些算法举例</p>

<h2 id="字符串">字符串</h2>

<h3 id="复原ip地址">复原IP地址</h3>

<p>给定一个只包含数字的字符串，复原它并返回所有可能的IP地址格式。</p>

<p>有效的IP地址正好由四个整数（0到255之间组成），整数之间用’.’分隔。</p>

<ul>
  <li>示例</li>
</ul>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code>输入： "25525511135"
输出：["255.255.11.135", "255.255.111.35"]
</code></pre></div></div>

<ul>
  <li>思路</li>
</ul>

<p>回溯法</p>

<p>1、一开始，字符串的长度小于 4 或者大于 12 ，一定不能拼凑出合法的 ip 地址（这一点可以一般化到中间结点的判断中，以产生剪枝行为）；</p>

<p>2、每一个结点可以选择截取的方法只有 3 种：截 1 位、截 2 位、截 3 位，因此每一个结点可以生长出的分支最多只有 3 条分支；</p>

<p>根据截取出来的字符串判断是否是合理的 ip 段，这里写法比较多，可以先截取，再转换成 int ，再判断。我采用的做法是先转成 int，是合法的 ip 段数值以后，再截取。</p>

<p>3、由于 ip 段最多就 4 个段，因此这棵三叉树最多 4 层，这个条件作为递归终止条件之一；</p>

<ul>
  <li>解法</li>
</ul>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">restoreIpAddresses</span><span class="p">(</span><span class="n">_</span> <span class="nv">s</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="kt">String</span><span class="p">]</span> <span class="p">{</span>
  <span class="c1">//回溯法</span>
  <span class="k">var</span> <span class="nv">res</span><span class="p">:[</span><span class="kt">String</span><span class="p">]</span><span class="o">=</span><span class="p">[]</span>
  <span class="k">var</span> <span class="nv">tmp</span><span class="p">:[</span><span class="kt">String</span><span class="p">]</span><span class="o">=</span><span class="p">[]</span>
  <span class="k">let</span> <span class="nv">chs</span><span class="p">:[</span><span class="kt">Character</span><span class="p">]</span><span class="o">=</span><span class="p">[</span><span class="kt">Character</span><span class="p">](</span><span class="n">s</span><span class="p">)</span>
  <span class="nf">backTrace</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="p">,</span><span class="o">&amp;</span><span class="n">tmp</span><span class="p">,</span><span class="n">chs</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">res</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">backTrace</span><span class="p">(</span><span class="n">_</span> <span class="nv">res</span><span class="p">:</span><span class="k">inout</span> <span class="p">[</span><span class="kt">String</span><span class="p">],</span><span class="n">_</span> <span class="nv">tmp</span><span class="p">:</span><span class="k">inout</span> <span class="p">[</span><span class="kt">String</span><span class="p">],</span><span class="n">_</span> <span class="nv">chs</span><span class="p">:[</span><span class="kt">Character</span><span class="p">],</span><span class="n">_</span> <span class="nv">ind</span><span class="p">:</span><span class="kt">Int</span><span class="p">,</span><span class="n">_</span> <span class="nv">has</span><span class="p">:</span><span class="kt">Int</span><span class="p">){</span>
  <span class="k">if</span> <span class="n">ind</span> <span class="o">==</span> <span class="n">chs</span><span class="o">.</span><span class="n">count</span> <span class="o">&amp;&amp;</span> <span class="n">has</span> <span class="o">==</span> <span class="mi">4</span><span class="p">{</span>
    <span class="k">var</span> <span class="nv">str</span><span class="p">:</span><span class="kt">String</span><span class="o">=</span><span class="s">""</span>
    <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="n">tmp</span><span class="p">{</span>
      <span class="n">str</span> <span class="o">+=</span> <span class="n">i</span><span class="o">+</span><span class="s">"."</span>
    <span class="p">}</span>
    <span class="n">str</span><span class="o">.</span><span class="nf">removeLast</span><span class="p">()</span>
    <span class="n">res</span><span class="o">.</span><span class="nf">append</span><span class="p">(</span><span class="n">str</span><span class="p">)</span>
    <span class="k">return</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">has</span> <span class="o">==</span> <span class="mi">4</span> <span class="o">&amp;&amp;</span> <span class="n">ind</span> <span class="o">&lt;</span> <span class="n">chs</span><span class="o">.</span><span class="n">count</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">ind</span> <span class="o">==</span> <span class="n">chs</span><span class="o">.</span><span class="n">count</span> <span class="o">&amp;&amp;</span> <span class="n">has</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">){</span><span class="k">return</span><span class="p">}</span>
  <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="n">ind</span><span class="o">...</span><span class="n">ind</span><span class="o">+</span><span class="mi">2</span><span class="p">{</span>
    <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">chs</span><span class="o">.</span><span class="n">count</span><span class="p">{</span><span class="k">break</span><span class="p">}</span>    <span class="c1">//确保i是一个有效的下标</span>
    <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">ind</span> <span class="o">&amp;&amp;</span> <span class="n">chs</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">==</span> <span class="s">"0"</span><span class="p">{</span><span class="k">break</span><span class="p">}</span>
    <span class="k">let</span> <span class="nv">str</span><span class="p">:</span><span class="kt">String</span><span class="o">=</span><span class="kt">String</span><span class="p">(</span><span class="n">chs</span><span class="p">[</span><span class="n">ind</span><span class="o">...</span><span class="n">i</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">str</span><span class="o">.</span><span class="n">count</span> <span class="o">==</span> <span class="mi">3</span> <span class="o">&amp;&amp;</span> <span class="n">str</span> <span class="o">&gt;</span> <span class="s">"255"</span><span class="p">{</span><span class="k">continue</span><span class="p">}</span>  <span class="c1">//长度为1和2的数都可以，为3的话需要筛选</span>
    <span class="n">tmp</span><span class="o">.</span><span class="nf">append</span><span class="p">(</span><span class="n">str</span><span class="p">)</span>
    <span class="nf">backTrace</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="p">,</span><span class="o">&amp;</span><span class="n">tmp</span><span class="p">,</span><span class="n">chs</span><span class="p">,</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">has</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">tmp</span><span class="o">.</span><span class="nf">removeLast</span><span class="p">()</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>结果</li>
</ul>

<blockquote>
  <p>let ress = solution.restoreIpAddresses(“25525511135”)</p>

  <p>print(ress)</p>

  <p><strong>[“255.255.11.135”, “255.255.111.35”]</strong></p>
</blockquote>

<h3 id="字符串相乘">字符串相乘</h3>

<ul>
  <li>示例</li>
</ul>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code>输入：num1="123"，num2="456"
输出："56088"
num1,num2均不以0开头，除非是数字0本身
</code></pre></div></div>

<ul>
  <li>思路</li>
</ul>

<p>第i位和第j位相乘，结果会在第i+j上面，如果有进位，则i+j-1上也有，结果是倒序的</p>

<ul>
  <li>解法</li>
</ul>

<p>代码实现：</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">multiply</span><span class="p">(</span><span class="n">_</span> <span class="nv">num1</span><span class="p">:</span> <span class="kt">String</span><span class="p">,</span> <span class="n">_</span> <span class="nv">num2</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">String</span> <span class="p">{</span>
        <span class="k">if</span> <span class="kt">Int</span><span class="p">(</span><span class="n">num1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="kt">Int</span><span class="p">(</span><span class="n">num2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span><span class="k">return</span> <span class="s">"0"</span><span class="p">}</span>
        <span class="k">var</span> <span class="nv">result</span> <span class="o">=</span> <span class="s">""</span>
        <span class="k">var</span> <span class="nv">resultArray</span><span class="p">:</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span><span class="o">.</span><span class="nf">init</span><span class="p">(</span><span class="nf">repeatElement</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nv">count</span><span class="p">:</span> <span class="n">num1</span><span class="o">.</span><span class="n">count</span><span class="o">+</span><span class="n">num2</span><span class="o">.</span><span class="n">count</span><span class="p">))</span>
        <span class="c1">//这两个for执行完，结果数组里面是未处理过进位的结果</span>
        <span class="k">for</span> <span class="n">i</span> <span class="nf">in</span> <span class="p">(</span><span class="mi">0</span><span class="o">..&lt;</span><span class="n">num1</span><span class="o">.</span><span class="n">count</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">for</span> <span class="n">j</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..&lt;</span><span class="n">num2</span><span class="o">.</span><span class="n">count</span> <span class="p">{</span>
                <span class="k">let</span> <span class="nv">c1</span> <span class="o">=</span> <span class="kt">Int</span><span class="p">(</span><span class="kt">String</span><span class="p">(</span><span class="n">num1</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span><span class="o">!</span>
                <span class="k">let</span> <span class="nv">c2</span> <span class="o">=</span> <span class="kt">Int</span><span class="p">(</span><span class="kt">String</span><span class="p">(</span><span class="n">num2</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span><span class="o">!</span>
                
                <span class="k">let</span> <span class="nv">res</span> <span class="o">=</span> <span class="n">c1</span><span class="o">*</span><span class="n">c2</span>
                <span class="n">resultArray</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">res</span>
            <span class="p">}</span>
        <span class="p">}</span>
        
        <span class="c1">//处理进位</span>
        <span class="k">var</span> <span class="nv">carrys</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="nf">in</span> <span class="p">(</span><span class="mi">0</span><span class="o">..&lt;</span><span class="n">resultArray</span><span class="o">.</span><span class="n">count</span><span class="p">)</span><span class="o">.</span><span class="nf">reversed</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">resultArray</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="k">continue</span>
            <span class="p">}</span>
            
            <span class="k">let</span> <span class="nv">tmp</span> <span class="o">=</span> <span class="n">resultArray</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="n">carrys</span>
            
            <span class="n">carrys</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">/</span><span class="mi">10</span>
            <span class="n">resultArray</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">%</span><span class="mi">10</span>
        <span class="p">}</span>
        
        <span class="c1">//最后一位如果是0，则需要舍弃</span>
        <span class="k">let</span> <span class="nv">end</span> <span class="o">=</span> <span class="n">resultArray</span><span class="o">.</span><span class="n">last</span><span class="o">!==</span><span class="mi">0</span> <span class="p">?</span> <span class="n">resultArray</span><span class="o">.</span><span class="n">count</span><span class="o">-</span><span class="mi">1</span> <span class="p">:</span> <span class="n">resultArray</span><span class="o">.</span><span class="n">count</span>
        <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..&lt;</span><span class="n">end</span> <span class="p">{</span>
            <span class="n">result</span> <span class="o">+=</span> <span class="kt">String</span><span class="p">(</span><span class="n">resultArray</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="p">}</span>
        
        <span class="k">return</span> <span class="n">result</span>
    <span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>测试</li>
</ul>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">print</span><span class="p">(</span><span class="n">solution</span><span class="o">.</span><span class="nf">multiply</span><span class="p">(</span><span class="s">"123"</span><span class="p">,</span> <span class="s">"3128"</span><span class="p">))</span>
</code></pre></div></div>

<ul>
  <li>结果</li>
</ul>

<blockquote>
  <p>384744</p>
</blockquote>

<h3 id="字符串s1和s2判断s2中是否包含s1的排列">字符串s1和s2，判断s2中是否包含s1的排列</h3>

<ul>
  <li>示例</li>
</ul>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code>输入："abo"和"eidboammnj"
输出：true
如果是"abb"则false，字符串都是小写，长度1-10000
</code></pre></div></div>

<ul>
  <li>思路</li>
</ul>

<p>采用窗口滑动法，从开始的空窗口从左向右滑动</p>

<ul>
  <li>解法</li>
</ul>

<p>代码实现：</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//保证了字符串都是小写字母，97是小写的a，65是大写的A</span>
    <span class="kd">func</span> <span class="nf">checkInclusion</span><span class="p">(</span><span class="n">_</span> <span class="nv">s1</span><span class="p">:</span> <span class="kt">String</span><span class="p">,</span> <span class="n">_</span> <span class="nv">s2</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Bool</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">s1</span><span class="o">.</span><span class="n">isEmpty</span> <span class="o">||</span> <span class="n">s2</span><span class="o">.</span><span class="n">isEmpty</span> <span class="p">{</span><span class="k">return</span> <span class="kc">false</span><span class="p">}</span>
        <span class="k">guard</span> <span class="n">s1</span><span class="o">.</span><span class="n">count</span> <span class="o">&lt;=</span> <span class="n">s2</span><span class="o">.</span><span class="n">count</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">false</span>
        <span class="p">}</span>

        <span class="kd">func</span> <span class="nf">allZero</span><span class="p">(</span><span class="n">_</span> <span class="nv">counts</span><span class="p">:</span> <span class="p">[</span><span class="kt">Int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kt">Bool</span> <span class="p">{</span>
            <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">0</span> <span class="o">..&lt;</span> <span class="mi">26</span> <span class="p">{</span>
                <span class="k">if</span> <span class="n">counts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
                    <span class="k">return</span> <span class="kc">false</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="kc">true</span>
        <span class="p">}</span>

        <span class="k">let</span> <span class="nv">chars1</span> <span class="o">=</span> <span class="kt">Array</span><span class="p">(</span><span class="n">s1</span><span class="o">.</span><span class="n">unicodeScalars</span><span class="p">)</span>
        <span class="k">let</span> <span class="nv">chars2</span> <span class="o">=</span> <span class="kt">Array</span><span class="p">(</span><span class="n">s2</span><span class="o">.</span><span class="n">unicodeScalars</span><span class="p">)</span>
        <span class="k">let</span> <span class="nv">len1</span> <span class="o">=</span> <span class="n">chars1</span><span class="o">.</span><span class="n">count</span>
        <span class="k">let</span> <span class="nv">len2</span> <span class="o">=</span> <span class="n">chars2</span><span class="o">.</span><span class="n">count</span>
        <span class="k">var</span> <span class="nv">counts</span> <span class="o">=</span> <span class="p">[</span><span class="kt">Int</span><span class="p">](</span><span class="nf">repeatElement</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nv">count</span><span class="p">:</span> <span class="mi">26</span><span class="p">))</span>

        <span class="c1">//可以简单理解有两个同时滑动的窗口，都向右滑，上面一个窗口后面会为空</span>
        <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">0</span> <span class="o">..&lt;</span> <span class="n">len1</span> <span class="p">{</span>
            <span class="c1">//s1从右边滑进的+1，从右边滑出的-1</span>
            <span class="n">counts</span><span class="p">[</span><span class="kt">Int</span><span class="p">(</span><span class="n">chars1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">value</span> <span class="o">-</span> <span class="mi">97</span><span class="p">)]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="c1">//s2从右边滑进的-1，从右边滑出的-1</span>
            <span class="n">counts</span><span class="p">[</span><span class="kt">Int</span><span class="p">(</span><span class="n">chars2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">value</span> <span class="o">-</span> <span class="mi">97</span><span class="p">)]</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="nf">allZero</span><span class="p">(</span><span class="n">counts</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="kc">true</span><span class="p">}</span>
        
        <span class="c1">//因为都是s2，所以只看滑进还是滑出</span>
        <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="n">len1</span> <span class="o">..&lt;</span> <span class="n">len2</span> <span class="p">{</span>
            <span class="c1">//从右边滑进，-1</span>
            <span class="n">counts</span><span class="p">[</span><span class="kt">Int</span><span class="p">(</span><span class="n">chars2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">value</span> <span class="o">-</span> <span class="mi">97</span><span class="p">)]</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="c1">//从右边滑出，+1</span>
            <span class="n">counts</span><span class="p">[</span><span class="kt">Int</span><span class="p">(</span><span class="n">chars2</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">len1</span><span class="p">]</span><span class="o">.</span><span class="n">value</span> <span class="o">-</span> <span class="mi">97</span><span class="p">)]</span> <span class="o">+=</span> <span class="mi">1</span>
            
            <span class="k">if</span> <span class="nf">allZero</span><span class="p">(</span><span class="n">counts</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="kc">true</span><span class="p">}</span>
        <span class="p">}</span>

        <span class="c1">//窗口的大小是短串的长度，必须要这样，否则肯定是false</span>
        <span class="k">return</span> <span class="kc">false</span>
    <span class="p">}</span>
</code></pre></div></div>

<h3 id="有一个字符串和一组子字符串请返回覆盖率最高单词最多的子字符串列表">有一个字符串和一组子字符串，请返回覆盖率最高，单词最多的子字符串列表</h3>

<p>示例：</p>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code>字符串: abcdefg
子字符串: ((ab，0, 1), (cd, 2, 3)，(efg，4, 6), (abc，0，2)，(abcd, 0, 3), (cdef, 2, 5))
期望: {ab, cd, efg}
</code></pre></div></div>

<ul>
  <li>分析</li>
</ul>

<h3 id="最长不重复子串">最长不重复子串</h3>

<p>给定一个字符串，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。
示例：</p>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code> 输入："adbdeacdmmm"
 输出：5
 解释：因为无重复的最长子串是"bdeac"或者"eacdm"
</code></pre></div></div>

<ul>
  <li>分析</li>
</ul>

<p>首先本体如果使用两层for循环当然可以轻松搞定，但是时间复杂度也是O（n^2），显然不是很满意，所以需要想个法子将复杂度调整到O（n）。
因为是子串，不是子序列，所以肯定是一串连续的字符区域。头设定为start，尾设定为end。那么在仅仅遍历一遍的情况下，start是会不断往后涨的，end就是当前遍历的位置。
    1. 如果当前遍历的字符在start后面没有出现过，则接着遍历，start往后移
    2. 如果当前遍历的字符已经出现了（这里可以使用hash表记录，key是character，value是index），则说明肯定有字符重复，需要将start移到这个重复字符处，也就是遍历的字符上一次出现的位置的下一个位置（index）
    3. 在这个过程中，时刻更新最大长度</p>

<ul>
  <li>解法</li>
</ul>

<p>代码实现：</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//code1</span>
<span class="kd">extension</span> <span class="kt">String</span> <span class="p">{</span>
    <span class="nf">subscript</span><span class="p">(</span><span class="n">_</span> <span class="nv">i</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span><span class="o">-&gt;</span><span class="kt">Character</span> <span class="p">{</span>
        <span class="k">get</span> <span class="p">{</span><span class="k">return</span> <span class="k">self</span><span class="p">[</span><span class="nf">index</span><span class="p">(</span><span class="n">startIndex</span><span class="p">,</span> <span class="nv">offsetBy</span><span class="p">:</span> <span class="n">i</span><span class="p">)]}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>code1是为了给string添加subscript操作，真正功能代码是：</p>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">//code2</span>
    <span class="kd">func</span> <span class="nf">lengthOfLongestSubstring</span><span class="p">(</span><span class="n">_</span> <span class="nv">s</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="kt">Int</span><span class="p">,</span> <span class="kt">String</span><span class="p">?)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">isEmpty</span> <span class="p">{</span>
            <span class="nf">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="k">var</span> <span class="nv">maxLength</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">var</span> <span class="nv">start</span> <span class="o">=</span> <span class="n">maxLength</span>
        
        <span class="k">var</span> <span class="nv">retString</span><span class="p">:</span> <span class="kt">String</span><span class="p">?</span> <span class="o">=</span> <span class="s">" "</span>
        
        <span class="k">var</span> <span class="nv">hashTable</span><span class="p">:</span> <span class="kt">Dictionary</span><span class="o">&lt;</span><span class="kt">Character</span><span class="p">,</span> <span class="kt">Int</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">[</span><span class="kt">Character</span><span class="p">:</span><span class="kt">Int</span><span class="p">]()</span>
                
        <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..&lt;</span><span class="n">s</span><span class="o">.</span><span class="n">count</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">hashTable</span><span class="o">.</span><span class="n">keys</span><span class="o">.</span><span class="nf">contains</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&amp;&amp;</span> <span class="n">hashTable</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">!</span> <span class="o">&gt;=</span> <span class="n">start</span> <span class="p">{</span>
                <span class="n">start</span> <span class="o">=</span> <span class="n">hashTable</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">!+</span><span class="mi">1</span>
            <span class="p">}</span>
            
            <span class="n">hashTable</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">i</span>
            
            <span class="n">maxLength</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span><span class="n">maxLength</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">-</span><span class="n">start</span><span class="p">)</span>
        <span class="p">}</span>
        
        <span class="nf">return</span> <span class="p">(</span><span class="n">maxLength</span><span class="p">,</span> <span class="n">retString</span><span class="o">!</span><span class="p">)</span>
    <span class="p">}</span>
</code></pre></div></div>
<p>当然code2实际上只是输出长度并没有输出子字符串，我们尝试着输出长度和子字符串，其实就是在code2的基础上稍微改一下：</p>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">//code3</span>
    <span class="kd">func</span> <span class="nf">lengthOfLongestSubstring</span><span class="p">(</span><span class="n">_</span> <span class="nv">s</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="kt">Int</span><span class="p">,</span> <span class="kt">String</span><span class="p">?)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">isEmpty</span> <span class="p">{</span>
            <span class="nf">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
        <span class="p">}</span>
        
        <span class="k">var</span> <span class="nv">maxLength</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">var</span> <span class="nv">start</span> <span class="o">=</span> <span class="n">maxLength</span>
        
        <span class="k">var</span> <span class="nv">retString</span><span class="p">:</span> <span class="kt">String</span><span class="p">?</span> <span class="o">=</span> <span class="s">" "</span>
        <span class="k">let</span> <span class="nv">strArray</span> <span class="o">=</span> <span class="kt">Array</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        
        <span class="k">var</span> <span class="nv">hashTable</span><span class="p">:</span> <span class="kt">Dictionary</span><span class="o">&lt;</span><span class="kt">Character</span><span class="p">,</span> <span class="kt">Int</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">[</span><span class="kt">Character</span><span class="p">:</span><span class="kt">Int</span><span class="p">]()</span>
                
        <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..&lt;</span><span class="n">s</span><span class="o">.</span><span class="n">count</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">hashTable</span><span class="o">.</span><span class="n">keys</span><span class="o">.</span><span class="nf">contains</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&amp;&amp;</span> <span class="n">hashTable</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">!</span> <span class="o">&gt;=</span> <span class="n">start</span> <span class="p">{</span>
                <span class="n">start</span> <span class="o">=</span> <span class="n">hashTable</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">!+</span><span class="mi">1</span>
            <span class="p">}</span>
            
            <span class="n">hashTable</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">i</span>
            
            <span class="c1">//此处就是获取子串，由于会一直遍历到最后，所以如果有多个相等长度的子串，会停留在最后一个子串，返回</span>
            <span class="k">if</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">-</span><span class="n">start</span> <span class="o">&gt;=</span> <span class="n">maxLength</span> <span class="p">{</span>
                <span class="k">let</span> <span class="nv">subArr</span> <span class="o">=</span> <span class="n">strArray</span><span class="p">[</span><span class="n">start</span><span class="o">..&lt;</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">let</span> <span class="nv">subStr</span><span class="p">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">subArr</span><span class="o">.</span><span class="n">map</span><span class="p">{</span><span class="kt">String</span><span class="o">.</span><span class="nf">init</span><span class="p">(</span><span class="nv">$0</span><span class="p">)}</span><span class="o">.</span><span class="nf">joined</span><span class="p">()</span>
                <span class="n">retString</span> <span class="o">=</span> <span class="n">subStr</span>
            <span class="p">}</span>
            
            <span class="n">maxLength</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span><span class="n">maxLength</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">-</span><span class="n">start</span><span class="p">)</span>
        <span class="p">}</span>

        <span class="nf">return</span> <span class="p">(</span><span class="n">maxLength</span><span class="p">,</span> <span class="n">retString</span><span class="o">!</span><span class="p">)</span>
    <span class="p">}</span>
</code></pre></div></div>

<p>示例代码如下:</p>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="nv">solution</span> <span class="o">=</span> <span class="kt">Solution</span><span class="p">()</span>
<span class="k">var</span> <span class="nv">turple1</span> <span class="o">=</span> <span class="n">solution</span><span class="o">.</span><span class="nf">lengthOfLongestSubstring</span><span class="p">(</span><span class="s">"adbdeacdmmm"</span><span class="p">)</span>

<span class="nf">print</span><span class="p">(</span><span class="n">turple1</span><span class="p">)</span>
</code></pre></div></div>
<p>以“adbdeacdmmm”为例，则长度为5，子串为：”bdeac”或者”eacdm”，但是由于“eacdm”在后面，所以输出的是“eacdm”
可以看到：</p>

<p><img src="http://localhost:4000/assets/images/posts/leetcode_lengthOfLongestSubstring.jpg" alt="lengthOfLongestSubstring" /></p>

<h3 id="最长公共前缀">最长公共前缀</h3>
<p>编写一个函数来查找字符串数组中的最长公共前缀。
如果不存在公共前缀，返回空字符串”” 
示例：</p>
<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code>输入：["flower","flow","flight"]
输出："fl"
</code></pre></div></div>
<p><em>说明</em>
所有的输入只包含小写字母<code class="language-plaintext highlighter-rouge">a-z</code></p>
<ul>
  <li>解法一</li>
</ul>

<p>暴力循环法，从题目可知：<strong>最长公共前缀的长度一定是字符串数组中长度最短的哪个字符串</strong></p>
<ol>
  <li>首先找出长度最短的字符串str，比如str=”abcf”。</li>
  <li>以此对’abcf’,’abc’,’ab’,’a’进行筛选，判断哪个是所有的其他字符串的前缀。</li>
</ol>

<ul>
  <li>解法二</li>
</ul>

<p>看下图：</p>

<p><img src="http://localhost:4000/assets/images/posts/leetcode_longestCommonPrefix.jpg" alt="longestCommonPrefix" /></p>

<p>对str[0]按照字符遍历，与其他字符串以此比较对应位置上的字符，并记录查找位置，如果找到不相等或者对应字符串的长度到了限制，就找到了。</p>

<p>代码如下：</p>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">func</span> <span class="nf">longestCommonPrefix</span><span class="p">(</span><span class="n">_</span> <span class="nv">strs</span><span class="p">:</span> <span class="p">[</span><span class="kt">String</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kt">String</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">strs</span><span class="o">.</span><span class="n">count</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="k">return</span> <span class="s">""</span>
        <span class="p">}</span>
        
        <span class="k">if</span> <span class="n">strs</span><span class="o">.</span><span class="n">count</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">strs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="p">}</span>
        
        <span class="k">let</span> <span class="nv">str</span> <span class="o">=</span> <span class="n">strs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..&lt;</span><span class="n">str</span><span class="o">.</span><span class="n">count</span> <span class="p">{</span>
            <span class="k">let</span> <span class="nv">c</span><span class="p">:</span> <span class="kt">Character</span> <span class="o">=</span> <span class="n">str</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">j</span> <span class="k">in</span> <span class="mi">1</span><span class="o">..&lt;</span><span class="n">strs</span><span class="o">.</span><span class="n">count</span> <span class="p">{</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">strs</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">count</span> <span class="o">||</span> <span class="n">c</span> <span class="o">!=</span> <span class="n">strs</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="p">{</span>
                    <span class="k">let</span> <span class="nv">rightIndex</span> <span class="o">=</span> <span class="n">strs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="nf">index</span><span class="p">(</span><span class="n">strs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">startIndex</span><span class="p">,</span> <span class="nv">offsetBy</span><span class="p">:</span> <span class="n">i</span><span class="p">)</span>
                    <span class="k">return</span> <span class="kt">String</span><span class="p">(</span><span class="n">strs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">strs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">startIndex</span><span class="o">..&lt;</span><span class="n">rightIndex</span><span class="p">])</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
        
        <span class="k">return</span> <span class="n">strs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="p">}</span>
</code></pre></div></div>
<p>测试：</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">strs2</span><span class="p">:</span> <span class="p">[</span><span class="kt">String</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s">"abcdfj"</span><span class="p">,</span> <span class="s">"abc"</span><span class="p">,</span> <span class="s">"abcmnihiuh"</span><span class="p">,</span> <span class="s">"abcmunh"</span><span class="p">]</span>
<span class="k">let</span> <span class="nv">str2</span><span class="p">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">solution</span><span class="o">.</span><span class="nf">longestCommonPrefix</span><span class="p">(</span><span class="n">strs2</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">str2</span><span class="p">)</span>
</code></pre></div></div>

<p>结果：</p>
<blockquote>
  <p>abc</p>
</blockquote>]]></content><author><name>Cambria Yang</name><email>cambriayang@qq.com</email></author><category term="Algorithm" /><category term="算法" /><summary type="html"><![CDATA[一些算法举例 字符串 复原IP地址 给定一个只包含数字的字符串，复原它并返回所有可能的IP地址格式。 有效的IP地址正好由四个整数（0到255之间组成），整数之间用’.’分隔。 示例 输入： "25525511135" 输出：["255.255.11.135", "255.255.111.35"] 思路 回溯法 1、一开始，字符串的长度小于 4 或者大于 12 ，一定不能拼凑出合法的 ip 地址（这一点可以一般化到中间结点的判断中，以产生剪枝行为）； 2、每一个结点可以选择截取的方法只有 3 种：截 1 位、截 2 位、截 3 位，因此每一个结点可以生长出的分支最多只有 3 条分支； 根据截取出来的字符串判断是否是合理的 ip 段，这里写法比较多，可以先截取，再转换成 int ，再判断。我采用的做法是先转成 int，是合法的 ip 段数值以后，再截取。 3、由于 ip 段最多就 4 个段，因此这棵三叉树最多 4 层，这个条件作为递归终止条件之一； 解法 func restoreIpAddresses(_ s: String) -&gt; [String] { //回溯法 var res:[String]=[] var tmp:[String]=[] let chs:[Character]=[Character](s) backTrace(&amp;res,&amp;tmp,chs,0,0) return res } func backTrace(_ res:inout [String],_ tmp:inout [String],_ chs:[Character],_ ind:Int,_ has:Int){ if ind == chs.count &amp;&amp; has == 4{ var str:String="" for i in tmp{ str += i+"." } str.removeLast() res.append(str) return } if (has == 4 &amp;&amp; ind &lt; chs.count) || (ind == chs.count &amp;&amp; has &lt; 4){return} for i in ind...ind+2{ if i &gt;= chs.count{break} //确保i是一个有效的下标 if i &gt; ind &amp;&amp; chs[ind] == "0"{break} let str:String=String(chs[ind...i]) if str.count == 3 &amp;&amp; str &gt; "255"{continue} //长度为1和2的数都可以，为3的话需要筛选 tmp.append(str) backTrace(&amp;res,&amp;tmp,chs,i+1,has+1) tmp.removeLast() } } 结果 let ress = solution.restoreIpAddresses(“25525511135”) print(ress) [“255.255.11.135”, “255.255.111.35”] 字符串相乘 示例 输入：num1="123"，num2="456" 输出："56088" num1,num2均不以0开头，除非是数字0本身 思路 第i位和第j位相乘，结果会在第i+j上面，如果有进位，则i+j-1上也有，结果是倒序的 解法 代码实现： func multiply(_ num1: String, _ num2: String) -&gt; String { if Int(num1) == 0 || Int(num2) == 0 {return "0"} var result = "" var resultArray: [Int] = [Int].init(repeatElement(0, count: num1.count+num2.count)) //这两个for执行完，结果数组里面是未处理过进位的结果 for i in (0..&lt;num1.count) { for j in 0..&lt;num2.count { let c1 = Int(String(num1[i]))! let c2 = Int(String(num2[j]))! let res = c1*c2 resultArray[i+j] += res } } //处理进位 var carrys = 0 for i in (0..&lt;resultArray.count).reversed() { if resultArray[i] == 0 { continue } let tmp = resultArray[i]+carrys carrys = tmp/10 resultArray[i] = tmp%10 } //最后一位如果是0，则需要舍弃 let end = resultArray.last!==0 ? resultArray.count-1 : resultArray.count for i in 0..&lt;end { result += String(resultArray[i]) } return result } 测试 print(solution.multiply("123", "3128")) 结果 384744 字符串s1和s2，判断s2中是否包含s1的排列 示例 输入："abo"和"eidboammnj" 输出：true 如果是"abb"则false，字符串都是小写，长度1-10000 思路 采用窗口滑动法，从开始的空窗口从左向右滑动 解法 代码实现： //保证了字符串都是小写字母，97是小写的a，65是大写的A func checkInclusion(_ s1: String, _ s2: String) -&gt; Bool { if s1.isEmpty || s2.isEmpty {return false} guard s1.count &lt;= s2.count else { return false } func allZero(_ counts: [Int]) -&gt; Bool { for i in 0 ..&lt; 26 { if counts[i] != 0 { return false } } return true } let chars1 = Array(s1.unicodeScalars) let chars2 = Array(s2.unicodeScalars) let len1 = chars1.count let len2 = chars2.count var counts = [Int](repeatElement(0, count: 26)) //可以简单理解有两个同时滑动的窗口，都向右滑，上面一个窗口后面会为空 for i in 0 ..&lt; len1 { //s1从右边滑进的+1，从右边滑出的-1 counts[Int(chars1[i].value - 97)] += 1 //s2从右边滑进的-1，从右边滑出的-1 counts[Int(chars2[i].value - 97)] -= 1 } if allZero(counts) {return true} //因为都是s2，所以只看滑进还是滑出 for i in len1 ..&lt; len2 { //从右边滑进，-1 counts[Int(chars2[i].value - 97)] -= 1 //从右边滑出，+1 counts[Int(chars2[i - len1].value - 97)] += 1 if allZero(counts) {return true} } //窗口的大小是短串的长度，必须要这样，否则肯定是false return false } 有一个字符串和一组子字符串，请返回覆盖率最高，单词最多的子字符串列表 示例： 字符串: abcdefg 子字符串: ((ab，0, 1), (cd, 2, 3)，(efg，4, 6), (abc，0，2)，(abcd, 0, 3), (cdef, 2, 5)) 期望: {ab, cd, efg} 分析 最长不重复子串 给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 示例： 输入："adbdeacdmmm" 输出：5 解释：因为无重复的最长子串是"bdeac"或者"eacdm" 分析 首先本体如果使用两层for循环当然可以轻松搞定，但是时间复杂度也是O（n^2），显然不是很满意，所以需要想个法子将复杂度调整到O（n）。 因为是子串，不是子序列，所以肯定是一串连续的字符区域。头设定为start，尾设定为end。那么在仅仅遍历一遍的情况下，start是会不断往后涨的，end就是当前遍历的位置。 1. 如果当前遍历的字符在start后面没有出现过，则接着遍历，start往后移 2. 如果当前遍历的字符已经出现了（这里可以使用hash表记录，key是character，value是index），则说明肯定有字符重复，需要将start移到这个重复字符处，也就是遍历的字符上一次出现的位置的下一个位置（index） 3. 在这个过程中，时刻更新最大长度 解法 代码实现： //code1 extension String { subscript(_ i: Int)-&gt;Character { get {return self[index(startIndex, offsetBy: i)]} } } code1是为了给string添加subscript操作，真正功能代码是： //code2 func lengthOfLongestSubstring(_ s: String) -&gt; (Int, String?) { if s.isEmpty { return (0, nil) } var maxLength = 0 var start = maxLength var retString: String? = " " var hashTable: Dictionary&lt;Character, Int&gt; = [Character:Int]() for i in 0..&lt;s.count { if hashTable.keys.contains(s[i]) &amp;&amp; hashTable[s[i]]! &gt;= start { start = hashTable[s[i]]!+1 } hashTable[s[i]] = i maxLength = max(maxLength, i+1-start) } return (maxLength, retString!) } 当然code2实际上只是输出长度并没有输出子字符串，我们尝试着输出长度和子字符串，其实就是在code2的基础上稍微改一下： //code3 func lengthOfLongestSubstring(_ s: String) -&gt; (Int, String?) { if s.isEmpty { return (0, nil) } var maxLength = 0 var start = maxLength var retString: String? = " " let strArray = Array(s) var hashTable: Dictionary&lt;Character, Int&gt; = [Character:Int]() for i in 0..&lt;s.count { if hashTable.keys.contains(s[i]) &amp;&amp; hashTable[s[i]]! &gt;= start { start = hashTable[s[i]]!+1 } hashTable[s[i]] = i //此处就是获取子串，由于会一直遍历到最后，所以如果有多个相等长度的子串，会停留在最后一个子串，返回 if i+1-start &gt;= maxLength { let subArr = strArray[start..&lt;i+1] let subStr: String = subArr.map{String.init($0)}.joined() retString = subStr } maxLength = max(maxLength, i+1-start) } return (maxLength, retString!) } 示例代码如下: var solution = Solution() var turple1 = solution.lengthOfLongestSubstring("adbdeacdmmm") print(turple1) 以“adbdeacdmmm”为例，则长度为5，子串为：”bdeac”或者”eacdm”，但是由于“eacdm”在后面，所以输出的是“eacdm” 可以看到： 最长公共前缀 编写一个函数来查找字符串数组中的最长公共前缀。 如果不存在公共前缀，返回空字符串”” 示例： 输入：["flower","flow","flight"] 输出："fl" 说明 所有的输入只包含小写字母a-z 解法一 暴力循环法，从题目可知：最长公共前缀的长度一定是字符串数组中长度最短的哪个字符串 首先找出长度最短的字符串str，比如str=”abcf”。 以此对’abcf’,’abc’,’ab’,’a’进行筛选，判断哪个是所有的其他字符串的前缀。 解法二 看下图： 对str[0]按照字符遍历，与其他字符串以此比较对应位置上的字符，并记录查找位置，如果找到不相等或者对应字符串的长度到了限制，就找到了。 代码如下： func longestCommonPrefix(_ strs: [String]) -&gt; String { if strs.count &lt;= 0 { return "" } if strs.count == 1 { return strs[0] } let str = strs[0] for i in 0..&lt;str.count { let c: Character = str[i] for j in 1..&lt;strs.count { if i == strs[j].count || c != strs[j][i] { let rightIndex = strs[0].index(strs[0].startIndex, offsetBy: i) return String(strs[0][strs[0].startIndex..&lt;rightIndex]) } } } return strs[0] } 测试： let strs2: [String] = ["abcdfj", "abc", "abcmnihiuh", "abcmunh"] let str2: String = solution.longestCommonPrefix(strs2) print(str2) 结果： abc]]></summary></entry><entry><title type="html">排序算法</title><link href="http://localhost:4000/algorithm/2022/03/08/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.html" rel="alternate" type="text/html" title="排序算法" /><published>2022-03-08T02:00:00+00:00</published><updated>2022-03-08T02:00:00+00:00</updated><id>http://localhost:4000/algorithm/2022/03/08/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95</id><content type="html" xml:base="http://localhost:4000/algorithm/2022/03/08/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.html"><![CDATA[<p>一些算法举例</p>

<h2 id="排序算法">排序算法</h2>
<p>首先看一张图：</p>

<p><img src="http://localhost:4000/assets/images/posts/sort_algorithm.jpg" alt="sort_algorithm" class="rounded border shadow" /></p>

<p>这里就不多解释了，下面抽几个排序简单讲下。</p>

<p class="success">成功</p>

<p class="info">信息</p>

<p class="warning">Warning Text.</p>

<p class="error">Error Text.</p>

<p><code class="language-plaintext success highlighter-rouge">success</code> <code class="language-plaintext info highlighter-rouge">info</code> <code class="language-plaintext warning highlighter-rouge">warning</code> <code class="language-plaintext error highlighter-rouge">error</code></p>

<h3 id="冒泡排序">冒泡排序</h3>
<ul>
  <li>算法步骤</li>
</ul>

<p>比较相邻的元素。如果第一个比第二个大，就交换他们两个。
对每一对相邻元素作同样的工作，从开始第一队到结尾的最后一对。这步做完后，最后的元素会是最大的数。
针对所有的元素重复以上的步骤，除了最后一个。
持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</p>

<ul>
  <li>动图演示</li>
</ul>

<p><img src="http://localhost:4000/assets/images/posts/bubbleSort.gif" alt="bubbleSort" /></p>

<ul>
  <li>代码实现：</li>
</ul>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">func</span> <span class="nf">bubleSort</span><span class="p">(</span><span class="nv">source</span><span class="p">:</span> <span class="k">inout</span> <span class="p">[</span><span class="kt">Int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"bubleSort before: </span><span class="se">\(</span><span class="n">source</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..&lt;</span><span class="n">source</span><span class="o">.</span><span class="n">count</span> <span class="p">{</span>
        <span class="k">for</span> <span class="n">j</span> <span class="k">in</span> <span class="n">i</span><span class="o">..&lt;</span><span class="n">source</span><span class="o">.</span><span class="n">count</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">source</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">&lt;</span><span class="n">source</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">{</span>
                <span class="n">source</span><span class="o">.</span><span class="nf">swapAt</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="nf">print</span><span class="p">(</span><span class="s">"bubleSort after: </span><span class="se">\(</span><span class="n">source</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">source</span>
<span class="p">}</span>
</code></pre></div></div>

<p>i的循环是计数用，j的循环是当次将最大的数放到最后。</p>

<h3 id="插入排序">插入排序</h3>
<ul>
  <li>算法步骤</li>
</ul>

<p>将第一待排序的第一个元素看过一个有序序列，把第二个元素到最后一个元素当成未排序序列。
从头到位以此扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面）</p>

<ul>
  <li>动图演示</li>
</ul>

<p>由于很好理解就不放动图演示了。</p>

<ul>
  <li>代码实现</li>
</ul>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">func</span> <span class="nf">insertSort</span><span class="p">(</span><span class="nv">arr</span><span class="p">:</span> <span class="k">inout</span> <span class="p">[</span><span class="kt">Int</span><span class="p">])</span> <span class="p">{</span>
        <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">1</span><span class="o">..&lt;</span><span class="n">arr</span><span class="o">.</span><span class="n">endIndex</span> <span class="p">{</span>
            <span class="k">let</span> <span class="nv">temp</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">j</span> <span class="nf">in</span> <span class="p">(</span><span class="mi">0</span><span class="o">..&lt;</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="nf">reversed</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">if</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">temp</span> <span class="p">{</span>
                    <span class="n">arr</span><span class="o">.</span><span class="nf">swapAt</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div></div>

<h3 id="快速排序">快速排序</h3>
<p>平均状况下，排序n个项目要O（nlogn）次比较。在最坏的状况下则需要O（n^2）次比较，但这种状况并不多见。事实上，快排通常明显比其他O（nlogn）算法更快一个，因为它的内部循环可以在大部分的架构上很有效率地被实现出来。
快排使用分治法（Divide and conquer）策略来把一个串行（list）分为两个子串行（sub-lists）。
快速排序本质上是冒泡排序基础上的递归分治法。它是处理大数据排序最快的算法之一了。
《算法艺术与信息学竞赛》上说：</p>
<blockquote>
  <p>快速排序最坏的情况是O（n^2），比如顺序数列额快排。但它的平摊期望时间是O（nlogn），且O（nlogn）记号中隐含的常数因子很小，比复杂度稳定等于O（nlogn）的归并排序要小很多。所以，对绝大多数树顺序性较弱的随机数列而言，快速排序总是优于归并排序。</p>
</blockquote>

<ul>
  <li>算法步骤</li>
</ul>

<ol>
  <li>从数列中挑出一个元素，称为“基准”（pivot）；</li>
  <li>重新排序数列，所有元素比基准值小的摆放在基准面前，所有比基准大的摆在基准后面（相同的可以放到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li>
  <li>递归的（recursive）把小于基准值的元素的子数列和大于基准值元素的子数列排序。</li>
</ol>

<ul>
  <li>动图演示</li>
</ul>

<p><img src="http://localhost:4000/assets/images/posts/quickSort.gif" alt="quickSort" /></p>

<ul>
  <li>代码实现</li>
</ul>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">//寻找pivot的函数</span>
    <span class="kd">func</span> <span class="nf">partition</span><span class="p">(</span><span class="nv">arr</span><span class="p">:</span> <span class="k">inout</span> <span class="p">[</span><span class="kt">Int</span><span class="p">],</span> <span class="nv">left</span><span class="p">:</span> <span class="kt">Int</span><span class="p">,</span> <span class="nv">right</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">pivot</span> <span class="o">=</span> <span class="n">left</span>
        <span class="k">var</span> <span class="nv">index</span> <span class="o">=</span> <span class="n">pivot</span><span class="o">+</span><span class="mi">1</span>
        <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="n">index</span><span class="o">...</span><span class="n">right</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">pivot</span><span class="p">]</span> <span class="p">{</span>
                <span class="n">arr</span><span class="o">.</span><span class="nf">swapAt</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
                <span class="n">index</span><span class="o">+=</span><span class="mi">1</span>
                <span class="c1">//i和index都更新，以pivot为分隔，两边都冒泡，后面再将假设的pivot替换为真正的pivot，然后继续递归</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="c1">//此处相当于pivot需要更新</span>
        <span class="n">arr</span><span class="o">.</span><span class="nf">swapAt</span><span class="p">(</span><span class="n">pivot</span><span class="p">,</span> <span class="n">index</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">index</span><span class="o">-</span><span class="mi">1</span>
    <span class="p">}</span>
    
    <span class="kd">func</span> <span class="nf">quickSort</span><span class="p">(</span><span class="nv">arr</span><span class="p">:</span> <span class="k">inout</span> <span class="p">[</span><span class="kt">Int</span><span class="p">],</span> <span class="nv">left</span><span class="p">:</span> <span class="kt">Int</span><span class="p">,</span> <span class="nv">right</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">arr</span><span class="o">.</span><span class="n">count</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="p">{</span>
            <span class="c1">//nothing, live it alone</span>
        <span class="p">}</span>
        
        <span class="k">let</span> <span class="nv">left</span> <span class="o">=</span> <span class="n">left</span>
        <span class="k">let</span> <span class="nv">right</span> <span class="o">=</span> <span class="n">right</span>
        <span class="k">if</span> <span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span> <span class="p">{</span>
            <span class="k">let</span> <span class="nv">partitionIndex</span> <span class="o">=</span> <span class="nf">partition</span><span class="p">(</span><span class="nv">arr</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">arr</span><span class="p">,</span> <span class="nv">left</span><span class="p">:</span> <span class="n">left</span><span class="p">,</span> <span class="nv">right</span><span class="p">:</span> <span class="n">right</span><span class="p">)</span>
            <span class="nf">quickSort</span><span class="p">(</span><span class="nv">arr</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">arr</span><span class="p">,</span> <span class="nv">left</span><span class="p">:</span> <span class="n">left</span><span class="p">,</span> <span class="nv">right</span><span class="p">:</span> <span class="n">partitionIndex</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="nf">quickSort</span><span class="p">(</span><span class="nv">arr</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">arr</span><span class="p">,</span> <span class="nv">left</span><span class="p">:</span> <span class="n">partitionIndex</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nv">right</span><span class="p">:</span> <span class="n">right</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div></div>]]></content><author><name>Cambria Yang</name><email>cambriayang@qq.com</email></author><category term="Algorithm" /><category term="算法" /><summary type="html"><![CDATA[一些算法举例 排序算法 首先看一张图： 这里就不多解释了，下面抽几个排序简单讲下。 成功 信息 Warning Text. Error Text. success info warning error 冒泡排序 算法步骤 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 对每一对相邻元素作同样的工作，从开始第一队到结尾的最后一对。这步做完后，最后的元素会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 动图演示 代码实现： func bubleSort(source: inout [Int]) -&gt; [Int] { print("bubleSort before: \(source)") for i in 0..&lt;source.count { for j in i..&lt;source.count { if source[j]&lt;source[i] { source.swapAt(i, j) } } } print("bubleSort after: \(source)") return source } i的循环是计数用，j的循环是当次将最大的数放到最后。 插入排序 算法步骤 将第一待排序的第一个元素看过一个有序序列，把第二个元素到最后一个元素当成未排序序列。 从头到位以此扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面） 动图演示 由于很好理解就不放动图演示了。 代码实现 func insertSort(arr: inout [Int]) { for i in 1..&lt;arr.endIndex { let temp = arr[i] for j in (0..&lt;i).reversed() { if arr[j] &gt; temp { arr.swapAt(j, j+1) } } } } 快速排序 平均状况下，排序n个项目要O（nlogn）次比较。在最坏的状况下则需要O（n^2）次比较，但这种状况并不多见。事实上，快排通常明显比其他O（nlogn）算法更快一个，因为它的内部循环可以在大部分的架构上很有效率地被实现出来。 快排使用分治法（Divide and conquer）策略来把一个串行（list）分为两个子串行（sub-lists）。 快速排序本质上是冒泡排序基础上的递归分治法。它是处理大数据排序最快的算法之一了。 《算法艺术与信息学竞赛》上说： 快速排序最坏的情况是O（n^2），比如顺序数列额快排。但它的平摊期望时间是O（nlogn），且O（nlogn）记号中隐含的常数因子很小，比复杂度稳定等于O（nlogn）的归并排序要小很多。所以，对绝大多数树顺序性较弱的随机数列而言，快速排序总是优于归并排序。 算法步骤 从数列中挑出一个元素，称为“基准”（pivot）； 重新排序数列，所有元素比基准值小的摆放在基准面前，所有比基准大的摆在基准后面（相同的可以放到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作； 递归的（recursive）把小于基准值的元素的子数列和大于基准值元素的子数列排序。 动图演示 代码实现 //寻找pivot的函数 func partition(arr: inout [Int], left: Int, right: Int) -&gt; Int { let pivot = left var index = pivot+1 for i in index...right { if arr[i] &lt; arr[pivot] { arr.swapAt(i, index) index+=1 //i和index都更新，以pivot为分隔，两边都冒泡，后面再将假设的pivot替换为真正的pivot，然后继续递归 } } //此处相当于pivot需要更新 arr.swapAt(pivot, index-1) return index-1 } func quickSort(arr: inout [Int], left: Int, right: Int) { if arr.count &lt;= 1 { //nothing, live it alone } let left = left let right = right if left &lt; right { let partitionIndex = partition(arr: &amp;arr, left: left, right: right) quickSort(arr: &amp;arr, left: left, right: partitionIndex-1) quickSort(arr: &amp;arr, left: partitionIndex+1, right: right) } }]]></summary></entry><entry><title type="html">偶来无聊, 拙笔涂鸦几首</title><link href="http://localhost:4000/poetry/2022/02/22/%E9%84%99%E4%BA%BA%E6%8B%99%E7%AC%94%E6%B6%82%E9%B8%A6.html" rel="alternate" type="text/html" title="偶来无聊, 拙笔涂鸦几首" /><published>2022-02-22T02:00:00+00:00</published><updated>2022-02-22T02:00:00+00:00</updated><id>http://localhost:4000/poetry/2022/02/22/%E9%84%99%E4%BA%BA%E6%8B%99%E7%AC%94%E6%B6%82%E9%B8%A6</id><content type="html" xml:base="http://localhost:4000/poetry/2022/02/22/%E9%84%99%E4%BA%BA%E6%8B%99%E7%AC%94%E6%B6%82%E9%B8%A6.html"><![CDATA[<p>此篇博客<em>纯属</em>个人<strong>兴趣爱好</strong>, 突然兴起, 胡乱涂鸦之作, 止增笑耳</p>

<h2 id="灼夏">灼夏</h2>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>灼，夏日，炎炎；
受，东风，徐徐；
漫，杠彴，慢慢；
看，卷云，片片；
回思昨日穿林打叶声，
竹杖芒鞋轻胜马，
管他风雨管他晴。
</code></pre></div></div>

<h2 id="窗外">窗外</h2>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>窗外马路等压，
小桥流水人家，
电脑书桌代码，
妖风阵阵，
BUG何时得挂。
</code></pre></div></div>

<p><img src="http://localhost:4000/assets/images/posts/out.jpeg" alt="out" class="rounded border shadow circle" /></p>

<h2 id="酒翁">酒翁</h2>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>酒自穿肠过，言从口中出;
情在心中留，意比磐石坚;
若卿有踟蹰，便倚胸中听;
绝无二三意，自始终如一。
酒乃前世药，来解今时忧;
无论今前世，不管酒前后；
铮铮铁板书，片字不得改。


人生在世几十载，失了智，又何妨；
离了爹妈断了奶，赢了你，夫何求。
</code></pre></div></div>

<h2 id="以梦为马不负韶华">以梦为马，不负韶华</h2>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>十年望飘影，踟蹰未前行，后母方穷转银河，
断了金盾，知了冷暖，梦已难成，
风雨故人情，一载难稳定，云滇船头倾沧海，
不奢霸气，不舍金戈，不满冠樱，
可堪持觞劝君停，何妨征战且徐行，
刃了戎戍，攘了太清！
</code></pre></div></div>

<p>— <em>没有成绩，呼吸都是错的 ———–DAC BurNing 夺冠（2017-04-05  21：41）</em></p>

<h2 id="无题">无题</h2>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>天高, 风清, 云淡, 鸟空鸣;
水明, 山秀, 民善, 人自行;
蜀道虽难, 有佳人作伴;
古韵犹藏, 引才俊尽赞;
栈道龙眠, 问功业何成.
</code></pre></div></div>

<h2 id="不足惜">不足惜</h2>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>龙腾万里雾,
岂顾尺寸兔.
雨泽天下步,
安敢惜一物.
</code></pre></div></div>

<h2 id="白蛇传">白蛇传</h2>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>缘未到, 情未深, 人未老, 心已死;
却看断桥犹在;
西湖凭栏听雨, 雷锋塔下扫落叶, 金山寺外撑旧伞;
千年修行, 只为与君同船渡, 共枕眠;
月下听蛙鸣, 田间闻潺溪;
天若有情, 便叫那雷锋塔倒, 西湖水干;
续前缘, 延旧情;
塔尖比翼鸟, 湖底连理枝.
</code></pre></div></div>

<h2 id="流星天空">流星·天空</h2>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>夜深了,天黑了.
一道流星耀眼地划过天空.
好美,天空说,
流星笑而不语.
留下来陪我吧,让我平凡的生活增添一道亮丽的风景吧.
天空说,
你应该找月亮!
天空默默无声.
流星对天空说,忘了我吧,我只是个匆匆过客.
天空对流星说,
我怎能忘记你的温度?
</code></pre></div></div>

<h2 id="雨中拙笔涂鸦">雨中拙笔涂鸦</h2>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>凭栏听雨声,倚窗拂清风.
思量前日事,惴惴不敢言.
渐闻雨婆远,佳人何所事.
心中繁杂陈,不可明言壮.
天公倾盆雨,必有彩虹日.
若知西子心,雷锋塔前汀.
便叫雷公停,他日七彩云.
</code></pre></div></div>]]></content><author><name>Cambria Yang</name><email>cambriayang@qq.com</email></author><category term="Poetry" /><category term="Poetry" /><summary type="html"><![CDATA[此篇博客纯属个人兴趣爱好, 突然兴起, 胡乱涂鸦之作, 止增笑耳 灼夏 灼，夏日，炎炎； 受，东风，徐徐； 漫，杠彴，慢慢； 看，卷云，片片； 回思昨日穿林打叶声， 竹杖芒鞋轻胜马， 管他风雨管他晴。 窗外 窗外马路等压， 小桥流水人家， 电脑书桌代码， 妖风阵阵， BUG何时得挂。 酒翁 酒自穿肠过，言从口中出; 情在心中留，意比磐石坚; 若卿有踟蹰，便倚胸中听; 绝无二三意，自始终如一。 酒乃前世药，来解今时忧; 无论今前世，不管酒前后； 铮铮铁板书，片字不得改。 人生在世几十载，失了智，又何妨； 离了爹妈断了奶，赢了你，夫何求。 以梦为马，不负韶华 十年望飘影，踟蹰未前行，后母方穷转银河， 断了金盾，知了冷暖，梦已难成， 风雨故人情，一载难稳定，云滇船头倾沧海， 不奢霸气，不舍金戈，不满冠樱， 可堪持觞劝君停，何妨征战且徐行， 刃了戎戍，攘了太清！ — 没有成绩，呼吸都是错的 ———–DAC BurNing 夺冠（2017-04-05 21：41） 无题 天高, 风清, 云淡, 鸟空鸣; 水明, 山秀, 民善, 人自行; 蜀道虽难, 有佳人作伴; 古韵犹藏, 引才俊尽赞; 栈道龙眠, 问功业何成. 不足惜 龙腾万里雾, 岂顾尺寸兔. 雨泽天下步, 安敢惜一物. 白蛇传 缘未到, 情未深, 人未老, 心已死; 却看断桥犹在; 西湖凭栏听雨, 雷锋塔下扫落叶, 金山寺外撑旧伞; 千年修行, 只为与君同船渡, 共枕眠; 月下听蛙鸣, 田间闻潺溪; 天若有情, 便叫那雷锋塔倒, 西湖水干; 续前缘, 延旧情; 塔尖比翼鸟, 湖底连理枝. 流星·天空 夜深了,天黑了. 一道流星耀眼地划过天空. 好美,天空说, 流星笑而不语. 留下来陪我吧,让我平凡的生活增添一道亮丽的风景吧. 天空说, 你应该找月亮! 天空默默无声. 流星对天空说,忘了我吧,我只是个匆匆过客. 天空对流星说, 我怎能忘记你的温度? 雨中拙笔涂鸦 凭栏听雨声,倚窗拂清风. 思量前日事,惴惴不敢言. 渐闻雨婆远,佳人何所事. 心中繁杂陈,不可明言壮. 天公倾盆雨,必有彩虹日. 若知西子心,雷锋塔前汀. 便叫雷公停,他日七彩云.]]></summary></entry><entry><title type="html">开发过程中的UI差异(flutter版)</title><link href="http://localhost:4000/flutter/2021/03/08/%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84UI%E5%B7%AE%E5%BC%82(flutter%E7%89%88).html" rel="alternate" type="text/html" title="开发过程中的UI差异(flutter版)" /><published>2021-03-08T07:09:00+00:00</published><updated>2021-03-08T07:09:00+00:00</updated><id>http://localhost:4000/flutter/2021/03/08/%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84UI%E5%B7%AE%E5%BC%82(flutter%E7%89%88)</id><content type="html" xml:base="http://localhost:4000/flutter/2021/03/08/%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84UI%E5%B7%AE%E5%BC%82(flutter%E7%89%88).html"><![CDATA[<h2 id="开发过程中的ui差异flutter版">开发过程中的UI差异(flutter版)</h2>

<p>一个App的从无到有一定绕不开UI的还原问题，通常有设计师设计好根据时下主流的机型产出UI稿交于开发人员去还原视觉稿。比如设计稿的规范为：375(width)<em>667(height)。通常开发人员按照设计稿设置的控件（100</em>40）以及字体fontSize：18。但是经常会有设计师来说，怎么Android和iOS上面的表现形式不一样呢？或者怎么oppo上面的字号显得比较大呢？其实，底层逻辑都是由于物理设备到开发语言的映射差异化导致的。</p>

<h3 id="原理介绍">原理介绍</h3>

<h4 id="几个名词">几个名词</h4>

<h5 id="屏幕尺寸">屏幕尺寸</h5>

<p>屏幕尺寸(screen size)，是屏幕的对角线长度，一般讲的大小单位都是英寸。</p>

<h5 id="dpi-dots-per-inch">DPI (dots per inch)</h5>

<p>　　dpi 是（英文Dots Per Inch）（每英寸所打印的点数）的缩写，是打印机、鼠标等设备分辨率的单位。国际上都是计算一平方英寸面积内像素的多少。这是衡量打印机打印精度的主要参数之一，一般来说，该值越大，表明打印机的打印精度越高。如果对于扫描设备，dpi越大，则采样点越高，扫描的图片越清晰。
　　可以理解为像素的密度，即单位面长度上的所打印点的数量。</p>

<h5 id="ppi-pixels-per-inch">PPI (pixels per inch)</h5>

<p>　　PPI (pixels per inch)（每英寸的像素数量）的缩写，也就是像素密度。</p>

<p><strong>PPI=√（X^2+Y^2）/ Z （X：长度像素数；Y：宽度像素数；Z：屏幕大小）</strong></p>

<h5 id="关于像素">关于像素</h5>

<p>像素是计算机设备显示的基本单位，它可以表示图形尺寸的大小。英文名为Pixel，简写为PX。</p>

<p>相同的分辨率，则PPI高的的设备，图片显示起来（物理尺寸）更小。</p>

<p>相同的物理尺寸，PPI低的设配，分辨率低。</p>

<p>简单的来说，图像分辨率(每英寸像素数)和PPI(每英寸点数)两者相互影响。</p>]]></content><author><name>Cambria Yang</name><email>cambriayang@qq.com</email></author><category term="flutter" /><category term="flutter" /><summary type="html"><![CDATA[开发过程中的UI差异(flutter版) 一个App的从无到有一定绕不开UI的还原问题，通常有设计师设计好根据时下主流的机型产出UI稿交于开发人员去还原视觉稿。比如设计稿的规范为：375(width)667(height)。通常开发人员按照设计稿设置的控件（10040）以及字体fontSize：18。但是经常会有设计师来说，怎么Android和iOS上面的表现形式不一样呢？或者怎么oppo上面的字号显得比较大呢？其实，底层逻辑都是由于物理设备到开发语言的映射差异化导致的。 原理介绍 几个名词 屏幕尺寸 屏幕尺寸(screen size)，是屏幕的对角线长度，一般讲的大小单位都是英寸。 DPI (dots per inch) 　　dpi 是（英文Dots Per Inch）（每英寸所打印的点数）的缩写，是打印机、鼠标等设备分辨率的单位。国际上都是计算一平方英寸面积内像素的多少。这是衡量打印机打印精度的主要参数之一，一般来说，该值越大，表明打印机的打印精度越高。如果对于扫描设备，dpi越大，则采样点越高，扫描的图片越清晰。 　　可以理解为像素的密度，即单位面长度上的所打印点的数量。 PPI (pixels per inch) 　　PPI (pixels per inch)（每英寸的像素数量）的缩写，也就是像素密度。 PPI=√（X^2+Y^2）/ Z （X：长度像素数；Y：宽度像素数；Z：屏幕大小） 关于像素 像素是计算机设备显示的基本单位，它可以表示图形尺寸的大小。英文名为Pixel，简写为PX。 相同的分辨率，则PPI高的的设备，图片显示起来（物理尺寸）更小。 相同的物理尺寸，PPI低的设配，分辨率低。 简单的来说，图像分辨率(每英寸像素数)和PPI(每英寸点数)两者相互影响。]]></summary></entry><entry><title type="html">flutter开发初探</title><link href="http://localhost:4000/flutter/2021/01/14/flutter%E5%BC%80%E5%8F%91%E5%88%9D%E6%8E%A2.html" rel="alternate" type="text/html" title="flutter开发初探" /><published>2021-01-14T08:00:00+00:00</published><updated>2021-01-14T08:00:00+00:00</updated><id>http://localhost:4000/flutter/2021/01/14/flutter%E5%BC%80%E5%8F%91%E5%88%9D%E6%8E%A2</id><content type="html" xml:base="http://localhost:4000/flutter/2021/01/14/flutter%E5%BC%80%E5%8F%91%E5%88%9D%E6%8E%A2.html"><![CDATA[<h2 id="flutter开发初探">flutter开发初探</h2>

<p><strong>作为时下最火的跨端技术，虽然现在才能才入局有点晚的感觉，但是本人是喜欢稳定版的，目前1.22.x也已经官方release了，这篇初探就简单记录下，一枚小白的使用心得和入门吧</strong></p>

<h2 id="国际惯例">国际惯例</h2>

<p><img src="http://localhost:4000/assets/images/posts/flutter_arch.jpg" alt="flutter_arch" /></p>

<p>摆出这张图，还是简单从整体上来先认识了一下什么是 Flutter，否则容易陷入“盲人摸象”的境地。</p>

<ul>
  <li><strong>Embedder</strong> 操作系统适配层，提供线程模型，事件循环模型</li>
  <li><strong>Engine</strong>：和底层OS无关了，一般是渲染层包括了 Skia 图形绘制库、Dart VM、Text 等，其中 Skia 和 Text 为上层接口提供了调用底层渲染和排版的能力</li>
  <li><strong>Framework</strong>：是一个用 Dart 实现的 UI SDK，从上之下包括了两大风格组件库（iOS和Android）、基础组件库、图形绘制、手势识别、动画等功能</li>
</ul>

<h2 id="flutter绘制">Flutter绘制</h2>

<p>首先是用户操作，触发 Widget Tree 的更新，然后构建 Element Tree，计算重绘区后将信息同步给 RenderObject Tree，之后实现组件布局、组件绘制、图层合成、引擎渲染。</p>

<p>渲染过程中有3棵树比较重要：</p>

<p><em>Widget Tree</em>, <em>Element Tree</em>, <em>RenderObject Tree</em></p>

<h3 id="widget-tree">Widget Tree</h3>

<p>基本逻辑单位，是用户对界面 UI 的描述方式。其实<strong>Widget是不可变的</strong>，只是通过重绘来更新<code class="language-plaintext highlighter-rouge">state </code></p>

<h3 id="element-tree">Element Tree</h3>

<p>它是 Widget 的实例化对象，<code class="language-plaintext highlighter-rouge">createElement</code> 工厂方法来创建Element。</p>

<p>Element Tree 的重新创建和重新渲染的开销会非常大， 所以 Element Tree 到 RenderObject Tree 也有一个 Diff 环节，来计算最小重绘区域。</p>

<p>需要注意的是，Element 同时持有 Widget 和 RenderObject， 但无论是 Widget 还是 Element，其实都不负责最后的渲染，它们只是“发号施令”，真正对配置信息进行渲染的是 RenderObject。</p>

<h3 id="renderobject-tree">RenderObject Tree</h3>

<p>RenderObject Tree 在 Flutter 的展示过程分为四个阶段：</p>

<ol>
  <li>布局</li>
  <li>绘制</li>
  <li>合成</li>
  <li>渲染</li>
</ol>

<p>其中，布局和绘制在 RenderObject 中完成，Flutter 采用深度优先机制遍历渲染对象树，确定树中各个对象的位置和尺寸，并把它们绘制到不同的图层上。绘制完毕后，合成和渲染的工作则交给 Skia 处理。</p>

<p>理论上可以直接让Widget和RenderObject通信，不过因为Widget设计为不可变的，但是最终在屏幕上的object不可能一直不变。如果每次改变都去全局渲染object，会损耗大量性能。所以Element实际上是对Widget做了抽象，只将变化的部分通知Render层，由此最大程度去降低重绘区域，提高渲染效率。</p>

<h3 id="flutter绘制流程拆解">Flutter绘制流程拆解</h3>

<ol>
  <li>Build</li>
  <li>Diff</li>
  <li>Layout</li>
  <li>Paint</li>
  <li>Composite</li>
  <li>Render</li>
</ol>

<h3 id="自绘引擎">自绘引擎</h3>

<ol>
  <li>通过Skia直接调用OpenGL渲染，保证性能同时抹平差异。</li>
  <li>Dart同时支持JIT和AOT。</li>
</ol>

<h2 id="flutter混合开发">Flutter混合开发</h2>

<h3 id="混合模式">混合模式</h3>

<ol>
  <li>
    <p>统一管理模式</p>

    <p>所谓统一管理模式，就是一个标准的 Flutter Application 工程，而其中 Flutter 的产物工程目录（ <code class="language-plaintext highlighter-rouge">ios/</code> 和 <code class="language-plaintext highlighter-rouge">android/</code> ）是可以进行原生混编的工程，如 React Native 进行混合开发那般，在工程项目中进行混合开发就好。但是这样的缺点是当原生项目业务庞大起来时，Flutter 工程对于原生工程的耦合就会非常严重，当工程进行升级时会比较麻烦。因此这种混合模式只适用于 Flutter 业务主导、原生功能为辅的项目。</p>
  </li>
  <li>
    <p>三端分离模式</p>

    <p>后来 Google 对混合开发有了更好的支持，除了 Flutter Application，还支持 Flutter Module。所谓 Flutter Module，恰如其名，就是支持以模块化的方式将 Flutter 引入原生工程中， 它的产物就是 iOS 下的 Framework 或 Pods、Android 下的 AAR，原生工程就像引入其他第三方 SDK 那样，使用 Maven 和 Cocoapods 引入 Flutter Module 即可。 从而实现真正意义上的三端分离的开发模式。</p>
  </li>
</ol>

<h3 id="混合栈原理">混合栈原理</h3>

<p>混合导航栈主要需要解决以下四种场景下的问题：</p>

<ul>
  <li>
    <p>Native 2 Native</p>

    <p>这种情况比较简单，Flutter Engine 已经为我们提供了现成的 Plugin，即 iOS 下的 FlutterViewController 与 Android 下的 FlutterView（自行包装一下可以实现 FlutterActivity），所以这种场景我们直接使用启动了的 Flutter Engine 来初始化 Flutter 容器，为其设置初始路由页面之后，就可以以原生的方式跳转至 Flutter 页面了。</p>
  </li>
  <li>
    <p>Flutter 2 Flutter</p>

    <ul>
      <li>使用 Flutter 本身的 Navigator 导航栈</li>
      <li>创建新的 Flutter 容器后，使用原生导航栈</li>
    </ul>
  </li>
  <li>
    <p>Flutter 2 Native</p>

    <p>这里的跳转其实是包含了两种情况，一是打开原生页面（open，包括但不限于 push），二是回退到原生页面（close，包括但不限于 pop）。</p>
  </li>
  <li>
    <p>Native 2 Native</p>
  </li>
</ul>]]></content><author><name>Cambria Yang</name><email>cambriayang@qq.com</email></author><category term="flutter" /><category term="flutter" /><summary type="html"><![CDATA[flutter开发初探 作为时下最火的跨端技术，虽然现在才能才入局有点晚的感觉，但是本人是喜欢稳定版的，目前1.22.x也已经官方release了，这篇初探就简单记录下，一枚小白的使用心得和入门吧 国际惯例 摆出这张图，还是简单从整体上来先认识了一下什么是 Flutter，否则容易陷入“盲人摸象”的境地。 Embedder 操作系统适配层，提供线程模型，事件循环模型 Engine：和底层OS无关了，一般是渲染层包括了 Skia 图形绘制库、Dart VM、Text 等，其中 Skia 和 Text 为上层接口提供了调用底层渲染和排版的能力 Framework：是一个用 Dart 实现的 UI SDK，从上之下包括了两大风格组件库（iOS和Android）、基础组件库、图形绘制、手势识别、动画等功能 Flutter绘制 首先是用户操作，触发 Widget Tree 的更新，然后构建 Element Tree，计算重绘区后将信息同步给 RenderObject Tree，之后实现组件布局、组件绘制、图层合成、引擎渲染。 渲染过程中有3棵树比较重要： Widget Tree, Element Tree, RenderObject Tree Widget Tree 基本逻辑单位，是用户对界面 UI 的描述方式。其实Widget是不可变的，只是通过重绘来更新state Element Tree 它是 Widget 的实例化对象，createElement 工厂方法来创建Element。 Element Tree 的重新创建和重新渲染的开销会非常大， 所以 Element Tree 到 RenderObject Tree 也有一个 Diff 环节，来计算最小重绘区域。 需要注意的是，Element 同时持有 Widget 和 RenderObject， 但无论是 Widget 还是 Element，其实都不负责最后的渲染，它们只是“发号施令”，真正对配置信息进行渲染的是 RenderObject。 RenderObject Tree RenderObject Tree 在 Flutter 的展示过程分为四个阶段： 布局 绘制 合成 渲染 其中，布局和绘制在 RenderObject 中完成，Flutter 采用深度优先机制遍历渲染对象树，确定树中各个对象的位置和尺寸，并把它们绘制到不同的图层上。绘制完毕后，合成和渲染的工作则交给 Skia 处理。 理论上可以直接让Widget和RenderObject通信，不过因为Widget设计为不可变的，但是最终在屏幕上的object不可能一直不变。如果每次改变都去全局渲染object，会损耗大量性能。所以Element实际上是对Widget做了抽象，只将变化的部分通知Render层，由此最大程度去降低重绘区域，提高渲染效率。 Flutter绘制流程拆解 Build Diff Layout Paint Composite Render 自绘引擎 通过Skia直接调用OpenGL渲染，保证性能同时抹平差异。 Dart同时支持JIT和AOT。 Flutter混合开发 混合模式 统一管理模式 所谓统一管理模式，就是一个标准的 Flutter Application 工程，而其中 Flutter 的产物工程目录（ ios/ 和 android/ ）是可以进行原生混编的工程，如 React Native 进行混合开发那般，在工程项目中进行混合开发就好。但是这样的缺点是当原生项目业务庞大起来时，Flutter 工程对于原生工程的耦合就会非常严重，当工程进行升级时会比较麻烦。因此这种混合模式只适用于 Flutter 业务主导、原生功能为辅的项目。 三端分离模式 后来 Google 对混合开发有了更好的支持，除了 Flutter Application，还支持 Flutter Module。所谓 Flutter Module，恰如其名，就是支持以模块化的方式将 Flutter 引入原生工程中， 它的产物就是 iOS 下的 Framework 或 Pods、Android 下的 AAR，原生工程就像引入其他第三方 SDK 那样，使用 Maven 和 Cocoapods 引入 Flutter Module 即可。 从而实现真正意义上的三端分离的开发模式。 混合栈原理 混合导航栈主要需要解决以下四种场景下的问题： Native 2 Native 这种情况比较简单，Flutter Engine 已经为我们提供了现成的 Plugin，即 iOS 下的 FlutterViewController 与 Android 下的 FlutterView（自行包装一下可以实现 FlutterActivity），所以这种场景我们直接使用启动了的 Flutter Engine 来初始化 Flutter 容器，为其设置初始路由页面之后，就可以以原生的方式跳转至 Flutter 页面了。 Flutter 2 Flutter 使用 Flutter 本身的 Navigator 导航栈 创建新的 Flutter 容器后，使用原生导航栈 Flutter 2 Native 这里的跳转其实是包含了两种情况，一是打开原生页面（open，包括但不限于 push），二是回退到原生页面（close，包括但不限于 pop）。 Native 2 Native]]></summary></entry><entry><title type="html">一些相关知识点</title><link href="http://localhost:4000/interview/2020/08/18/%E4%B8%80%E4%BA%9B%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9.html" rel="alternate" type="text/html" title="一些相关知识点" /><published>2020-08-18T07:39:00+00:00</published><updated>2020-08-18T07:39:00+00:00</updated><id>http://localhost:4000/interview/2020/08/18/%E4%B8%80%E4%BA%9B%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9</id><content type="html" xml:base="http://localhost:4000/interview/2020/08/18/%E4%B8%80%E4%BA%9B%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9.html"><![CDATA[<h2 id="对称加密">对称加密</h2>

<h3 id="定义">定义</h3>

<p class="success">对称加密是指加密和解密的密匙为同一个，用来加密数据的密匙也可以用来解密</p>

<h3 id="特点">特点</h3>

<ul>
  <li>加密速度快，使用简单</li>
  <li>对称加密的破解难度是随着钥匙的大小增加而增加的，钥匙越大就越难破解，但是钥匙越大相应的解密的时间也会越长</li>
</ul>

<h3 id="对称加密的问题">对称加密的问题</h3>

<ol>
  <li>双方都必须先约定好加密规则</li>
  <li>秘钥数目难于管理。因为对于每一个合作者都需要使用不同的秘钥，很难适应开放互联网中的大量的合作者交流。</li>
  <li>无法适用于陌生的网络的环境，双方都必须是可信任的才可进行。</li>
</ol>

<h2 id="非对称加密">非对称加密</h2>

<h3 id="定义-1">定义</h3>

<p class="info">非对称加密的秘钥是成对的（公钥和私钥）。私钥由自己安全保管不外泄，而公钥则可以发给网络中的任何人。</p>

<p>非对称加密适用这对秘钥中的一个进行加密，而解密则需要另一个秘钥。根据公钥是无法推导出私钥的。</p>

<h3 id="特点-1">特点</h3>

<ol>
  <li>比对称加密安全：使用不同的钥匙，非对称加密的私钥是由自己保管，不会外泄的。</li>
  <li>更方便，可扩展：公钥可以在公布在网络中，任何人都可以拿着公钥和你进行通信，而对称加密密钥是不可能公布在网络中的，只能通过私下约定密钥规则。</li>
</ol>

<h3 id="非对称加密的问题">非对称加密的问题</h3>

<p>虽然非对称加密很安全，但是和对称加密比起来，它的解密速度非常慢，所以通常会用混合加密的方式进行通信，混合加密是用非对称加密的方式交换双方的对称加密密钥，交换对称加密密钥之后再用对称加密的方式进行通信。</p>

<h2 id="数字签名">数字签名</h2>

<h3 id="信息被篡改的风险">信息被篡改的风险</h3>

<p>对称加密和非对称加密已经解决了信息传输中的安全问题了，进过加密的数据黑客截取了也无法解密。但是还有一个问题，虽然黑客无法解密通信的内容，但是黑客可以篡改数据双方的通信数据，那么这种情况下我们如何识别数据经过网络传输之后是否被别人篡改过呢？数字签名</p>

<ol>
  <li>首先把需要发送的信息进行哈希得到信息摘要</li>
  <li>然后对信息内容和摘要进行签名得到数字签名</li>
  <li>然后用对称加密密钥把信息内容和数字签名进行对称加密</li>
  <li>最后再把对称加密的秘钥进行加密</li>
</ol>

<h3 id="数字证书">数字证书</h3>

<h4 id="身份确认证的问题">身份确认证的问题</h4>

<p>数字签名解决了信息可能会被篡改的问题，但是还有另外一个问题就是如何确定当前给我发信息的人就是A呢？黑客也可以伪装成A的身份然后把A的公钥替换成自己的公钥，这样B就无法分辨出来了。</p>

<p>这样就衍生了一个身份认证的问题，显然这个身份证明不能由当事人自己发出来，只能由一个大家都信任的公开机构（CA）来发行证书，大家先要到CA去申请一个数字证书（证书信息包括发布机构，所属人，公钥，过期时间等信息）</p>

<p>通信流程如下：</p>

<ol>
  <li>A首先去CA申请一个数字证书</li>
  <li>A把信息加密后+加上签名的数字证书发送给B</li>
  <li>B收到A的信息后，拿着A传过来的数字证书到CA去验证</li>
  <li>如果查询到对应的数字证书里的所属人的确为A，那么身份真实，可以通讯</li>
  <li>然后B根据数字证书信息生成一个专属于A和B的加密方式（这里为对称加密），两个人通过此加密方式进行通讯</li>
</ol>

<h2 id="https">HTTPS</h2>

<h3 id="不足">不足</h3>

<ol>
  <li>不能验证身份，可能被伪装</li>
  <li>明文通信，数据可能被窃取</li>
  <li>无法验证报文的完整性，内容可能被篡改</li>
</ol>

<h3 id="ssltsl协议的解决方案">SSL/TSL协议的解决方案</h3>

<p>通常的https是http+ssl或者http+tsl，ssl主要针对http存在的三个问题逐一实现了对应的解决方案</p>

<h3 id="通信加密解决数据被窃取问题">通信加密（解决数据被窃取问题）</h3>

<p>ssl采用了<strong>混合加密</strong>（同时使用非对称加密和对称加密）的方式建立起安全的http通信，经过加密后的内容即是被窃听了，窃听的人也无法解密对应的数据。</p>

<h3 id="数字证书解决身份伪装问题">数字证书（解决身份伪装问题）</h3>

<h3 id="数字签名解决数据篡改问题">数字签名（解决数据篡改问题）</h3>

<p>数字签名主要有两个作用，一是验证数据是否为意料中的对象所发出的，二是对数据的完整性进行验证，验证数据是否被篡改过。</p>

<h3 id="https通信流程">https通信流程</h3>

<p>https通信主要包括几个节点，发起请求，验证身份，协商秘钥，加密会话，具体流程如下（此例子只有客户端对服务端的单向验证）：</p>

<ol>
  <li>客户端向服务端发起，建立https请求。</li>
  <li>服务器向客户端发送数字证书。</li>
  <li>客户端验证数字证书，证书验证通过后客户端生成会话密钥（双向验证则此处客户端也会向服务器发送证书）。</li>
  <li>服务器生成会话密钥（双向验证此处服务端也会对客户端的证书验证）。</li>
  <li>客户端与服务端开始进行加密会话。</li>
</ol>

<ul>
  <li>客户端向服务器发起请求
    <ul>
      <li>客户端生成随机r1发送给服务端</li>
      <li>告诉服务端自己支持哪些加密算法</li>
    </ul>
  </li>
  <li>服务器向客户端发送数字证书
    <ul>
      <li>服务端生成随机数r2</li>
      <li>从客户端支持的加密算法中选择一种双方都支持的加密算法（此算法用于后面的会话密钥生成）</li>
      <li>服务端生成把证书，随机数r2，会话密钥生成算法，一同发给客户端</li>
    </ul>
  </li>
  <li>客户端验证数字证书
    <ul>
      <li>验证证书的可靠性</li>
      <li>验证证书合法性，包括证书是否吊销，是否到期，域名是否匹配等等</li>
      <li>获得证书的公钥，会话密钥生成算法，随机数r2</li>
      <li>生成一个随机数r3</li>
      <li>根据会话密钥算法使用r1，r2，r3生成会话密钥</li>
      <li>用服务端证书的公钥加密随机数r3并发送给服务端</li>
    </ul>
  </li>
  <li>服务器得到会话密钥
    <ul>
      <li>服务器用私钥解密客户端发过来的r3</li>
      <li>根据会话密钥算法使用r1，r2，r3生成会话密钥</li>
    </ul>
  </li>
  <li>客户端与服务器进行加密会话</li>
</ul>]]></content><author><name>Cambria Yang</name><email>cambriayang@qq.com</email></author><category term="Interview" /><category term="面试" /><summary type="html"><![CDATA[对称加密 定义 对称加密是指加密和解密的密匙为同一个，用来加密数据的密匙也可以用来解密 特点 加密速度快，使用简单 对称加密的破解难度是随着钥匙的大小增加而增加的，钥匙越大就越难破解，但是钥匙越大相应的解密的时间也会越长 对称加密的问题 双方都必须先约定好加密规则 秘钥数目难于管理。因为对于每一个合作者都需要使用不同的秘钥，很难适应开放互联网中的大量的合作者交流。 无法适用于陌生的网络的环境，双方都必须是可信任的才可进行。 非对称加密 定义 非对称加密的秘钥是成对的（公钥和私钥）。私钥由自己安全保管不外泄，而公钥则可以发给网络中的任何人。 非对称加密适用这对秘钥中的一个进行加密，而解密则需要另一个秘钥。根据公钥是无法推导出私钥的。 特点 比对称加密安全：使用不同的钥匙，非对称加密的私钥是由自己保管，不会外泄的。 更方便，可扩展：公钥可以在公布在网络中，任何人都可以拿着公钥和你进行通信，而对称加密密钥是不可能公布在网络中的，只能通过私下约定密钥规则。 非对称加密的问题 虽然非对称加密很安全，但是和对称加密比起来，它的解密速度非常慢，所以通常会用混合加密的方式进行通信，混合加密是用非对称加密的方式交换双方的对称加密密钥，交换对称加密密钥之后再用对称加密的方式进行通信。 数字签名 信息被篡改的风险 对称加密和非对称加密已经解决了信息传输中的安全问题了，进过加密的数据黑客截取了也无法解密。但是还有一个问题，虽然黑客无法解密通信的内容，但是黑客可以篡改数据双方的通信数据，那么这种情况下我们如何识别数据经过网络传输之后是否被别人篡改过呢？数字签名 首先把需要发送的信息进行哈希得到信息摘要 然后对信息内容和摘要进行签名得到数字签名 然后用对称加密密钥把信息内容和数字签名进行对称加密 最后再把对称加密的秘钥进行加密 数字证书 身份确认证的问题 数字签名解决了信息可能会被篡改的问题，但是还有另外一个问题就是如何确定当前给我发信息的人就是A呢？黑客也可以伪装成A的身份然后把A的公钥替换成自己的公钥，这样B就无法分辨出来了。 这样就衍生了一个身份认证的问题，显然这个身份证明不能由当事人自己发出来，只能由一个大家都信任的公开机构（CA）来发行证书，大家先要到CA去申请一个数字证书（证书信息包括发布机构，所属人，公钥，过期时间等信息） 通信流程如下： A首先去CA申请一个数字证书 A把信息加密后+加上签名的数字证书发送给B B收到A的信息后，拿着A传过来的数字证书到CA去验证 如果查询到对应的数字证书里的所属人的确为A，那么身份真实，可以通讯 然后B根据数字证书信息生成一个专属于A和B的加密方式（这里为对称加密），两个人通过此加密方式进行通讯 HTTPS 不足 不能验证身份，可能被伪装 明文通信，数据可能被窃取 无法验证报文的完整性，内容可能被篡改 SSL/TSL协议的解决方案 通常的https是http+ssl或者http+tsl，ssl主要针对http存在的三个问题逐一实现了对应的解决方案 通信加密（解决数据被窃取问题） ssl采用了混合加密（同时使用非对称加密和对称加密）的方式建立起安全的http通信，经过加密后的内容即是被窃听了，窃听的人也无法解密对应的数据。 数字证书（解决身份伪装问题） 数字签名（解决数据篡改问题） 数字签名主要有两个作用，一是验证数据是否为意料中的对象所发出的，二是对数据的完整性进行验证，验证数据是否被篡改过。 https通信流程 https通信主要包括几个节点，发起请求，验证身份，协商秘钥，加密会话，具体流程如下（此例子只有客户端对服务端的单向验证）： 客户端向服务端发起，建立https请求。 服务器向客户端发送数字证书。 客户端验证数字证书，证书验证通过后客户端生成会话密钥（双向验证则此处客户端也会向服务器发送证书）。 服务器生成会话密钥（双向验证此处服务端也会对客户端的证书验证）。 客户端与服务端开始进行加密会话。 客户端向服务器发起请求 客户端生成随机r1发送给服务端 告诉服务端自己支持哪些加密算法 服务器向客户端发送数字证书 服务端生成随机数r2 从客户端支持的加密算法中选择一种双方都支持的加密算法（此算法用于后面的会话密钥生成） 服务端生成把证书，随机数r2，会话密钥生成算法，一同发给客户端 客户端验证数字证书 验证证书的可靠性 验证证书合法性，包括证书是否吊销，是否到期，域名是否匹配等等 获得证书的公钥，会话密钥生成算法，随机数r2 生成一个随机数r3 根据会话密钥算法使用r1，r2，r3生成会话密钥 用服务端证书的公钥加密随机数r3并发送给服务端 服务器得到会话密钥 服务器用私钥解密客户端发过来的r3 根据会话密钥算法使用r1，r2，r3生成会话密钥 客户端与服务器进行加密会话]]></summary></entry></feed>