<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="zh-Hans"><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" hreflang="zh-Hans" /><updated>2022-05-02T04:09:01+00:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Argost’s Home</title><subtitle>My personal Blog Site
</subtitle><author><name>Cambria Yang</name><email>cambriayang@qq.com</email></author><entry><title type="html">偶来无聊, 拙笔涂鸦几首</title><link href="http://localhost:4000/poetry/2022/05/01/%E9%84%99%E4%BA%BA%E6%8B%99%E7%AC%94%E6%B6%82%E9%B8%A6.html" rel="alternate" type="text/html" title="偶来无聊, 拙笔涂鸦几首" /><published>2022-05-01T02:00:00+00:00</published><updated>2022-05-01T02:00:00+00:00</updated><id>http://localhost:4000/poetry/2022/05/01/%E9%84%99%E4%BA%BA%E6%8B%99%E7%AC%94%E6%B6%82%E9%B8%A6</id><content type="html" xml:base="http://localhost:4000/poetry/2022/05/01/%E9%84%99%E4%BA%BA%E6%8B%99%E7%AC%94%E6%B6%82%E9%B8%A6.html"><![CDATA[<p>此篇博客<em>纯属</em>个人<strong>兴趣爱好</strong>, 突然兴起, 胡乱涂鸦之作, 止增笑耳</p>

<h2 id="灼夏">灼夏</h2>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>灼，夏日，炎炎；
受，东风，徐徐；
漫，杠彴，慢慢；
看，卷云，片片；
回思昨日穿林打叶声，
竹杖芒鞋轻胜马，
管他风雨管他晴。
</code></pre></div></div>

<h2 id="窗外">窗外</h2>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>窗外马路等压，
小桥流水人家，
电脑书桌代码，
妖风阵阵，
BUG何时得挂。
</code></pre></div></div>

<p><img src="http://localhost:4000/assets/images/posts/out.jpeg" alt="out" class="rounded border shadow circle" /></p>

<h2 id="酒翁">酒翁</h2>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>酒自穿肠过，言从口中出;
情在心中留，意比磐石坚;
若卿有踟蹰，便倚胸中听;
绝无二三意，自始终如一。
酒乃前世药，来解今时忧;
无论今前世，不管酒前后；
铮铮铁板书，片字不得改。


人生在世几十载，失了智，又何妨；
离了爹妈断了奶，赢了你，夫何求。
</code></pre></div></div>

<h2 id="以梦为马不负韶华">以梦为马，不负韶华</h2>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>十年望飘影，踟蹰未前行，后母方穷转银河，
断了金盾，知了冷暖，梦已难成，
风雨故人情，一载难稳定，云滇船头倾沧海，
不奢霸气，不舍金戈，不满冠樱，
可堪持觞劝君停，何妨征战且徐行，
刃了戎戍，攘了太清！
</code></pre></div></div>

<p>— <em>没有成绩，呼吸都是错的 ———–DAC BurNing 夺冠（2017-04-05  21：41）</em></p>

<h2 id="无题">无题</h2>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>天高, 风清, 云淡, 鸟空鸣;
水明, 山秀, 民善, 人自行;
蜀道虽难, 有佳人作伴;
古韵犹藏, 引才俊尽赞;
栈道龙眠, 问功业何成.
</code></pre></div></div>

<h2 id="不足惜">不足惜</h2>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>龙腾万里雾,
岂顾尺寸兔.
雨泽天下步,
安敢惜一物.
</code></pre></div></div>

<h2 id="白蛇传">白蛇传</h2>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>缘未到, 情未深, 人未老, 心已死;
却看断桥犹在;
西湖凭栏听雨, 雷锋塔下扫落叶, 金山寺外撑旧伞;
千年修行, 只为与君同船渡, 共枕眠;
月下听蛙鸣, 田间闻潺溪;
天若有情, 便叫那雷锋塔倒, 西湖水干;
续前缘, 延旧情;
塔尖比翼鸟, 湖底连理枝.
</code></pre></div></div>

<h2 id="流星天空">流星·天空</h2>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>夜深了,天黑了.
一道流星耀眼地划过天空.
好美,天空说,
流星笑而不语.
留下来陪我吧,让我平凡的生活增添一道亮丽的风景吧.
天空说,
你应该找月亮!
天空默默无声.
流星对天空说,忘了我吧,我只是个匆匆过客.
天空对流星说,
我怎能忘记你的温度?
</code></pre></div></div>

<h2 id="雨中拙笔涂鸦">雨中拙笔涂鸦</h2>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>凭栏听雨声,倚窗拂清风.
思量前日事,惴惴不敢言.
渐闻雨婆远,佳人何所事.
心中繁杂陈,不可明言壮.
天公倾盆雨,必有彩虹日.
若知西子心,雷锋塔前汀.
便叫雷公停,他日七彩云.
</code></pre></div></div>]]></content><author><name>Cambria Yang</name><email>cambriayang@qq.com</email></author><category term="Poetry" /><category term="Poetry" /><summary type="html"><![CDATA[此篇博客纯属个人兴趣爱好, 突然兴起, 胡乱涂鸦之作, 止增笑耳 灼夏 灼，夏日，炎炎； 受，东风，徐徐； 漫，杠彴，慢慢； 看，卷云，片片； 回思昨日穿林打叶声， 竹杖芒鞋轻胜马， 管他风雨管他晴。 窗外 窗外马路等压， 小桥流水人家， 电脑书桌代码， 妖风阵阵， BUG何时得挂。 酒翁 酒自穿肠过，言从口中出; 情在心中留，意比磐石坚; 若卿有踟蹰，便倚胸中听; 绝无二三意，自始终如一。 酒乃前世药，来解今时忧; 无论今前世，不管酒前后； 铮铮铁板书，片字不得改。 人生在世几十载，失了智，又何妨； 离了爹妈断了奶，赢了你，夫何求。 以梦为马，不负韶华 十年望飘影，踟蹰未前行，后母方穷转银河， 断了金盾，知了冷暖，梦已难成， 风雨故人情，一载难稳定，云滇船头倾沧海， 不奢霸气，不舍金戈，不满冠樱， 可堪持觞劝君停，何妨征战且徐行， 刃了戎戍，攘了太清！ — 没有成绩，呼吸都是错的 ———–DAC BurNing 夺冠（2017-04-05 21：41） 无题 天高, 风清, 云淡, 鸟空鸣; 水明, 山秀, 民善, 人自行; 蜀道虽难, 有佳人作伴; 古韵犹藏, 引才俊尽赞; 栈道龙眠, 问功业何成. 不足惜 龙腾万里雾, 岂顾尺寸兔. 雨泽天下步, 安敢惜一物. 白蛇传 缘未到, 情未深, 人未老, 心已死; 却看断桥犹在; 西湖凭栏听雨, 雷锋塔下扫落叶, 金山寺外撑旧伞; 千年修行, 只为与君同船渡, 共枕眠; 月下听蛙鸣, 田间闻潺溪; 天若有情, 便叫那雷锋塔倒, 西湖水干; 续前缘, 延旧情; 塔尖比翼鸟, 湖底连理枝. 流星·天空 夜深了,天黑了. 一道流星耀眼地划过天空. 好美,天空说, 流星笑而不语. 留下来陪我吧,让我平凡的生活增添一道亮丽的风景吧. 天空说, 你应该找月亮! 天空默默无声. 流星对天空说,忘了我吧,我只是个匆匆过客. 天空对流星说, 我怎能忘记你的温度? 雨中拙笔涂鸦 凭栏听雨声,倚窗拂清风. 思量前日事,惴惴不敢言. 渐闻雨婆远,佳人何所事. 心中繁杂陈,不可明言壮. 天公倾盆雨,必有彩虹日. 若知西子心,雷锋塔前汀. 便叫雷公停,他日七彩云.]]></summary></entry><entry><title type="html">动态规划</title><link href="http://localhost:4000/algorithm/2022/04/30/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.html" rel="alternate" type="text/html" title="动态规划" /><published>2022-04-30T07:00:00+00:00</published><updated>2022-04-30T07:00:00+00:00</updated><id>http://localhost:4000/algorithm/2022/04/30/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92</id><content type="html" xml:base="http://localhost:4000/algorithm/2022/04/30/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.html"><![CDATA[<p>一些算法举例</p>

<h2 id="动态规划">动态规划</h2>

<h3 id="买卖股票的最佳时机">买卖股票的最佳时机</h3>

<p>给定一个数组，它的第i个元素是一支给定股票第i天的价格。</p>

<p>如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。</p>

<p><strong>注意</strong>： 你不能再买入股票前卖出股票。</p>

<ul>
  <li>示例</li>
</ul>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code>输入：[7,1,5,3,6,4]
输出： 5
解释： 在第2天（股票价格=1）的时候买入，在第5天（=6），最大利润=6-1=5.注意利润不可能是7-1

输入： [7,6,4,3,1]
输出： 0
解释： 在这种情况下，没有交易完成，所以利润为0.
</code></pre></div></div>

<ul>
  <li>思路</li>
</ul>

<p>需要找到最小的谷之后的最大的峰。 我们可以维持两个变量——minprice 和 maxprofit，它们分别对应迄今为止所得到的最小的谷值和最大的利润（卖出价格与最低价格之间的最大差值）。</p>

<ul>
  <li>解法</li>
</ul>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">maxProfit</span><span class="p">(</span><span class="n">_</span> <span class="nv">prices</span><span class="p">:</span> <span class="p">[</span><span class="kt">Int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="p">{</span>
  <span class="k">var</span> <span class="nv">minPrice</span> <span class="o">=</span> <span class="kt">Int</span><span class="o">.</span><span class="n">max</span>
  <span class="k">var</span> <span class="nv">maxProfit</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..&lt;</span><span class="n">prices</span><span class="o">.</span><span class="n">count</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">minPrice</span> <span class="p">{</span>
      <span class="n">minPrice</span> <span class="o">=</span> <span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">minPrice</span> <span class="o">&gt;</span> <span class="n">maxProfit</span> <span class="p">{</span>
      <span class="n">maxProfit</span> <span class="o">=</span> <span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="n">minPrice</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">maxProfit</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>结果</li>
</ul>

<blockquote>
  <p>print(solution.maxProfit([7,1,5,3,6,4]))</p>

  <p>5</p>
</blockquote>

<h3 id="买卖股票的最佳时机ii">买卖股票的最佳时机II</h3>

<ul>
  <li>示例</li>
</ul>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code>输入：[7,1,5,3,6,4]
输出：7
解释：在第2天（=1）买入，第三天（=5）卖出，利润4，然后在第4天（=3）买入，第5天（=6）卖出，利润3
总利润3+4=7
</code></pre></div></div>

<ul>
  <li>思路</li>
</ul>

<p>在斜坡上爬升并持续增加从交易中获得的利润</p>

<p><img src="http://localhost:4000/assets/images/posts/leetcode_maxprofit.jpg" alt="leetcode_maxprofit" /></p>

<ul>
  <li>解法</li>
</ul>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">maxProfitII</span><span class="p">(</span><span class="n">_</span> <span class="nv">prices</span><span class="p">:</span> <span class="p">[</span><span class="kt">Int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="p">{</span>
  <span class="k">if</span> <span class="n">prices</span><span class="o">.</span><span class="n">count</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">0</span>
  <span class="p">}</span>

  <span class="k">var</span> <span class="nv">maxProfit</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">1</span><span class="o">..&lt;</span><span class="n">prices</span><span class="o">.</span><span class="n">count</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="p">{</span>
      <span class="n">maxProfit</span> <span class="o">+=</span> <span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">maxProfit</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>结果</li>
</ul>

<blockquote>
  <p>print(solution.maxProfitII([7,1,5,3,6,4]))</p>

  <p>7</p>
</blockquote>

<h3 id="滑动窗口最大值">滑动窗口最大值</h3>

<p>给定一个Int窗口，实时的输出窗口最大的元素</p>

<ul>
  <li>示例</li>
</ul>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code>输入：k=3，nums=[1,3,-1,-3,5,3,6]
输出：[3,3,5,5,6]
</code></pre></div></div>

<ul>
  <li>思路</li>
</ul>

<p>窗口为3个位置，只要有一个最大值进来，比他早的元素永远没有出头之日，所以可以直接忽略掉。</p>

<ul>
  <li>解法</li>
</ul>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">findMaxInWindow</span><span class="p">(</span><span class="n">_</span> <span class="nv">count</span><span class="p">:</span> <span class="kt">Int</span><span class="p">,</span> <span class="n">_</span> <span class="nv">nums</span><span class="p">:</span> <span class="p">[</span><span class="kt">Int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span> <span class="p">{</span>
  <span class="k">var</span> <span class="nv">res</span> <span class="o">=</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]()</span>

  <span class="k">if</span> <span class="n">nums</span><span class="o">.</span><span class="n">count</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">[]</span>
  <span class="p">}</span>

  <span class="k">var</span> <span class="nv">maxNum</span> <span class="o">=</span> <span class="kt">Int</span><span class="o">.</span><span class="n">min</span>

  <span class="k">if</span> <span class="n">nums</span><span class="o">.</span><span class="n">count</span> <span class="o">&lt;</span> <span class="n">count</span> <span class="p">{</span>
    <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..&lt;</span><span class="n">nums</span><span class="o">.</span><span class="n">count</span> <span class="p">{</span>
      <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">maxNum</span> <span class="p">{</span>
        <span class="n">maxNum</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">res</span><span class="o">.</span><span class="nf">append</span><span class="p">(</span><span class="n">maxNum</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">res</span>
  <span class="p">}</span>

  <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..&lt;</span><span class="n">count</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">maxNum</span> <span class="p">{</span>
      <span class="n">maxNum</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="n">res</span><span class="o">.</span><span class="nf">append</span><span class="p">(</span><span class="n">maxNum</span><span class="p">)</span>

  <span class="k">for</span> <span class="n">j</span> <span class="nf">in</span> <span class="p">(</span><span class="n">nums</span><span class="o">.</span><span class="n">count</span><span class="o">-</span><span class="n">count</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">..&lt;</span><span class="n">nums</span><span class="o">.</span><span class="n">count</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">maxNum</span> <span class="p">{</span>
      <span class="n">maxNum</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
    <span class="p">}</span>

    <span class="n">res</span><span class="o">.</span><span class="nf">append</span><span class="p">(</span><span class="n">maxNum</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">res</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>结果</li>
</ul>

<blockquote>
  <p>let r15 = solution.findMaxInWindow(3, [1,3,-1,-3,5,3,6])</p>

  <p>print(r15)</p>

  <p><strong>[3, 3, 5, 5, 6]</strong></p>
</blockquote>

<h3 id="生成小括号字符串">生成小括号字符串</h3>

<p>给定固定长度，比如n，生成所有合法的小括号组成形式</p>

<ul>
  <li>示例</li>
</ul>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code>输入: n=3
输出: ["((()))", "(()())", "(())()", "()(())", "()()()"]
</code></pre></div></div>

<ul>
  <li>思路</li>
</ul>

<p>采用递归，但是要注意，左右括号肯定都是为n个，并且左括号可以随意加（不超过n），但是右括号必须要在左括号大于右括号的时候才可以输入，然后递归即可</p>

<ul>
  <li>解法</li>
</ul>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">generateParenthesis</span><span class="p">(</span><span class="n">_</span> <span class="nv">count</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="kt">String</span><span class="p">]</span> <span class="p">{</span>
  <span class="k">var</span> <span class="nv">res</span><span class="p">:</span> <span class="p">[</span><span class="kt">String</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="kt">String</span><span class="p">]()</span>
  <span class="nf">_gen</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="s">""</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">res</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">res</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">_gen</span><span class="p">(</span><span class="n">_</span> <span class="nv">left</span><span class="p">:</span> <span class="kt">Int</span><span class="p">,</span> <span class="n">_</span> <span class="nv">right</span><span class="p">:</span> <span class="kt">Int</span><span class="p">,</span> <span class="n">_</span> <span class="nv">count</span><span class="p">:</span> <span class="kt">Int</span><span class="p">,</span> <span class="n">_</span> <span class="nv">result</span><span class="p">:</span> <span class="kt">String</span><span class="p">,</span> <span class="n">_</span> <span class="nv">res</span><span class="p">:</span> <span class="k">inout</span> <span class="p">[</span><span class="kt">String</span><span class="p">])</span> <span class="p">{</span>
  <span class="c1">//递归出口</span>
  <span class="k">if</span> <span class="n">left</span> <span class="o">==</span> <span class="n">count</span> <span class="o">&amp;&amp;</span> <span class="n">right</span> <span class="o">==</span> <span class="n">count</span> <span class="p">{</span>
    <span class="n">res</span><span class="o">.</span><span class="nf">append</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="n">left</span> <span class="o">&lt;</span> <span class="n">count</span> <span class="p">{</span>
    <span class="nf">_gen</span><span class="p">(</span><span class="n">left</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">result</span><span class="o">+</span><span class="s">"("</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">res</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="n">left</span> <span class="o">&gt;</span> <span class="n">right</span> <span class="o">&amp;&amp;</span> <span class="n">right</span> <span class="o">&lt;</span> <span class="n">count</span> <span class="p">{</span>
    <span class="nf">_gen</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">result</span><span class="o">+</span><span class="s">")"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">res</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>结果</li>
</ul>

<blockquote>
  <p>let r16 = solution.generateParenthesis(3)</p>

  <p>print(r16)</p>

  <p><strong>[”((()))”, “(()())”, “(())()”, “()(())”, “()()()”]</strong></p>
</blockquote>]]></content><author><name>Cambria Yang</name><email>cambriayang@qq.com</email></author><category term="Algorithm" /><category term="算法" /><summary type="html"><![CDATA[一些算法举例 动态规划 买卖股票的最佳时机 给定一个数组，它的第i个元素是一支给定股票第i天的价格。 如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。 注意： 你不能再买入股票前卖出股票。 示例 输入：[7,1,5,3,6,4] 输出： 5 解释： 在第2天（股票价格=1）的时候买入，在第5天（=6），最大利润=6-1=5.注意利润不可能是7-1 输入： [7,6,4,3,1] 输出： 0 解释： 在这种情况下，没有交易完成，所以利润为0. 思路 需要找到最小的谷之后的最大的峰。 我们可以维持两个变量——minprice 和 maxprofit，它们分别对应迄今为止所得到的最小的谷值和最大的利润（卖出价格与最低价格之间的最大差值）。 解法 func maxProfit(_ prices: [Int]) -&gt; Int { var minPrice = Int.max var maxProfit = 0 for i in 0..&lt;prices.count { if prices[i] &lt; minPrice { minPrice = prices[i] } else if prices[i] - minPrice &gt; maxProfit { maxProfit = prices[i]-minPrice } } return maxProfit } 结果 print(solution.maxProfit([7,1,5,3,6,4])) 5 买卖股票的最佳时机II 示例 输入：[7,1,5,3,6,4] 输出：7 解释：在第2天（=1）买入，第三天（=5）卖出，利润4，然后在第4天（=3）买入，第5天（=6）卖出，利润3 总利润3+4=7 思路 在斜坡上爬升并持续增加从交易中获得的利润 解法 func maxProfitII(_ prices: [Int]) -&gt; Int { if prices.count &lt; 2 { return 0 } var maxProfit = 0 for i in 1..&lt;prices.count { if prices[i] &gt; prices[i-1] { maxProfit += prices[i]-prices[i-1] } } return maxProfit } 结果 print(solution.maxProfitII([7,1,5,3,6,4])) 7 滑动窗口最大值 给定一个Int窗口，实时的输出窗口最大的元素 示例 输入：k=3，nums=[1,3,-1,-3,5,3,6] 输出：[3,3,5,5,6] 思路 窗口为3个位置，只要有一个最大值进来，比他早的元素永远没有出头之日，所以可以直接忽略掉。 解法 func findMaxInWindow(_ count: Int, _ nums: [Int]) -&gt; [Int] { var res = [Int]() if nums.count &lt; 0 { return [] } var maxNum = Int.min if nums.count &lt; count { for i in 0..&lt;nums.count { if nums[i] &gt; maxNum { maxNum = nums[i] } } res.append(maxNum) return res } for i in 0..&lt;count { if nums[i] &gt; maxNum { maxNum = nums[i] } } res.append(maxNum) for j in (nums.count-count-1)..&lt;nums.count { if nums[j] &gt; maxNum { maxNum = nums[j] } res.append(maxNum) } return res } 结果 let r15 = solution.findMaxInWindow(3, [1,3,-1,-3,5,3,6]) print(r15) [3, 3, 5, 5, 6] 生成小括号字符串 给定固定长度，比如n，生成所有合法的小括号组成形式 示例 输入: n=3 输出: ["((()))", "(()())", "(())()", "()(())", "()()()"] 思路 采用递归，但是要注意，左右括号肯定都是为n个，并且左括号可以随意加（不超过n），但是右括号必须要在左括号大于右括号的时候才可以输入，然后递归即可 解法 func generateParenthesis(_ count: Int) -&gt; [String] { var res: [String] = [String]() _gen(0, 0, count, "", &amp;res) return res } func _gen(_ left: Int, _ right: Int, _ count: Int, _ result: String, _ res: inout [String]) { //递归出口 if left == count &amp;&amp; right == count { res.append(result) } if left &lt; count { _gen(left+1, right, count, result+"(", &amp;res) } if left &gt; right &amp;&amp; right &lt; count { _gen(left, right+1, count, result+")", &amp;res) } } 结果 let r16 = solution.generateParenthesis(3) print(r16) [”((()))”, “(()())”, “(())()”, “()(())”, “()()()”]]]></summary></entry><entry><title type="html">杂项算法</title><link href="http://localhost:4000/algorithm/2022/03/08/%E6%9D%82%E9%A1%B9%E7%AE%97%E6%B3%95.html" rel="alternate" type="text/html" title="杂项算法" /><published>2022-03-08T07:00:00+00:00</published><updated>2022-03-08T07:00:00+00:00</updated><id>http://localhost:4000/algorithm/2022/03/08/%E6%9D%82%E9%A1%B9%E7%AE%97%E6%B3%95</id><content type="html" xml:base="http://localhost:4000/algorithm/2022/03/08/%E6%9D%82%E9%A1%B9%E7%AE%97%E6%B3%95.html"><![CDATA[<p>一些算法举例</p>

<h2 id="杂项">杂项</h2>

<h3 id="产生不重复的随机数">产生不重复的随机数</h3>

<ul>
  <li>思路</li>
</ul>

<p>设想一下，有n个苹果，有不同的编号，从1-n，每次拿一个出来。来产生不同的随机数</p>

<ul>
  <li>实现</li>
</ul>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">randomNumberWithoutDuplication</span><span class="p">(</span><span class="n">_</span> <span class="nv">number</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span> <span class="p">{</span>
  <span class="k">var</span> <span class="nv">resultArr</span> <span class="o">=</span> <span class="kt">Array</span><span class="p">(</span><span class="nv">repeating</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="nv">count</span><span class="p">:</span> <span class="n">number</span><span class="p">)</span>
  <span class="k">var</span> <span class="nv">startArr</span> <span class="o">=</span> <span class="kt">Array</span><span class="p">(</span><span class="mi">1</span><span class="o">...</span><span class="n">number</span><span class="p">)</span>

  <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..&lt;</span><span class="n">startArr</span><span class="o">.</span><span class="n">count</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">currentCount</span> <span class="o">=</span> <span class="kt">UInt32</span><span class="p">(</span><span class="n">startArr</span><span class="o">.</span><span class="n">count</span><span class="o">-</span><span class="n">i</span><span class="p">)</span>
    <span class="k">let</span> <span class="nv">index</span> <span class="o">=</span> <span class="kt">Int</span><span class="p">(</span><span class="nf">arc4random_uniform</span><span class="p">(</span><span class="n">currentCount</span><span class="p">))</span>
    <span class="n">resultArr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">startArr</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
    <span class="n">startArr</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">startArr</span><span class="p">[</span><span class="kt">Int</span><span class="p">(</span><span class="n">currentCount</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">resultArr</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>测试</li>
</ul>

<blockquote>
  <p>let aaa = solution.randomNumberWithoutDuplication(10)</p>

  <p>[1, 5, 8, 9, 4, 3, 10, 2, 6, 7]</p>
</blockquote>

<h3 id="求解n的结果中有多少个0">求解n！的结果中有多少个0</h3>

<ul>
  <li>
    <p>思路</p>

    <p>首先我们知道10=2<em>5，所以有多少个0取决于有多少个2</em>5。而n！中包含5的因子的个数，可以用下面的表达式来计算</p>

    <p>k= n/5+n/5^2+n/5^3+…</p>

    <p>同样的n！包含2的因子的个数可以用下面的表达式来计算</p>

    <p>m= n/2+n/2^2+n/2^3+…</p>

    <p>很显然m&gt;k。所以末尾0的个数是min(m,k)也就是k了。</p>
  </li>
  <li>
    <p>实现</p>

    <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">trailing_zero_num</span><span class="p">(</span><span class="nv">number</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="p">{</span>
  <span class="k">var</span> <span class="nv">num</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="k">var</span> <span class="nv">n</span> <span class="o">=</span> <span class="n">number</span>
  <span class="k">while</span> <span class="kt">Bool</span><span class="p">(</span><span class="nv">truncating</span><span class="p">:</span> <span class="n">n</span> <span class="k">as</span> <span class="kt">NSNumber</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">num</span> <span class="o">+=</span> <span class="n">n</span><span class="o">/</span><span class="mi">5</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">n</span><span class="o">/</span><span class="mi">5</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">num</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
</ul>

<h3 id="多线程交替打印ab分别10次">多线程交替打印A，B分别10次</h3>

<ul>
  <li>实现</li>
</ul>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">outABWithGCD</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">let</span> <span class="nv">queue1</span> <span class="o">=</span> <span class="kt">DispatchQueue</span><span class="p">(</span><span class="nv">label</span><span class="p">:</span> <span class="s">"com.queue1.a"</span><span class="p">,</span> <span class="nv">qos</span><span class="p">:</span> <span class="o">.</span><span class="n">utility</span><span class="p">)</span>
  <span class="k">let</span> <span class="nv">queue2</span> <span class="o">=</span> <span class="kt">DispatchQueue</span><span class="p">(</span><span class="nv">label</span><span class="p">:</span> <span class="s">"com.queue2.b"</span><span class="p">,</span> <span class="nv">qos</span><span class="p">:</span> <span class="o">.</span><span class="n">utility</span><span class="p">)</span>

  <span class="k">var</span> <span class="nv">change</span><span class="p">:</span> <span class="kt">Bool</span> <span class="o">=</span> <span class="kc">true</span>

  <span class="n">queue1</span><span class="o">.</span><span class="k">async</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">count1</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="kc">true</span> <span class="p">{</span>
      <span class="k">if</span> <span class="n">change</span> <span class="p">{</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"queue1:A"</span><span class="p">)</span>
        <span class="n">change</span> <span class="o">=</span> <span class="kc">false</span>
        <span class="n">count1</span><span class="o">+=</span><span class="mi">1</span>
      <span class="p">}</span>

      <span class="k">if</span> <span class="n">count1</span> <span class="o">==</span> <span class="mi">10</span> <span class="p">{</span>
        <span class="k">break</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="n">queue2</span><span class="o">.</span><span class="k">async</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">count2</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="kc">true</span> <span class="p">{</span>
      <span class="k">if</span> <span class="o">!</span><span class="n">change</span> <span class="p">{</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"queue2:B"</span><span class="p">)</span>
        <span class="n">change</span> <span class="o">=</span> <span class="kc">true</span>
        <span class="n">count2</span><span class="o">+=</span><span class="mi">1</span>
      <span class="p">}</span>

      <span class="k">if</span> <span class="n">count2</span> <span class="o">==</span> <span class="mi">10</span> <span class="p">{</span>
        <span class="k">break</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>示例</li>
</ul>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">solution</span><span class="o">.</span><span class="nf">outABWithGCD</span><span class="p">()</span>
</code></pre></div></div>

<ul>
  <li>结果</li>
</ul>

<blockquote>
  <p><strong>queue1:A</strong></p>

  <p><strong>queue2:B</strong></p>

  <p><strong>queue1:A</strong></p>

  <p><strong>queue2:B</strong></p>

  <p><strong>queue1:A</strong></p>

  <p><strong>queue2:B</strong></p>

  <p><strong>queue1:A</strong></p>

  <p><strong>queue2:B</strong></p>

  <p><strong>queue1:A</strong></p>

  <p><strong>queue2:B</strong></p>

  <p><strong>queue1:A</strong></p>

  <p><strong>queue2:B</strong></p>

  <p><strong>queue1:A</strong></p>

  <p><strong>queue2:B</strong></p>

  <p><strong>queue1:A</strong></p>

  <p><strong>queue2:B</strong></p>

  <p><strong>queue1:A</strong></p>

  <p><strong>queue2:B</strong></p>

  <p><strong>queue1:A</strong></p>

  <p>queue2:B</p>
</blockquote>]]></content><author><name>Cambria Yang</name><email>cambriayang@qq.com</email></author><category term="Algorithm" /><category term="算法" /><summary type="html"><![CDATA[一些算法举例 杂项 产生不重复的随机数 思路 设想一下，有n个苹果，有不同的编号，从1-n，每次拿一个出来。来产生不同的随机数 实现 func randomNumberWithoutDuplication(_ number: Int) -&gt; [Int] { var resultArr = Array(repeating: 0, count: number) var startArr = Array(1...number) for i in 0..&lt;startArr.count { let currentCount = UInt32(startArr.count-i) let index = Int(arc4random_uniform(currentCount)) resultArr[i] = startArr[index] startArr[index] = startArr[Int(currentCount) - 1] } return resultArr } 测试 let aaa = solution.randomNumberWithoutDuplication(10) [1, 5, 8, 9, 4, 3, 10, 2, 6, 7] 求解n！的结果中有多少个0 思路 首先我们知道10=25，所以有多少个0取决于有多少个25。而n！中包含5的因子的个数，可以用下面的表达式来计算 k= n/5+n/5^2+n/5^3+… 同样的n！包含2的因子的个数可以用下面的表达式来计算 m= n/2+n/2^2+n/2^3+… 很显然m&gt;k。所以末尾0的个数是min(m,k)也就是k了。 实现 func trailing_zero_num(number: Int) -&gt; Int { var num = 0 var n = number while Bool(truncating: n as NSNumber) { num += n/5 n = n/5 } return num } 多线程交替打印A，B分别10次 实现 func outABWithGCD() { let queue1 = DispatchQueue(label: "com.queue1.a", qos: .utility) let queue2 = DispatchQueue(label: "com.queue2.b", qos: .utility) var change: Bool = true queue1.async { var count1 = 0 while true { if change { print("queue1:A") change = false count1+=1 } if count1 == 10 { break } } } queue2.async { var count2 = 0 while true { if !change { print("queue2:B") change = true count2+=1 } if count2 == 10 { break } } } } 示例 solution.outABWithGCD() 结果 queue1:A queue2:B queue1:A queue2:B queue1:A queue2:B queue1:A queue2:B queue1:A queue2:B queue1:A queue2:B queue1:A queue2:B queue1:A queue2:B queue1:A queue2:B queue1:A queue2:B]]></summary></entry><entry><title type="html">树算法</title><link href="http://localhost:4000/algorithm/2022/03/08/%E6%A0%91%E7%AE%97%E6%B3%95.html" rel="alternate" type="text/html" title="树算法" /><published>2022-03-08T06:00:00+00:00</published><updated>2022-03-08T06:00:00+00:00</updated><id>http://localhost:4000/algorithm/2022/03/08/%E6%A0%91%E7%AE%97%E6%B3%95</id><content type="html" xml:base="http://localhost:4000/algorithm/2022/03/08/%E6%A0%91%E7%AE%97%E6%B3%95.html"><![CDATA[<p>一些算法举例</p>

<h2 id="树">树</h2>

<p>树是最常用且非常有用的数据结构之一，通过下图可以很容易理解树的概念。</p>

<p><img src="http://localhost:4000/assets/images/posts/leetcode_tree.jpg" alt="leetcode_tree" /></p>

<p>上图展示的是一个拥有5个层级数的树结构。树根root是第0层，从树最外层开始每深入一层，其层级树相应的减1。
树能帮你解决很多问题，包括：</p>

<ul>
  <li>表示对象的层级关系</li>
  <li>使查询快速高效</li>
  <li>能提供有序的数据链</li>
  <li>文本的前缀匹配搜索</li>
</ul>

<h3 id="swift构造树">swift构造树</h3>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">TreeNode</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">T</span>
    <span class="k">var</span> <span class="nv">children</span><span class="p">:</span> <span class="p">[</span><span class="kt">TreeNode</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">weak</span> <span class="k">var</span> <span class="nv">parent</span><span class="p">:</span> <span class="kt">TreeNode</span><span class="p">?</span>
    
    <span class="nf">init</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="kt">T</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>
    <span class="p">}</span>
    
    <span class="kd">func</span> <span class="nf">add</span><span class="p">(</span><span class="nv">child</span><span class="p">:</span> <span class="kt">TreeNode</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">children</span><span class="o">.</span><span class="nf">append</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
        <span class="n">child</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="k">self</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>但是这种是没办法被print打印出来的。需要：</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">extension</span> <span class="kt">TreeNode</span><span class="p">:</span> <span class="kt">CustomStringConvertible</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">description</span><span class="p">:</span> <span class="kt">String</span> <span class="p">{</span>
        <span class="k">var</span> <span class="nv">text</span> <span class="o">=</span> <span class="s">"</span><span class="se">\(</span><span class="n">value</span><span class="se">)</span><span class="s">"</span>
        <span class="k">if</span> <span class="o">!</span><span class="n">children</span><span class="o">.</span><span class="n">isEmpty</span> <span class="p">{</span>
            <span class="n">text</span> <span class="o">+=</span> <span class="s">"{"</span><span class="o">+</span><span class="n">children</span><span class="o">.</span><span class="n">map</span><span class="p">{</span><span class="nv">$0</span><span class="o">.</span><span class="n">description</span><span class="p">}</span><span class="o">.</span><span class="nf">joined</span><span class="p">(</span><span class="nv">separator</span><span class="p">:</span> <span class="s">", "</span><span class="p">)</span><span class="o">+</span><span class="s">"}"</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">text</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>搜索：</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">extension</span> <span class="kt">TreeNode</span> <span class="k">where</span> <span class="kt">T</span><span class="p">:</span> <span class="kt">Equatable</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">search</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="kt">T</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">TreeNode</span><span class="p">?</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">value</span> <span class="o">==</span> <span class="k">self</span><span class="o">.</span><span class="n">value</span> <span class="p">{</span>
            <span class="k">return</span> <span class="k">self</span>
        <span class="p">}</span>
        
        <span class="k">for</span> <span class="n">child</span> <span class="k">in</span> <span class="n">children</span> <span class="p">{</span>
            <span class="k">if</span> <span class="k">let</span> <span class="nv">found</span> <span class="o">=</span> <span class="n">child</span><span class="o">.</span><span class="nf">search</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="n">found</span>
            <span class="p">}</span>
        <span class="p">}</span>
        
        <span class="k">return</span> <span class="kc">nil</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="为数组建立二进制搜索树并搜索范围内的节点">为数组建立二进制搜索树，并搜索范围内的节点</h3>
<ul>
  <li>示例：</li>
</ul>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code>输入：int型数组[7, 20，9，10，25，16，2，40，16，6]
范围：[9,35]
输出：9，10，20, 25, 16
</code></pre></div></div>

<ul>
  <li>
    <p>思路：</p>
  </li>
  <li>
    <p>构建BST：</p>
  </li>
</ul>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">BinaryTree</span><span class="o">&lt;</span><span class="kt">T</span><span class="p">:</span> <span class="kt">Comparable</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="kd">public</span> <span class="k">var</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">T</span>
    <span class="kd">public</span> <span class="k">var</span> <span class="nv">parent</span><span class="p">:</span> <span class="kt">BinaryTree</span><span class="p">?</span>
    <span class="kd">public</span> <span class="k">var</span> <span class="nv">left</span><span class="p">:</span> <span class="kt">BinaryTree</span><span class="p">?</span>
    <span class="kd">public</span> <span class="k">var</span> <span class="nv">right</span><span class="p">:</span> <span class="kt">BinaryTree</span><span class="p">?</span>

    <span class="nf">init</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="kt">T</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>
    <span class="p">}</span>
    
    <span class="k">var</span> <span class="nv">isRoot</span><span class="p">:</span> <span class="kt">Bool</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">parent</span> <span class="o">==</span> <span class="kc">nil</span>
    <span class="p">}</span>
    
    <span class="k">var</span> <span class="nv">isLeaf</span><span class="p">:</span> <span class="kt">Bool</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">left</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="n">right</span> <span class="o">==</span> <span class="kc">nil</span>
    <span class="p">}</span>
    
    <span class="k">var</span> <span class="nv">isLeftChild</span><span class="p">:</span> <span class="kt">Bool</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">parent</span><span class="p">?</span><span class="o">.</span><span class="n">left</span> <span class="o">===</span> <span class="k">self</span>
    <span class="p">}</span>
    
    <span class="k">var</span> <span class="nv">isRightChild</span><span class="p">:</span> <span class="kt">Bool</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">parent</span><span class="p">?</span><span class="o">.</span><span class="n">right</span> <span class="o">===</span> <span class="k">self</span>
    <span class="p">}</span>
    
    <span class="k">var</span> <span class="nv">hasLeftChild</span><span class="p">:</span> <span class="kt">Bool</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">left</span> <span class="o">!=</span> <span class="kc">nil</span>
    <span class="p">}</span>
    
    <span class="k">var</span> <span class="nv">hasRightChild</span><span class="p">:</span> <span class="kt">Bool</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">right</span> <span class="o">!=</span> <span class="kc">nil</span>
    <span class="p">}</span>
    
    <span class="k">var</span> <span class="nv">hasBothChildren</span><span class="p">:</span> <span class="kt">Bool</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">hasLeftChild</span> <span class="o">&amp;&amp;</span> <span class="n">hasRightChild</span>
    <span class="p">}</span>
    
    <span class="k">var</span> <span class="nv">count</span><span class="p">:</span> <span class="kt">Int</span> <span class="p">{</span>
        <span class="nf">return</span> <span class="p">(</span><span class="n">left</span><span class="p">?</span><span class="o">.</span><span class="n">count</span> <span class="p">??</span> <span class="mi">0</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="o">+</span><span class="p">(</span><span class="n">right</span><span class="p">?</span><span class="o">.</span><span class="n">count</span> <span class="p">??</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="kt">BinarySearchTree</span><span class="o">&lt;</span><span class="kt">T</span><span class="p">:</span> <span class="kt">Comparable</span><span class="o">&gt;</span> <span class="p">:</span> <span class="kt">BinaryTree</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">insert</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="kt">T</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">value</span> <span class="o">&lt;</span> <span class="k">self</span><span class="o">.</span><span class="n">value</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">hasLeftChild</span> <span class="p">{</span>
                <span class="p">(</span><span class="n">left</span> <span class="k">as!</span> <span class="kt">BinarySearchTree</span><span class="p">)</span><span class="o">.</span><span class="nf">insert</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="n">value</span><span class="p">)</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">left</span> <span class="o">=</span> <span class="kt">BinarySearchTree</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="n">value</span><span class="p">)</span>
                <span class="n">left</span><span class="p">?</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="k">self</span>
            <span class="p">}</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">hasRightChild</span> <span class="p">{</span>
                <span class="p">(</span><span class="n">right</span> <span class="k">as!</span> <span class="kt">BinarySearchTree</span><span class="p">)</span><span class="o">.</span><span class="nf">insert</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="n">value</span><span class="p">)</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">right</span> <span class="o">=</span> <span class="kt">BinarySearchTree</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="n">value</span><span class="p">)</span>
                <span class="n">right</span><span class="p">?</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="k">self</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>功能函数：</li>
</ul>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//获取[9,35]</span>
    <span class="kd">func</span> <span class="nf">findTree</span><span class="p">(</span><span class="nv">tree</span><span class="p">:</span> <span class="kt">BinarySearchTree</span><span class="o">&lt;</span><span class="kt">Int</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">tree</span><span class="o">.</span><span class="n">value</span> <span class="o">&lt;=</span> <span class="mi">9</span> <span class="p">{</span>
            <span class="c1">//在右边找</span>
            <span class="k">if</span> <span class="n">tree</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="mi">9</span> <span class="p">{</span>
                <span class="nf">print</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="nv">terminator</span><span class="p">:</span> <span class="s">" "</span><span class="p">)</span>
            <span class="p">}</span>
            
            <span class="k">if</span> <span class="n">tree</span><span class="o">.</span><span class="n">hasRightChild</span> <span class="p">{</span>
                <span class="nf">findTree</span><span class="p">(</span><span class="nv">tree</span><span class="p">:</span> <span class="n">tree</span><span class="o">.</span><span class="n">right</span><span class="o">!</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">tree</span><span class="o">.</span><span class="n">value</span> <span class="o">&gt;=</span> <span class="mi">35</span> <span class="p">{</span>
            <span class="c1">//在左边找</span>
            <span class="k">if</span> <span class="n">tree</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="mi">35</span> <span class="p">{</span>
                <span class="nf">print</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="nv">terminator</span><span class="p">:</span> <span class="s">" "</span><span class="p">)</span>
            <span class="p">}</span>
            
            <span class="k">if</span> <span class="n">tree</span><span class="o">.</span><span class="n">hasLeftChild</span> <span class="p">{</span>
                <span class="nf">findTree</span><span class="p">(</span><span class="nv">tree</span><span class="p">:</span> <span class="n">tree</span><span class="o">.</span><span class="n">left</span><span class="o">!</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">tree</span><span class="o">.</span><span class="n">value</span> <span class="o">&gt;</span> <span class="mi">9</span> <span class="o">&amp;&amp;</span> <span class="n">tree</span><span class="o">.</span><span class="n">value</span> <span class="o">&lt;</span> <span class="mi">35</span> <span class="p">{</span>
            <span class="nf">print</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="nv">terminator</span><span class="p">:</span> <span class="s">" "</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">tree</span><span class="o">.</span><span class="n">hasLeftChild</span> <span class="p">{</span>
                <span class="nf">findTree</span><span class="p">(</span><span class="nv">tree</span><span class="p">:</span> <span class="n">tree</span><span class="o">.</span><span class="n">left</span><span class="o">!</span><span class="p">)</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="n">tree</span><span class="o">.</span><span class="n">hasRightChild</span> <span class="p">{</span>
                <span class="nf">findTree</span><span class="p">(</span><span class="nv">tree</span><span class="p">:</span> <span class="n">tree</span><span class="o">.</span><span class="n">right</span><span class="o">!</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>测试：</li>
</ul>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">tree</span> <span class="o">=</span> <span class="kt">BinarySearchTree</span><span class="o">&lt;</span><span class="kt">Int</span><span class="o">&gt;</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="mi">7</span><span class="p">)</span>
<span class="n">tree</span><span class="o">.</span><span class="nf">insert</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="mi">20</span><span class="p">)</span>
<span class="n">tree</span><span class="o">.</span><span class="nf">insert</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="mi">9</span><span class="p">)</span>
<span class="n">tree</span><span class="o">.</span><span class="nf">insert</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="mi">10</span><span class="p">)</span>
<span class="n">tree</span><span class="o">.</span><span class="nf">insert</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="mi">25</span><span class="p">)</span>
<span class="n">tree</span><span class="o">.</span><span class="nf">insert</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="mi">16</span><span class="p">)</span>
<span class="n">tree</span><span class="o">.</span><span class="nf">insert</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">tree</span><span class="o">.</span><span class="nf">insert</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="mi">40</span><span class="p">)</span>
<span class="n">tree</span><span class="o">.</span><span class="nf">insert</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="mi">16</span><span class="p">)</span>
<span class="n">tree</span><span class="o">.</span><span class="nf">insert</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="mi">6</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
</code></pre></div></div>

<blockquote>
  <p><strong>(2 -&gt; (6)) &lt;- 7 -&gt; ((9 -&gt; (10 -&gt; (16))) &lt;- 20 -&gt; (25 -&gt; (40)))</strong></p>

  <p><strong>20 9 10 16 25</strong></p>
</blockquote>

<h3 id="输出一颗树所有的到叶子节点的路径">输出一颗树所有的到叶子节点的路径</h3>

<ul>
  <li>示例：</li>
</ul>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code>输入：int型数组[7, 20，9，10，25，16，2，40，16，6]
输出：["7-&gt;2-&gt;6", "7-&gt;20-&gt;9-&gt;10-&gt;16", "7-&gt;20-&gt;25-&gt;40"]
</code></pre></div></div>
<ul>
  <li>
    <p>思路
很简单，递归，先去实现左子树的路径，而后实现右子树的路径</p>
  </li>
  <li>
    <p>实现
  沿用上述的二叉搜索树结构（自定义的二叉树结构也测试过，此处不展示了）</p>

    <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">public</span> <span class="kd">func</span> <span class="nf">outputAllPathInBTree</span><span class="p">(</span><span class="nv">root</span><span class="p">:</span> <span class="kt">BinaryTree</span><span class="o">&lt;</span><span class="kt">Int</span><span class="o">&gt;</span><span class="p">?,</span> <span class="nv">path</span><span class="p">:</span> <span class="kt">String</span><span class="p">,</span> <span class="nv">paths</span><span class="p">:</span> <span class="k">inout</span> <span class="p">[</span><span class="kt">String</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kt">Void</span> <span class="p">{</span>
      <span class="k">if</span> <span class="n">root</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
          <span class="k">return</span>
      <span class="p">}</span>
	
      <span class="k">var</span> <span class="nv">p</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="nf">appending</span><span class="p">(</span><span class="kt">String</span><span class="p">(</span><span class="n">root</span><span class="o">!.</span><span class="n">value</span><span class="p">))</span>
	
      <span class="k">if</span> <span class="n">root</span><span class="p">?</span><span class="o">.</span><span class="n">left</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="n">root</span><span class="p">?</span><span class="o">.</span><span class="n">right</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
          <span class="n">paths</span><span class="o">.</span><span class="nf">append</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
          <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="nf">appending</span><span class="p">(</span><span class="s">"-&gt;"</span><span class="p">)</span>
          <span class="nf">outputAllPathInBTree</span><span class="p">(</span><span class="nv">root</span><span class="p">:</span> <span class="n">root</span><span class="p">?</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="nv">path</span><span class="p">:</span> <span class="n">p</span><span class="p">,</span> <span class="nv">paths</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">paths</span><span class="p">)</span>
          <span class="nf">outputAllPathInBTree</span><span class="p">(</span><span class="nv">root</span><span class="p">:</span> <span class="n">root</span><span class="p">?</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="nv">path</span><span class="p">:</span> <span class="n">p</span><span class="p">,</span> <span class="nv">paths</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">paths</span><span class="p">)</span>
      <span class="p">}</span>
  <span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>测试</p>

    <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code>      <span class="k">let</span> <span class="nv">bsTree</span> <span class="o">=</span> <span class="nf">generateBSTree</span><span class="p">()</span>
  <span class="k">let</span> <span class="nv">bTree</span> <span class="o">=</span> <span class="nf">generateBTree</span><span class="p">()</span>
  
  <span class="k">let</span> <span class="nv">bstpath</span> <span class="o">=</span> <span class="s">""</span>
  <span class="k">var</span> <span class="nv">bstpaths</span><span class="p">:</span> <span class="p">[</span><span class="kt">String</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
  
  <span class="nf">outputAllPathInBTree</span><span class="p">(</span><span class="nv">root</span><span class="p">:</span> <span class="n">bsTree</span><span class="p">,</span> <span class="nv">path</span><span class="p">:</span> <span class="n">bstpath</span><span class="p">,</span> <span class="nv">paths</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">bstpaths</span><span class="p">)</span>
  
  <span class="nf">print</span><span class="p">(</span><span class="s">"outputAllPathInBTree is: "</span><span class="p">)</span>
  <span class="nf">print</span><span class="p">(</span><span class="n">bstpaths</span><span class="p">)</span>
    
  <span class="kd">public</span> <span class="kd">func</span> <span class="nf">generateBTree</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">BinaryTree</span><span class="o">&lt;</span><span class="kt">Int</span><span class="o">&gt;</span> <span class="p">{</span>
      <span class="k">let</span> <span class="nv">bTree</span> <span class="o">=</span> <span class="kt">BinaryTree</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="mi">1</span><span class="p">)</span>
	
      <span class="n">bTree</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="kt">BinaryTree</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="mi">3</span><span class="p">)</span>
	
      <span class="k">let</span> <span class="nv">bl</span> <span class="o">=</span> <span class="kt">BinaryTree</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="mi">2</span><span class="p">)</span>
      <span class="n">bl</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="kt">BinaryTree</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="mi">5</span><span class="p">)</span>
	
      <span class="n">bTree</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">bl</span>
	
      <span class="nf">print</span><span class="p">(</span><span class="s">"binary tree is: "</span><span class="p">)</span>
      <span class="nf">print</span><span class="p">(</span><span class="n">bTree</span><span class="p">)</span>
      <span class="nf">print</span><span class="p">(</span><span class="s">"</span><span class="se">\r</span><span class="s">"</span><span class="p">)</span>
	
      <span class="k">return</span> <span class="n">bTree</span>
  <span class="p">}</span>
</code></pre></div>    </div>
  </li>
</ul>

<blockquote>
  <p>outputAllPathInBTree is: 
[“7-&gt;2-&gt;6”, “7-&gt;20-&gt;9-&gt;10-&gt;16”, “7-&gt;20-&gt;25-&gt;40”]</p>

  <p>outputAllPathInBTree is: 
[“1-&gt;2-&gt;5”, “1-&gt;3”]</p>
</blockquote>]]></content><author><name>Cambria Yang</name><email>cambriayang@qq.com</email></author><category term="Algorithm" /><category term="算法" /><summary type="html"><![CDATA[一些算法举例 树 树是最常用且非常有用的数据结构之一，通过下图可以很容易理解树的概念。 上图展示的是一个拥有5个层级数的树结构。树根root是第0层，从树最外层开始每深入一层，其层级树相应的减1。 树能帮你解决很多问题，包括： 表示对象的层级关系 使查询快速高效 能提供有序的数据链 文本的前缀匹配搜索 swift构造树 class TreeNode&lt;T&gt; { var value: T var children: [TreeNode] = [] weak var parent: TreeNode? init(value: T) { self.value = value } func add(child: TreeNode) { children.append(child) child.parent = self } } 但是这种是没办法被print打印出来的。需要： extension TreeNode: CustomStringConvertible { var description: String { var text = "\(value)" if !children.isEmpty { text += "{"+children.map{$0.description}.joined(separator: ", ")+"}" } return text } } 搜索： extension TreeNode where T: Equatable { func search(value: T) -&gt; TreeNode? { if value == self.value { return self } for child in children { if let found = child.search(value: value) { return found } } return nil } } 为数组建立二进制搜索树，并搜索范围内的节点 示例： 输入：int型数组[7, 20，9，10，25，16，2，40，16，6] 范围：[9,35] 输出：9，10，20, 25, 16 思路： 构建BST： class BinaryTree&lt;T: Comparable&gt; { public var value: T public var parent: BinaryTree? public var left: BinaryTree? public var right: BinaryTree? init(value: T) { self.value = value } var isRoot: Bool { return parent == nil } var isLeaf: Bool { return left == nil &amp;&amp; right == nil } var isLeftChild: Bool { return parent?.left === self } var isRightChild: Bool { return parent?.right === self } var hasLeftChild: Bool { return left != nil } var hasRightChild: Bool { return right != nil } var hasBothChildren: Bool { return hasLeftChild &amp;&amp; hasRightChild } var count: Int { return (left?.count ?? 0)+1+(right?.count ?? 0) } } class BinarySearchTree&lt;T: Comparable&gt; : BinaryTree&lt;T&gt; { func insert(value: T) { if value &lt; self.value { if hasLeftChild { (left as! BinarySearchTree).insert(value: value) } else { left = BinarySearchTree(value: value) left?.parent = self } } else { if hasRightChild { (right as! BinarySearchTree).insert(value: value) } else { right = BinarySearchTree(value: value) right?.parent = self } } } } 功能函数： //获取[9,35] func findTree(tree: BinarySearchTree&lt;Int&gt;) { if tree.value &lt;= 9 { //在右边找 if tree.value == 9 { print(tree.value, terminator: " ") } if tree.hasRightChild { findTree(tree: tree.right!) } } else if tree.value &gt;= 35 { //在左边找 if tree.value == 35 { print(tree.value, terminator: " ") } if tree.hasLeftChild { findTree(tree: tree.left!) } } else if tree.value &gt; 9 &amp;&amp; tree.value &lt; 35 { print(tree.value, terminator: " ") if tree.hasLeftChild { findTree(tree: tree.left!) } if tree.hasRightChild { findTree(tree: tree.right!) } } } 测试： let tree = BinarySearchTree&lt;Int&gt;(value: 7) tree.insert(value: 20) tree.insert(value: 9) tree.insert(value: 10) tree.insert(value: 25) tree.insert(value: 16) tree.insert(value: 2) tree.insert(value: 40) tree.insert(value: 16) tree.insert(value: 6) print(tree) (2 -&gt; (6)) &lt;- 7 -&gt; ((9 -&gt; (10 -&gt; (16))) &lt;- 20 -&gt; (25 -&gt; (40))) 20 9 10 16 25 输出一颗树所有的到叶子节点的路径 示例： 输入：int型数组[7, 20，9，10，25，16，2，40，16，6] 输出：["7-&gt;2-&gt;6", "7-&gt;20-&gt;9-&gt;10-&gt;16", "7-&gt;20-&gt;25-&gt;40"] 思路 很简单，递归，先去实现左子树的路径，而后实现右子树的路径 实现 沿用上述的二叉搜索树结构（自定义的二叉树结构也测试过，此处不展示了） public func outputAllPathInBTree(root: BinaryTree&lt;Int&gt;?, path: String, paths: inout [String]) -&gt; Void { if root == nil { return } var p = path.appending(String(root!.value)) if root?.left == nil &amp;&amp; root?.right == nil { paths.append(p) } else { p = p.appending("-&gt;") outputAllPathInBTree(root: root?.left, path: p, paths: &amp;paths) outputAllPathInBTree(root: root?.right, path: p, paths: &amp;paths) } } 测试 let bsTree = generateBSTree() let bTree = generateBTree() let bstpath = "" var bstpaths: [String] = [] outputAllPathInBTree(root: bsTree, path: bstpath, paths: &amp;bstpaths) print("outputAllPathInBTree is: ") print(bstpaths) public func generateBTree() -&gt; BinaryTree&lt;Int&gt; { let bTree = BinaryTree(value: 1) bTree.right = BinaryTree(value: 3) let bl = BinaryTree(value: 2) bl.right = BinaryTree(value: 5) bTree.left = bl print("binary tree is: ") print(bTree) print("\r") return bTree } outputAllPathInBTree is: [“7-&gt;2-&gt;6”, “7-&gt;20-&gt;9-&gt;10-&gt;16”, “7-&gt;20-&gt;25-&gt;40”] outputAllPathInBTree is: [“1-&gt;2-&gt;5”, “1-&gt;3”]]]></summary></entry><entry><title type="html">链表算法</title><link href="http://localhost:4000/algorithm/2022/03/08/%E9%93%BE%E8%A1%A8%E7%AE%97%E6%B3%95.html" rel="alternate" type="text/html" title="链表算法" /><published>2022-03-08T05:00:00+00:00</published><updated>2022-03-08T05:00:00+00:00</updated><id>http://localhost:4000/algorithm/2022/03/08/%E9%93%BE%E8%A1%A8%E7%AE%97%E6%B3%95</id><content type="html" xml:base="http://localhost:4000/algorithm/2022/03/08/%E9%93%BE%E8%A1%A8%E7%AE%97%E6%B3%95.html"><![CDATA[<p>一些算法举例</p>

<h2 id="链表">链表</h2>
<h3 id="合并两个排过序的链表并将其作为新链表">合并两个排过序的链表，并将其作为新链表</h3>

<p>示例：</p>
<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code>输入：1-＞2-＞4,1-＞3-＞4
输出：1-＞1-＞2-＞3-＞4-＞4
</code></pre></div></div>

<p>思路：
很简单，就是链表遍历，然后变换next就可以了</p>

<p>代码实现：</p>

<p>链表构造</p>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">Node</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">T</span>
    <span class="k">var</span> <span class="nv">next</span><span class="p">:</span> <span class="kt">Node</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span><span class="p">?</span>
    <span class="nf">init</span><span class="p">(</span><span class="n">_</span> <span class="nv">val</span><span class="p">:</span> <span class="kt">T</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">val</span>
        <span class="k">self</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="kc">nil</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="kt">IntLinkList</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">head</span><span class="p">:</span> <span class="kt">Node</span><span class="o">&lt;</span><span class="kt">Int</span><span class="o">&gt;</span><span class="p">?</span>
    <span class="k">var</span> <span class="nv">tail</span><span class="p">:</span> <span class="kt">Node</span><span class="o">&lt;</span><span class="kt">Int</span><span class="o">&gt;</span><span class="p">?</span>
    
    <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">tail</span> <span class="o">=</span> <span class="kc">nil</span>
        <span class="n">head</span> <span class="o">=</span> <span class="n">tail</span>
    <span class="p">}</span>
    
    <span class="k">var</span> <span class="nv">isEmpty</span><span class="p">:</span> <span class="kt">Bool</span> <span class="p">{</span>
        <span class="k">get</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">head</span> <span class="o">==</span> <span class="kc">nil</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="kd">func</span> <span class="nf">append</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">node</span> <span class="o">=</span> <span class="kt">Node</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">tail</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="n">tail</span> <span class="o">=</span> <span class="n">node</span>
            <span class="n">head</span> <span class="o">=</span> <span class="n">tail</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">tail</span><span class="o">!.</span><span class="n">next</span> <span class="o">=</span> <span class="n">node</span>
            <span class="n">tail</span> <span class="o">=</span> <span class="n">tail</span><span class="o">!.</span><span class="n">next</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="kd">func</span> <span class="nf">appendToHead</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">node</span> <span class="o">=</span> <span class="kt">Node</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">head</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="n">head</span> <span class="o">=</span> <span class="n">node</span>
            <span class="n">tail</span> <span class="o">=</span> <span class="n">head</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">node</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">head</span><span class="p">?</span><span class="o">.</span><span class="n">next</span>
            <span class="n">head</span> <span class="o">=</span> <span class="n">node</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="kd">func</span> <span class="nf">insertAt</span><span class="p">(</span><span class="nv">index</span><span class="p">:</span> <span class="kt">Int</span><span class="p">,</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="k">self</span><span class="o">.</span><span class="nf">appendToHead</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="n">value</span><span class="p">)</span>
        <span class="p">}</span>
        
        <span class="k">var</span> <span class="nv">tmp</span> <span class="o">=</span> <span class="n">head</span>
        
        <span class="k">var</span> <span class="nv">i</span><span class="p">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">0</span>
        
        <span class="k">while</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">index</span> <span class="o">&amp;&amp;</span> <span class="n">tmp</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">?</span><span class="o">.</span><span class="n">next</span>
            <span class="n">i</span><span class="o">+=</span><span class="mi">1</span>
        <span class="p">}</span>
        
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">index</span> <span class="p">{</span>
            <span class="k">let</span> <span class="nv">node</span> <span class="o">=</span> <span class="kt">Node</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="n">node</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">?</span><span class="o">.</span><span class="n">next</span>
            <span class="n">tmp</span><span class="p">?</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">node</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="c1">//说明index太大，还没到，链表就走完了</span>
            <span class="k">self</span><span class="o">.</span><span class="nf">append</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="n">value</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>功能</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//left和right是已经排好序的链表</span>
    <span class="kd">func</span> <span class="nf">bindTwoLink</span><span class="p">(</span><span class="n">firstList</span> <span class="nv">left</span><span class="p">:</span> <span class="kt">IntLinkList</span><span class="p">,</span> <span class="n">second</span> <span class="nv">right</span><span class="p">:</span> <span class="kt">IntLinkList</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">IntLinkList</span> <span class="p">{</span>
        <span class="k">guard</span> <span class="o">!</span><span class="n">left</span><span class="o">.</span><span class="n">isEmpty</span> <span class="k">else</span> <span class="p">{</span><span class="k">return</span> <span class="n">right</span><span class="p">}</span>
        
        <span class="k">guard</span> <span class="o">!</span><span class="n">left</span><span class="o">.</span><span class="n">isEmpty</span> <span class="k">else</span> <span class="p">{</span><span class="k">return</span> <span class="n">right</span><span class="p">}</span>
        
        <span class="k">let</span> <span class="nv">list</span> <span class="o">=</span> <span class="kt">IntLinkList</span><span class="p">()</span>
        
        <span class="k">var</span> <span class="nv">currentLeft</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="n">head</span>
        <span class="k">var</span> <span class="nv">currentRight</span> <span class="o">=</span> <span class="n">right</span><span class="o">.</span><span class="n">head</span>
        
        <span class="k">if</span> <span class="k">let</span> <span class="nv">leftNode</span> <span class="o">=</span> <span class="n">currentLeft</span> <span class="p">,</span> <span class="k">let</span> <span class="nv">rightNode</span> <span class="o">=</span> <span class="n">currentRight</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">leftNode</span><span class="o">.</span><span class="n">value</span> <span class="o">&lt;</span> <span class="n">rightNode</span><span class="o">.</span><span class="n">value</span> <span class="p">{</span>
                <span class="n">list</span><span class="o">.</span><span class="n">head</span> <span class="o">=</span> <span class="n">leftNode</span>
                <span class="n">currentLeft</span> <span class="o">=</span> <span class="n">leftNode</span><span class="o">.</span><span class="n">next</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">list</span><span class="o">.</span><span class="n">head</span> <span class="o">=</span> <span class="n">rightNode</span>
                <span class="n">currentRight</span> <span class="o">=</span> <span class="n">rightNode</span><span class="o">.</span><span class="n">next</span>
            <span class="p">}</span>
            <span class="n">list</span><span class="o">.</span><span class="n">tail</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="n">head</span>
        <span class="p">}</span>
        
        <span class="k">while</span> <span class="k">let</span> <span class="nv">leftNode</span> <span class="o">=</span> <span class="n">currentLeft</span><span class="p">,</span> <span class="k">let</span> <span class="nv">rightNode</span> <span class="o">=</span> <span class="n">currentRight</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">leftNode</span><span class="o">.</span><span class="n">value</span> <span class="o">&lt;</span> <span class="n">rightNode</span><span class="o">.</span><span class="n">value</span> <span class="p">{</span>
                <span class="n">list</span><span class="o">.</span><span class="n">tail</span><span class="p">?</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">leftNode</span>
                <span class="n">currentLeft</span> <span class="o">=</span> <span class="n">leftNode</span><span class="o">.</span><span class="n">next</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">list</span><span class="o">.</span><span class="n">tail</span><span class="p">?</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">rightNode</span>
                <span class="n">currentRight</span> <span class="o">=</span> <span class="n">rightNode</span><span class="o">.</span><span class="n">next</span>
            <span class="p">}</span>
            <span class="n">list</span><span class="o">.</span><span class="n">tail</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="n">tail</span><span class="p">?</span><span class="o">.</span><span class="n">next</span>
        <span class="p">}</span>
        
        <span class="c1">//此处还有最后两个尾端没有遍历到</span>
        <span class="k">if</span> <span class="k">let</span> <span class="nv">leftNode</span> <span class="o">=</span> <span class="n">currentLeft</span> <span class="p">{</span><span class="n">list</span><span class="o">.</span><span class="n">tail</span><span class="p">?</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">leftNode</span><span class="p">}</span>
        <span class="k">if</span> <span class="k">let</span> <span class="nv">rightNode</span> <span class="o">=</span> <span class="n">currentRight</span> <span class="p">{</span><span class="n">list</span><span class="o">.</span><span class="n">tail</span><span class="p">?</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">rightNode</span><span class="p">}</span>
        
        <span class="k">return</span> <span class="n">list</span>
    <span class="p">}</span>
</code></pre></div></div>

<p>测试：</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">list1</span> <span class="o">=</span> <span class="kt">IntLinkList</span><span class="p">()</span>
<span class="n">list1</span><span class="o">.</span><span class="nf">append</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">list1</span><span class="o">.</span><span class="nf">append</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">list1</span><span class="o">.</span><span class="nf">append</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="mi">4</span><span class="p">)</span>
<span class="n">list1</span><span class="o">.</span><span class="nf">append</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="mi">5</span><span class="p">)</span>
<span class="n">list1</span><span class="o">.</span><span class="nf">append</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="mi">22</span><span class="p">)</span>

<span class="k">let</span> <span class="nv">list2</span> <span class="o">=</span> <span class="kt">IntLinkList</span><span class="p">()</span>
<span class="n">list2</span><span class="o">.</span><span class="nf">append</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">list2</span><span class="o">.</span><span class="nf">append</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">list2</span><span class="o">.</span><span class="nf">append</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="mi">4</span><span class="p">)</span>
<span class="n">list2</span><span class="o">.</span><span class="nf">append</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="mi">5</span><span class="p">)</span>
<span class="n">list2</span><span class="o">.</span><span class="nf">append</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="mi">6</span><span class="p">)</span>
<span class="n">list2</span><span class="o">.</span><span class="nf">append</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="mi">7</span><span class="p">)</span>
<span class="n">list2</span><span class="o">.</span><span class="nf">append</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="mi">8</span><span class="p">)</span>

<span class="k">let</span> <span class="nv">list</span> <span class="o">=</span> <span class="n">solution</span><span class="o">.</span><span class="nf">bindTwoLink</span><span class="p">(</span><span class="nv">firstList</span><span class="p">:</span> <span class="n">list1</span><span class="p">,</span> <span class="nv">second</span><span class="p">:</span> <span class="n">list2</span><span class="p">)</span>

<span class="k">var</span> <span class="nv">head</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="n">head</span>

<span class="k">while</span> <span class="n">head</span><span class="p">?</span><span class="o">.</span><span class="n">next</span> <span class="o">!=</span> <span class="kc">nil</span>  <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="n">head</span><span class="o">!.</span><span class="n">value</span> <span class="k">as</span> <span class="kt">Any</span><span class="p">,</span> <span class="nv">terminator</span><span class="p">:</span> <span class="s">" "</span><span class="p">)</span>
    <span class="n">head</span> <span class="o">=</span> <span class="n">head</span><span class="o">!.</span><span class="n">next</span>
<span class="p">}</span>

<span class="nf">print</span><span class="p">(</span><span class="n">head</span><span class="o">!.</span><span class="n">value</span><span class="p">)</span>
</code></pre></div></div>

<p>结果：</p>
<blockquote>
  <p>1 1 2 3 4 4 5 5 6 7 8 22</p>
</blockquote>

<h3 id="反转链表">反转链表</h3>

<ul>
  <li>示例</li>
</ul>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL
输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL
</code></pre></div></div>

<ul>
  <li>思路</li>
</ul>

<p>将节点的next指向pre即可</p>

<ul>
  <li>解法</li>
</ul>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">reverseList</span><span class="p">(</span><span class="n">_</span> <span class="nv">head</span><span class="p">:</span> <span class="kt">Node</span><span class="o">&lt;</span><span class="kt">Int</span><span class="o">&gt;</span><span class="p">?)</span> <span class="o">-&gt;</span> <span class="kt">Node</span><span class="o">&lt;</span><span class="kt">Int</span><span class="o">&gt;</span><span class="p">?</span> <span class="p">{</span>
  <span class="k">var</span> <span class="nv">cur</span> <span class="o">=</span> <span class="n">head</span>
  <span class="k">var</span> <span class="nv">last</span><span class="p">:</span> <span class="kt">Node</span><span class="o">&lt;</span><span class="kt">Int</span><span class="o">&gt;</span><span class="p">?</span>
  <span class="k">var</span> <span class="nv">next</span><span class="p">:</span> <span class="kt">Node</span><span class="o">&lt;</span><span class="kt">Int</span><span class="o">&gt;</span><span class="p">?</span>

  <span class="k">while</span> <span class="p">(</span><span class="n">cur</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">next</span> <span class="o">=</span> <span class="n">cur</span><span class="p">?</span><span class="o">.</span><span class="n">next</span>
    <span class="n">cur</span><span class="p">?</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">last</span>
    <span class="n">last</span> <span class="o">=</span> <span class="n">cur</span>
    <span class="n">cur</span> <span class="o">=</span> <span class="n">next</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">last</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>结果</li>
</ul>

<blockquote>
  <p><strong>let</strong> <strong>list3</strong> <strong>=</strong> <strong>IntLinkList</strong><strong>()</strong></p>

  <p><strong>list3</strong><strong>.</strong><strong>append</strong><strong>(value:</strong> <strong>10</strong><strong>)</strong></p>

  <p><strong>list3</strong><strong>.</strong><strong>append</strong><strong>(value:</strong> <strong>12</strong><strong>)</strong></p>

  <p><strong>list3</strong><strong>.</strong><strong>append</strong><strong>(value:</strong> <strong>4</strong><strong>)</strong></p>

  <p><strong>list3</strong><strong>.</strong><strong>append</strong><strong>(value:</strong> <strong>5</strong><strong>)</strong></p>

  <p><strong>list3</strong><strong>.</strong><strong>append</strong><strong>(value:</strong> <strong>2</strong><strong>)</strong></p>

  <p><strong>var</strong> <strong>prev</strong> <strong>=</strong> <strong>solution</strong><strong>.</strong><strong>reverseList</strong><strong>(</strong><strong>list3</strong><strong>.</strong><strong>head</strong><strong>)</strong></p>

  <p><strong>while</strong> <strong>prev</strong><strong>?.</strong><strong>next</strong> <strong>!=</strong> <strong>nil</strong> <strong>{</strong></p>

  <p><strong>print</strong><strong>(</strong><strong>prev</strong><strong>!.</strong><strong>value</strong> <strong>as</strong> <strong>Any</strong><strong>, terminator:</strong> <strong>” “</strong><strong>)</strong></p>

  <p><strong>prev</strong> <strong>=</strong> <strong>prev</strong><strong>!.</strong><strong>next</strong></p>

  <p><strong>}</strong></p>

  <p><strong>print</strong><strong>(</strong><strong>prev</strong><strong>!.</strong><strong>value</strong><strong>)</strong></p>
</blockquote>

<blockquote>
  <p><strong>2 5 4 12 10</strong></p>
</blockquote>]]></content><author><name>Cambria Yang</name><email>cambriayang@qq.com</email></author><category term="Algorithm" /><category term="算法" /><summary type="html"><![CDATA[一些算法举例 链表 合并两个排过序的链表，并将其作为新链表 示例： 输入：1-＞2-＞4,1-＞3-＞4 输出：1-＞1-＞2-＞3-＞4-＞4 思路： 很简单，就是链表遍历，然后变换next就可以了 代码实现： 链表构造 class Node&lt;T&gt; { var value: T var next: Node&lt;T&gt;? init(_ val: T) { self.value = val self.next = nil } } class IntLinkList { var head: Node&lt;Int&gt;? var tail: Node&lt;Int&gt;? init() { tail = nil head = tail } var isEmpty: Bool { get { return head == nil } } func append(value: Int) { let node = Node(value) if tail == nil { tail = node head = tail } else { tail!.next = node tail = tail!.next } } func appendToHead(value: Int) { let node = Node(value) if head == nil { head = node tail = head } else { node.next = head?.next head = node } } func insertAt(index: Int, value: Int) { if index == 0 { self.appendToHead(value: value) } var tmp = head var i: Int = 0 while i != index &amp;&amp; tmp == nil { tmp = tmp?.next i+=1 } if i == index { let node = Node(value) node.next = tmp?.next tmp?.next = node } else { //说明index太大，还没到，链表就走完了 self.append(value: value) } } } 功能 //left和right是已经排好序的链表 func bindTwoLink(firstList left: IntLinkList, second right: IntLinkList) -&gt; IntLinkList { guard !left.isEmpty else {return right} guard !left.isEmpty else {return right} let list = IntLinkList() var currentLeft = left.head var currentRight = right.head if let leftNode = currentLeft , let rightNode = currentRight { if leftNode.value &lt; rightNode.value { list.head = leftNode currentLeft = leftNode.next } else { list.head = rightNode currentRight = rightNode.next } list.tail = list.head } while let leftNode = currentLeft, let rightNode = currentRight { if leftNode.value &lt; rightNode.value { list.tail?.next = leftNode currentLeft = leftNode.next } else { list.tail?.next = rightNode currentRight = rightNode.next } list.tail = list.tail?.next } //此处还有最后两个尾端没有遍历到 if let leftNode = currentLeft {list.tail?.next = leftNode} if let rightNode = currentRight {list.tail?.next = rightNode} return list } 测试： let list1 = IntLinkList() list1.append(value: 1) list1.append(value: 2) list1.append(value: 4) list1.append(value: 5) list1.append(value: 22) let list2 = IntLinkList() list2.append(value: 1) list2.append(value: 3) list2.append(value: 4) list2.append(value: 5) list2.append(value: 6) list2.append(value: 7) list2.append(value: 8) let list = solution.bindTwoLink(firstList: list1, second: list2) var head = list.head while head?.next != nil { print(head!.value as Any, terminator: " ") head = head!.next } print(head!.value) 结果： 1 1 2 3 4 4 5 5 6 7 8 22 反转链表 示例 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL 输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL 思路 将节点的next指向pre即可 解法 func reverseList(_ head: Node&lt;Int&gt;?) -&gt; Node&lt;Int&gt;? { var cur = head var last: Node&lt;Int&gt;? var next: Node&lt;Int&gt;? while (cur != nil) { next = cur?.next cur?.next = last last = cur cur = next } return last } 结果 let list3 = IntLinkList() list3.append(value: 10) list3.append(value: 12) list3.append(value: 4) list3.append(value: 5) list3.append(value: 2) var prev = solution.reverseList(list3.head) while prev?.next != nil { print(prev!.value as Any, terminator: ” “) prev = prev!.next } print(prev!.value) 2 5 4 12 10]]></summary></entry><entry><title type="html">数组算法</title><link href="http://localhost:4000/algorithm/2022/03/08/%E6%95%B0%E7%BB%84%E7%AE%97%E6%B3%95.html" rel="alternate" type="text/html" title="数组算法" /><published>2022-03-08T04:00:00+00:00</published><updated>2022-03-08T04:00:00+00:00</updated><id>http://localhost:4000/algorithm/2022/03/08/%E6%95%B0%E7%BB%84%E7%AE%97%E6%B3%95</id><content type="html" xml:base="http://localhost:4000/algorithm/2022/03/08/%E6%95%B0%E7%BB%84%E7%AE%97%E6%B3%95.html"><![CDATA[<p>一些算法举例</p>

<h2 id="数组">数组</h2>

<h3 id="寻找中间数">寻找中间数</h3>

<p>给出一个无序数组，求出一个数，使得其左边的数都小于它，右边的数都大于等于它。要求时间复杂度为n</p>

<ul>
  <li>示例</li>
</ul>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code>输入：[4,3,2,7,9,10,11,10]
输出：7,9
</code></pre></div></div>

<ul>
  <li>思路</li>
</ul>

<p>两次遍历，第一次遍历，记录下每个位置和它之后的那个元素的最小值（当然这个最小值会一直更新，所以这一次遍历完，就是整个数组的最小值），需要一个n的数组，存放的是这个位置和它后面一个位置的较小值，当然如果已经遇到了，最小值，因为会和最小值进行判断，所以后续这个新的数组里存放的都是这个最小值了。</p>

<p>第二次遍历是正常的从左向右遍历，寻找左边大且比右边小的数，也会记住一个最大值。</p>

<ul>
  <li>解法</li>
</ul>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">findTheMidNumber</span><span class="p">(</span><span class="n">_</span> <span class="nv">data</span><span class="p">:</span> <span class="p">[</span><span class="kt">Int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span> <span class="p">{</span>
  <span class="k">var</span> <span class="nv">res</span> <span class="o">=</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]()</span>

  <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span><span class="k">return</span> <span class="n">res</span><span class="p">}</span>
  <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">count</span> <span class="o">&lt;=</span> <span class="mi">2</span> <span class="p">{</span><span class="k">return</span> <span class="n">res</span><span class="p">}</span>

  <span class="k">var</span> <span class="nv">rightMin</span> <span class="o">=</span> <span class="p">[</span><span class="kt">Int</span><span class="p">](</span><span class="nv">repeating</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="nv">count</span><span class="p">:</span> <span class="n">data</span><span class="o">.</span><span class="n">count</span><span class="p">)</span>
  <span class="k">var</span> <span class="nv">r_min</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">data</span><span class="o">.</span><span class="n">count</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

  <span class="c1">//从右往左，寻找每个位置及其之后的最小数</span>
  <span class="k">for</span> <span class="n">i</span> <span class="nf">in</span> <span class="p">(</span><span class="mi">0</span><span class="o">..&lt;</span><span class="n">data</span><span class="o">.</span><span class="n">count</span><span class="p">)</span><span class="o">.</span><span class="nf">reversed</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">r_min</span> <span class="p">{</span>
      <span class="n">r_min</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="p">}</span>
    <span class="n">rightMin</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">r_min</span>
  <span class="p">}</span>

  <span class="c1">//从左往右，寻找左边大且比右边小的数</span>
  <span class="k">var</span> <span class="nv">l_max</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
  <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..&lt;</span><span class="n">data</span><span class="o">.</span><span class="n">count</span><span class="o">-</span><span class="mi">1</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">l_max</span> <span class="p">{</span>
      <span class="n">l_max</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
      <span class="k">if</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">rightMin</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="p">{</span>
        <span class="n">res</span><span class="o">.</span><span class="nf">append</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="nf">print</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">res</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>测试</li>
</ul>

<blockquote>
  <p>_ = findTheMidNumber([4,3,2,7,9,10,11,10])</p>

  <p><strong>[7, 9]</strong></p>
</blockquote>

<h3 id="三数之和">三数之和</h3>

<p>一个包含n个整数的数组nums，判断nums中是否存在三个元素a，b，c，使得a+b+c=0？请找出所有满足条件且不重复的三元组</p>

<p><em>注意</em>：不可以包含重复的三元组</p>

<ul>
  <li>示例</li>
</ul>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code>输入：nums=[-1,0,1,2,-1,-4]
输出：[[-1,0,1], [-1,-1,2]]
</code></pre></div></div>

<ul>
  <li>思路</li>
</ul>

<p>除非三个数全是0，否则肯定会有正数和负数，所以假定选择一个数，然后再去找另外两个数，这样只要找到两个数且和为第一个选择的数的相反数。</p>

<ol>
  <li>从小到大排序</li>
  <li>循环</li>
  <li>如果最小的数大于0，直接结束（因为必须要有负数）</li>
</ol>

<p><img src="http://localhost:4000/assets/images/posts/leetcode_three_sums.jpg" alt="sort_algorithm" /></p>

<p>相当于两数之和问题：a+b=target，因为是排好序的，选定了i，那么j+k需要是i的相反数，如果j+k&lt;target，则j++,否则k–，j和k是右边数组的首末两端</p>

<ul>
  <li>解法</li>
</ul>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">threeSum</span><span class="p">(</span><span class="n">_</span> <span class="nv">nums</span><span class="p">:</span> <span class="p">[</span><span class="kt">Int</span><span class="p">])</span><span class="o">-&gt;</span><span class="p">[[</span><span class="kt">Int</span><span class="p">]]?</span> <span class="p">{</span>
  <span class="k">var</span> <span class="nv">tempNums</span> <span class="o">=</span> <span class="n">nums</span>

  <span class="k">if</span> <span class="n">nums</span><span class="o">.</span><span class="n">count</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="p">{</span><span class="k">return</span> <span class="kc">nil</span><span class="p">}</span>
  <span class="c1">//排序</span>
  <span class="nf">insertSort</span><span class="p">(</span><span class="nv">arr</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">tempNums</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">tempNums</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">{</span><span class="k">return</span> <span class="kc">nil</span><span class="p">}</span>

  <span class="k">var</span> <span class="nv">res</span> <span class="o">=</span> <span class="p">[[</span><span class="kt">Int</span><span class="p">]]()</span>

  <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..&lt;</span><span class="n">tempNums</span><span class="o">.</span><span class="n">count</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">target</span> <span class="o">=</span> <span class="o">-</span><span class="n">tempNums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

    <span class="k">var</span> <span class="nv">j</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span>
    <span class="k">var</span> <span class="nv">k</span> <span class="o">=</span> <span class="n">tempNums</span><span class="o">.</span><span class="n">count</span><span class="o">-</span><span class="mi">1</span>

    <span class="k">while</span> <span class="n">k</span><span class="o">-</span><span class="n">j</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
      <span class="k">let</span> <span class="nv">numj</span> <span class="o">=</span> <span class="n">tempNums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
      <span class="k">let</span> <span class="nv">numk</span> <span class="o">=</span> <span class="n">tempNums</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>

      <span class="k">if</span> <span class="n">numj</span><span class="o">+</span><span class="n">numk</span> <span class="o">&lt;</span> <span class="n">target</span> <span class="p">{</span>
        <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
      <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">numj</span><span class="o">+</span><span class="n">numk</span> <span class="o">&gt;</span> <span class="n">target</span> <span class="p">{</span>
        <span class="n">k</span> <span class="o">-=</span> <span class="mi">1</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c1">//找到，返回i，j，k</span>
        <span class="n">res</span><span class="o">.</span><span class="nf">append</span><span class="p">([</span><span class="n">tempNums</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">numj</span><span class="p">,</span><span class="n">numk</span><span class="p">])</span>
        <span class="k">break</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">res</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>测试</li>
</ul>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">res</span> <span class="o">=</span> <span class="n">solution</span><span class="o">.</span><span class="nf">threeSum</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">4</span><span class="p">])</span>
</code></pre></div></div>

<ul>
  <li>结果</li>
</ul>

<blockquote>
  <p>[[-1, -1, 2], [-1, 0, 1]]</p>
</blockquote>

<h3 id="岛屿最大面积">岛屿最大面积</h3>

<p>给定一个包含了一些 <code class="language-plaintext highlighter-rouge">0</code> 和 <code class="language-plaintext highlighter-rouge">1</code> 的非空二维数组 <code class="language-plaintext highlighter-rouge">grid</code> 。</p>

<p>一个 <strong>岛屿</strong> 是由一些相邻的 <code class="language-plaintext highlighter-rouge">1</code> (代表土地) 构成的组合，这里的「相邻」要求两个 <code class="language-plaintext highlighter-rouge">1</code> 必须在水平或者竖直方向上相邻。你可以假设 <code class="language-plaintext highlighter-rouge">grid</code> 的四个边缘都被 <code class="language-plaintext highlighter-rouge">0</code>（代表水）包围着。</p>

<p>找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为 <code class="language-plaintext highlighter-rouge">0</code> 。)</p>

<ul>
  <li>示例</li>
</ul>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[[0,0,1,0,0,0,0,1,0,0,0,0,0],
 [0,0,0,0,0,0,0,1,1,1,0,0,0],
 [0,1,1,0,1,0,0,0,0,0,0,0,0],
 [0,1,0,0,1,1,0,0,1,0,1,0,0],
 [0,1,0,0,1,1,0,0,1,1,1,0,0],
 [0,0,0,0,0,0,0,0,0,0,1,0,0],
 [0,0,0,0,0,0,0,1,1,1,0,0,0],
 [0,0,0,0,0,0,0,1,1,0,0,0,0]]
</code></pre></div></div>

<p>对于上面这个给定矩阵应返回 <code class="language-plaintext highlighter-rouge">6</code>。注意答案不应该是 <code class="language-plaintext highlighter-rouge">11</code> ，因为岛屿只能包含水平或垂直的四个方向的 <code class="language-plaintext highlighter-rouge">1</code> 。</p>

<p><strong>注意:</strong> 给定的矩阵<code class="language-plaintext highlighter-rouge">grid</code> 的长度和宽度都不超过 50。</p>

<ul>
  <li>解法</li>
</ul>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">_</span> <span class="nv">i</span><span class="p">:</span> <span class="kt">Int</span><span class="p">,</span><span class="n">_</span> <span class="nv">j</span><span class="p">:</span> <span class="kt">Int</span><span class="p">,</span><span class="n">_</span> <span class="nv">m</span><span class="p">:</span> <span class="kt">Int</span><span class="p">,</span><span class="n">_</span> <span class="nv">n</span><span class="p">:</span><span class="kt">Int</span><span class="p">,</span><span class="n">_</span> <span class="nv">grid</span><span class="p">:</span> <span class="k">inout</span> <span class="p">[[</span><span class="kt">Int</span><span class="p">]],</span><span class="n">_</span> <span class="nv">tempArea</span><span class="p">:</span> <span class="k">inout</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="p">{</span>
  <span class="k">if</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">0</span> <span class="o">||</span> <span class="n">i</span><span class="o">&gt;=</span><span class="n">m</span> <span class="o">||</span> <span class="n">j</span><span class="o">&lt;</span><span class="mi">0</span> <span class="o">||</span> <span class="n">j</span><span class="o">&gt;=</span><span class="n">n</span> <span class="o">||</span> <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">tempArea</span>
  <span class="p">}</span>
  <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="n">tempArea</span> <span class="o">+=</span> <span class="mi">1</span>
  <span class="n">tempArea</span> <span class="o">=</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">grid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tempArea</span><span class="p">)</span>
  <span class="n">tempArea</span> <span class="o">=</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">grid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tempArea</span><span class="p">)</span>
  <span class="n">tempArea</span> <span class="o">=</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">grid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tempArea</span><span class="p">)</span>
  <span class="n">tempArea</span> <span class="o">=</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">grid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tempArea</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">tempArea</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">maxAreaOfIsland</span><span class="p">(</span><span class="n">_</span> <span class="nv">grid</span><span class="p">:</span> <span class="p">[[</span><span class="kt">Int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="p">{</span>
  <span class="k">var</span> <span class="nv">tempGrid</span> <span class="o">=</span> <span class="n">grid</span>
  <span class="k">var</span> <span class="nv">area</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="k">let</span> <span class="nv">m</span> <span class="o">=</span> <span class="n">tempGrid</span><span class="o">.</span><span class="n">count</span>
  <span class="k">var</span> <span class="nv">n</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="k">var</span> <span class="nv">islandMax</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..&lt;</span><span class="n">m</span> <span class="p">{</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">tempGrid</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">count</span>
    <span class="k">for</span> <span class="n">j</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..&lt;</span><span class="n">n</span> <span class="p">{</span>
      <span class="n">area</span> <span class="o">=</span> <span class="mi">0</span>
      <span class="n">area</span> <span class="o">=</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tempGrid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">area</span><span class="p">)</span>
      <span class="n">islandMax</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span><span class="n">islandMax</span><span class="p">,</span> <span class="n">area</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">islandMax</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="最长递增子序列非连续">最长递增子序列（非连续）</h3>

<p>给定一个未经排序的整数数组，找到最长递增子序列</p>

<ul>
  <li>示例</li>
</ul>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code>输入：10，9，2，5，3，7，101，18，20
输出：2，3，7，18，20
</code></pre></div></div>

<ul>
  <li>思路</li>
</ul>

<p>一个巧妙的方法，一般来说第一遍for i-&gt;n-1(n),第二遍for j-&gt;i-1(n).这里可以加速的是第二个循环，因为第一个循环肯定是不能加速的，所以只能加速第二个循环。</p>

<p>可以维护一个数组LIS（最后的结果数组），一开始数组是空的，当第一个数10进来，毫无疑问，它就是最长递增子序列，9进来的时候，如果它比10大则直接append，否则用二分查找法去找到数组中比它大的最小的数，<strong>替换掉</strong>，</p>

<p>因为我们相当于要不断让更小的数进来，所以很好理解。这个复杂度是logn的，所以整体是nlogn的时间复杂度。</p>

<ul>
  <li>实现</li>
</ul>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
</code></pre></div></div>

<h3 id="最长连续递增序列">最长连续递增序列</h3>

<p>给定一个未经排序的整数数组，找到最长且连续的递增序列，并返回该序列的长度。</p>

<ul>
  <li>示例</li>
</ul>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code>输入：[1,3,5,4,7]
输出：3
解释：最长递增序列是[1,3,5], 长度为3

输入：[2,2,2,2]
输出：1
解释：最长连续递增序列是[2], 长度为1
</code></pre></div></div>

<p><strong>注</strong>：数组长度不超过10000</p>

<ul>
  <li>思路
    <ul>
      <li>count 为当前元素峰值，ans为最大峰值</li>
      <li>初始化 count=1</li>
      <li>从0位置开始遍历，遍历是根据前后元素状态判断是否递增，递增则count++，递减count=1</li>
      <li>如果count&gt;ans，则更新ans</li>
      <li>直到循环结束</li>
    </ul>
  </li>
  <li>解法</li>
</ul>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">findLengthOfLCIS</span><span class="p">(</span><span class="n">_</span> <span class="nv">nums</span><span class="p">:</span> <span class="p">[</span><span class="kt">Int</span><span class="p">])</span><span class="o">-&gt;</span><span class="kt">Int</span> <span class="p">{</span>
  <span class="k">if</span> <span class="n">nums</span><span class="o">.</span><span class="n">count</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="p">{</span><span class="k">return</span> <span class="n">nums</span><span class="o">.</span><span class="n">count</span><span class="p">}</span>
  <span class="k">var</span> <span class="nv">ans</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="k">var</span> <span class="nv">count</span> <span class="o">=</span> <span class="mi">1</span>

  <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..&lt;</span><span class="n">nums</span><span class="o">.</span><span class="n">count</span><span class="o">-</span><span class="mi">1</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">{</span>
      <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="n">count</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="p">}</span>

    <span class="n">ans</span> <span class="o">=</span> <span class="n">count</span><span class="o">&gt;</span><span class="n">ans</span> <span class="p">?</span> <span class="nv">count</span> <span class="p">:</span> <span class="n">ans</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">ans</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>结果</li>
</ul>

<blockquote>
  <p>print(solution.findLengthOfLCIS([1,3,5,4,7]))</p>

  <p>3</p>
</blockquote>

<h3 id="数组中的第k大的元素">数组中的第K大的元素</h3>

<p>在未排序的数组中找到第k大的元素。</p>

<ul>
  <li>示例</li>
</ul>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code>输入： [3,2,1,5,6,4], k=2
输出：5

输入： [3,2,3,1,2,4,5,5,6], k=4
输出：4
</code></pre></div></div>

<p>假设k总是有效的，且1&lt;=k&lt;=数组长度</p>

<ul>
  <li>思路</li>
</ul>

<p>改进快速排序算法，求得第k大的元素，不需要将快速排序完全进行完，只需要进行一遍的递归，如果q刚好是第k大，则打完收工。</p>

<ul>
  <li>解法</li>
</ul>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//寻找pivot的函数</span>
<span class="kd">func</span> <span class="nf">partition</span><span class="p">(</span><span class="nv">arr</span><span class="p">:</span> <span class="k">inout</span> <span class="p">[</span><span class="kt">Int</span><span class="p">],</span> <span class="nv">left</span><span class="p">:</span> <span class="kt">Int</span><span class="p">,</span> <span class="nv">right</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="p">{</span>
  <span class="k">let</span> <span class="nv">pivot</span> <span class="o">=</span> <span class="n">left</span>
  <span class="k">var</span> <span class="nv">index</span> <span class="o">=</span> <span class="n">pivot</span><span class="o">+</span><span class="mi">1</span>
  <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="n">index</span><span class="o">...</span><span class="n">right</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">pivot</span><span class="p">]</span> <span class="p">{</span>
      <span class="n">arr</span><span class="o">.</span><span class="nf">swapAt</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
      <span class="n">index</span><span class="o">+=</span><span class="mi">1</span>
      <span class="c1">//i和index都更新，以pivot为分隔，两边都冒泡，后面再将假设的pivot替换为真正的pivot，然后继续递归</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="c1">//此处相当于pivot需要更新</span>
  <span class="n">arr</span><span class="o">.</span><span class="nf">swapAt</span><span class="p">(</span><span class="n">pivot</span><span class="p">,</span> <span class="n">index</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">index</span><span class="o">-</span><span class="mi">1</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">findKthLargest</span><span class="p">(</span><span class="n">_</span> <span class="nv">nums</span><span class="p">:</span> <span class="k">inout</span> <span class="p">[</span><span class="kt">Int</span><span class="p">],</span> <span class="n">_</span> <span class="nv">k</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nf">quickSelect</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nums</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">nums</span><span class="o">.</span><span class="n">count</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">nums</span><span class="o">.</span><span class="n">count</span><span class="o">-</span><span class="n">k</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">quickSelect</span><span class="p">(</span><span class="n">_</span> <span class="nv">a</span><span class="p">:</span> <span class="k">inout</span> <span class="p">[</span><span class="kt">Int</span><span class="p">],</span> <span class="n">_</span> <span class="nv">l</span><span class="p">:</span> <span class="kt">Int</span><span class="p">,</span> <span class="n">_</span> <span class="nv">r</span><span class="p">:</span> <span class="kt">Int</span><span class="p">,</span> <span class="n">_</span> <span class="nv">index</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="p">{</span>
  <span class="k">let</span> <span class="nv">q</span> <span class="o">=</span> <span class="nf">partition</span><span class="p">(</span><span class="nv">arr</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="nv">left</span><span class="p">:</span> <span class="n">l</span><span class="p">,</span> <span class="nv">right</span><span class="p">:</span> <span class="n">r</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">q</span> <span class="o">==</span> <span class="n">index</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">a</span><span class="p">[</span><span class="n">q</span><span class="p">]</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">q</span><span class="o">&lt;</span><span class="n">index</span> <span class="p">?</span> <span class="nf">quickSelect</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="n">q</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span> <span class="p">:</span> <span class="nf">quickSelect</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">q</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>结果</li>
</ul>

<blockquote>
  <p>var nums = [3,2,3,1,2,4,5,5,6]</p>

  <p>let r10 = solution.findKthLargest(&amp;nums, 4)</p>

  <p>4</p>
</blockquote>

<h3 id="最长连续增序列">最长连续增序列</h3>

<p>给定一个未排序的整数数组，找出最长连续增序列的长度。</p>

<p>要求算法复杂度O（n）</p>

<ul>
  <li>示例</li>
</ul>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code>输入：[100,4,200,1,3,2]
输出：4
解释：最长连续序列是[1,2,3,4]。长度为4
</code></pre></div></div>

<ul>
  <li>思路</li>
</ul>

<p>使用hashmap来保存数组中已经遍历过的元素，key对应元素的值，value表示该元素所在的连续子数组的长度。如果hash中存在此元素，则遍历下一个元素。如果不存在，则看hashmap中是否存在在此元素的前一个元素，比如如果遍历到5时，看看hash中是否存在4，如果存在则取该连续子数组的子一个元素，将它value值+1，并将该元素放到hashmap中，value值与第一个元素值相同，都表示该连续子数组的长度。如果hashmap中存在的该元素遍历到5时，hashmap中是否存在6，将次元素加入到最后一个连续的子数组中，并且和2中一样，找到子数组的第一个和最后一个元素，将它们的value值更新为子数组的长度。</p>

<p>swift解法简单，先排好序，然后判断i-1的值+1是否等于i的值，是的话，则继续向后，否则，当前和记录的最大值比较，currentstreak=1初始化</p>

<ul>
  <li>解法</li>
</ul>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">longestConsecutive</span><span class="p">(</span><span class="n">_</span> <span class="nv">nums</span><span class="p">:</span> <span class="p">[</span><span class="kt">Int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="p">{</span>
  <span class="k">guard</span> <span class="n">nums</span><span class="o">.</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span> <span class="p">}</span>
  <span class="k">let</span> <span class="nv">nums</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="nf">sorted</span><span class="p">(){</span><span class="nv">$0</span> <span class="o">&lt;</span> <span class="nv">$1</span><span class="p">}</span>
  
  <span class="k">var</span> <span class="nv">longestStreak</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="k">var</span> <span class="nv">currentStreak</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">1</span><span class="o">..&lt;</span><span class="n">nums</span><span class="o">.</span><span class="n">count</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="p">{</span>
      <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">{</span>
        <span class="n">currentStreak</span> <span class="o">+=</span> <span class="mi">1</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">longestStreak</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span><span class="n">longestStreak</span><span class="p">,</span> <span class="n">currentStreak</span><span class="p">)</span>
        <span class="n">currentStreak</span> <span class="o">=</span> <span class="mi">1</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nf">max</span><span class="p">(</span><span class="n">longestStreak</span><span class="p">,</span> <span class="n">currentStreak</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="按频率对整数数组进行排序">按频率对整数数组进行排序</h3>

<p>应该按频率对数组排序，如果相同的频率则对整数排序</p>

<ul>
  <li>示例</li>
</ul>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code>输入：1 1 1 1 1 2 1 2 3 3 3 3 3
输出：1 1 1 1 1 1 3 3 3 3 3 2 2
</code></pre></div></div>

<ul>
  <li>思路</li>
</ul>

<p>用hashmap存放数字出现的次数，然后对hashmap的value进行排序</p>

<p>代码实现：</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">sortFrequencyArray</span><span class="p">(</span><span class="nv">source</span><span class="p">:</span> <span class="p">[</span><span class="kt">Int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span> <span class="p">{</span>
  <span class="k">if</span> <span class="n">source</span><span class="o">.</span><span class="n">count</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">source</span>
  <span class="p">}</span>

  <span class="c1">//key是数字，value是出现的频率</span>
  <span class="k">var</span> <span class="nv">hashTable</span><span class="p">:</span> <span class="kt">Dictionary</span><span class="o">&lt;</span><span class="kt">Int</span><span class="p">,</span> <span class="kt">Int</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">[</span><span class="kt">Int</span><span class="p">:</span><span class="kt">Int</span><span class="p">]()</span>
  <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..&lt;</span><span class="n">source</span><span class="o">.</span><span class="n">count</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">source</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">hashTable</span><span class="o">.</span><span class="n">keys</span><span class="o">.</span><span class="nf">contains</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">//更新数值</span>
      <span class="k">var</span> <span class="nv">value</span> <span class="o">=</span> <span class="n">hashTable</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
      <span class="n">value</span><span class="o">!</span> <span class="o">+=</span> <span class="mi">1</span>
      <span class="n">hashTable</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="n">hashTable</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">let</span> <span class="nv">values</span> <span class="o">=</span> <span class="n">hashTable</span><span class="o">.</span><span class="n">sorted</span><span class="p">{</span>
    <span class="k">if</span> <span class="nv">$0</span><span class="o">.</span><span class="mi">1</span> <span class="o">==</span> <span class="nv">$1</span><span class="o">.</span><span class="mi">1</span> <span class="p">{</span>
      <span class="c1">//如果value（频率）相等，则按照key倒序</span>
      <span class="k">return</span> <span class="nv">$0</span><span class="o">.</span><span class="mi">0</span> <span class="o">&gt;</span> <span class="nv">$1</span><span class="o">.</span><span class="mi">0</span>
    <span class="p">}</span>

    <span class="c1">//如果value（频率）不等，则按照value倒序</span>
    <span class="k">return</span> <span class="nv">$0</span><span class="o">.</span><span class="mi">1</span> <span class="o">&gt;</span> <span class="nv">$1</span><span class="o">.</span><span class="mi">1</span>
  <span class="p">}</span>

  <span class="k">var</span> <span class="nv">result</span><span class="p">:</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]()</span>

  <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..&lt;</span><span class="n">values</span><span class="o">.</span><span class="n">count</span> <span class="p">{</span>
    <span class="k">for</span> <span class="n">_</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..&lt;</span><span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="mi">1</span> <span class="p">{</span>
      <span class="n">result</span><span class="o">.</span><span class="nf">append</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="mi">0</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">result</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>测试</li>
</ul>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">array6</span> <span class="o">=</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
<span class="k">let</span> <span class="nv">array7</span> <span class="o">=</span> <span class="n">solution</span><span class="o">.</span><span class="nf">sortFrequencyArray</span><span class="p">(</span><span class="nv">source</span><span class="p">:</span> <span class="n">array6</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">array7</span><span class="p">)</span>
</code></pre></div></div>

<ul>
  <li>结果</li>
</ul>

<blockquote>
  <p>[8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 1, 1, 1, 1, 1, 1, 7, 7, 6, 6, 5, 5, 4, 4, 3, 3, 2, 2]</p>
</blockquote>]]></content><author><name>Cambria Yang</name><email>cambriayang@qq.com</email></author><category term="Algorithm" /><category term="算法" /><summary type="html"><![CDATA[一些算法举例 数组 寻找中间数 给出一个无序数组，求出一个数，使得其左边的数都小于它，右边的数都大于等于它。要求时间复杂度为n 示例 输入：[4,3,2,7,9,10,11,10] 输出：7,9 思路 两次遍历，第一次遍历，记录下每个位置和它之后的那个元素的最小值（当然这个最小值会一直更新，所以这一次遍历完，就是整个数组的最小值），需要一个n的数组，存放的是这个位置和它后面一个位置的较小值，当然如果已经遇到了，最小值，因为会和最小值进行判断，所以后续这个新的数组里存放的都是这个最小值了。 第二次遍历是正常的从左向右遍历，寻找左边大且比右边小的数，也会记住一个最大值。 解法 func findTheMidNumber(_ data: [Int]) -&gt; [Int] { var res = [Int]() if data.count == 0 {return res} if data.count &lt;= 2 {return res} var rightMin = [Int](repeating: 0, count: data.count) var r_min = data[data.count-1] //从右往左，寻找每个位置及其之后的最小数 for i in (0..&lt;data.count).reversed() { if data[i] &lt; r_min { r_min = data[i] } rightMin[i] = r_min } //从左往右，寻找左边大且比右边小的数 var l_max = data[0] for i in 0..&lt;data.count-1 { if data[i] &gt; l_max { l_max = data[i] if data[i] &lt; rightMin[i+1] { res.append(data[i]) } } } print(res) return res } 测试 _ = findTheMidNumber([4,3,2,7,9,10,11,10]) [7, 9] 三数之和 一个包含n个整数的数组nums，判断nums中是否存在三个元素a，b，c，使得a+b+c=0？请找出所有满足条件且不重复的三元组 注意：不可以包含重复的三元组 示例 输入：nums=[-1,0,1,2,-1,-4] 输出：[[-1,0,1], [-1,-1,2]] 思路 除非三个数全是0，否则肯定会有正数和负数，所以假定选择一个数，然后再去找另外两个数，这样只要找到两个数且和为第一个选择的数的相反数。 从小到大排序 循环 如果最小的数大于0，直接结束（因为必须要有负数） 相当于两数之和问题：a+b=target，因为是排好序的，选定了i，那么j+k需要是i的相反数，如果j+k&lt;target，则j++,否则k–，j和k是右边数组的首末两端 解法 func threeSum(_ nums: [Int])-&gt;[[Int]]? { var tempNums = nums if nums.count &lt;= 0 {return nil} //排序 insertSort(arr: &amp;tempNums) if tempNums[0] &gt; 0 {return nil} var res = [[Int]]() for i in 0..&lt;tempNums.count { let target = -tempNums[i] var j = i+1 var k = tempNums.count-1 while k-j &gt; 0 { let numj = tempNums[j] let numk = tempNums[k] if numj+numk &lt; target { j += 1 } else if numj+numk &gt; target { k -= 1 } else { //找到，返回i，j，k res.append([tempNums[i],numj,numk]) break } } } return res } 测试 let res = solution.threeSum([-1,0,1,2,-1,-4]) 结果 [[-1, -1, 2], [-1, 0, 1]] 岛屿最大面积 给定一个包含了一些 0 和 1 的非空二维数组 grid 。 一个 岛屿 是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在水平或者竖直方向上相邻。你可以假设 grid 的四个边缘都被 0（代表水）包围着。 找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为 0 。) 示例 [[0,0,1,0,0,0,0,1,0,0,0,0,0], [0,0,0,0,0,0,0,1,1,1,0,0,0], [0,1,1,0,1,0,0,0,0,0,0,0,0], [0,1,0,0,1,1,0,0,1,0,1,0,0], [0,1,0,0,1,1,0,0,1,1,1,0,0], [0,0,0,0,0,0,0,0,0,0,1,0,0], [0,0,0,0,0,0,0,1,1,1,0,0,0], [0,0,0,0,0,0,0,1,1,0,0,0,0]] 对于上面这个给定矩阵应返回 6。注意答案不应该是 11 ，因为岛屿只能包含水平或垂直的四个方向的 1 。 注意: 给定的矩阵grid 的长度和宽度都不超过 50。 解法 func dfs(_ i: Int,_ j: Int,_ m: Int,_ n:Int,_ grid: inout [[Int]],_ tempArea: inout Int) -&gt; Int { if i&lt;0 || i&gt;=m || j&lt;0 || j&gt;=n || grid[i][j] == 0 { return tempArea } grid[i][j] = 0 tempArea += 1 tempArea = dfs(i+1, j, m, n, &amp;grid, &amp;tempArea) tempArea = dfs(i-1, j, m, n, &amp;grid, &amp;tempArea) tempArea = dfs(i, j+1, m, n, &amp;grid, &amp;tempArea) tempArea = dfs(i, j-1, m, n, &amp;grid, &amp;tempArea) return tempArea } func maxAreaOfIsland(_ grid: [[Int]]) -&gt; Int { var tempGrid = grid var area = 0 let m = tempGrid.count var n = 0 var islandMax = 0 for i in 0..&lt;m { n = tempGrid[i].count for j in 0..&lt;n { area = 0 area = dfs(i, j, m, n, &amp;tempGrid, &amp;area) islandMax = max(islandMax, area) } } return islandMax } 最长递增子序列（非连续） 给定一个未经排序的整数数组，找到最长递增子序列 示例 输入：10，9，2，5，3，7，101，18，20 输出：2，3，7，18，20 思路 一个巧妙的方法，一般来说第一遍for i-&gt;n-1(n),第二遍for j-&gt;i-1(n).这里可以加速的是第二个循环，因为第一个循环肯定是不能加速的，所以只能加速第二个循环。 可以维护一个数组LIS（最后的结果数组），一开始数组是空的，当第一个数10进来，毫无疑问，它就是最长递增子序列，9进来的时候，如果它比10大则直接append，否则用二分查找法去找到数组中比它大的最小的数，替换掉， 因为我们相当于要不断让更小的数进来，所以很好理解。这个复杂度是logn的，所以整体是nlogn的时间复杂度。 实现 最长连续递增序列 给定一个未经排序的整数数组，找到最长且连续的递增序列，并返回该序列的长度。 示例 输入：[1,3,5,4,7] 输出：3 解释：最长递增序列是[1,3,5], 长度为3 输入：[2,2,2,2] 输出：1 解释：最长连续递增序列是[2], 长度为1 注：数组长度不超过10000 思路 count 为当前元素峰值，ans为最大峰值 初始化 count=1 从0位置开始遍历，遍历是根据前后元素状态判断是否递增，递增则count++，递减count=1 如果count&gt;ans，则更新ans 直到循环结束 解法 func findLengthOfLCIS(_ nums: [Int])-&gt;Int { if nums.count &lt;= 1 {return nums.count} var ans = 1 var count = 1 for i in 0..&lt;nums.count-1 { if nums[i+1] &gt; nums[i] { count += 1 } else { count = 1 } ans = count&gt;ans ? count : ans } return ans } 结果 print(solution.findLengthOfLCIS([1,3,5,4,7])) 3 数组中的第K大的元素 在未排序的数组中找到第k大的元素。 示例 输入： [3,2,1,5,6,4], k=2 输出：5 输入： [3,2,3,1,2,4,5,5,6], k=4 输出：4 假设k总是有效的，且1&lt;=k&lt;=数组长度 思路 改进快速排序算法，求得第k大的元素，不需要将快速排序完全进行完，只需要进行一遍的递归，如果q刚好是第k大，则打完收工。 解法 //寻找pivot的函数 func partition(arr: inout [Int], left: Int, right: Int) -&gt; Int { let pivot = left var index = pivot+1 for i in index...right { if arr[i] &lt; arr[pivot] { arr.swapAt(i, index) index+=1 //i和index都更新，以pivot为分隔，两边都冒泡，后面再将假设的pivot替换为真正的pivot，然后继续递归 } } //此处相当于pivot需要更新 arr.swapAt(pivot, index-1) return index-1 } func findKthLargest(_ nums: inout [Int], _ k: Int) -&gt; Int { return quickSelect(&amp;nums, 0, nums.count-1, nums.count-k) } func quickSelect(_ a: inout [Int], _ l: Int, _ r: Int, _ index: Int) -&gt; Int { let q = partition(arr: &amp;a, left: l, right: r) if q == index { return a[q] } else { return q&lt;index ? quickSelect(&amp;a, q+1, r, index) : quickSelect(&amp;a, l, q-1, index) } } 结果 var nums = [3,2,3,1,2,4,5,5,6] let r10 = solution.findKthLargest(&amp;nums, 4) 4 最长连续增序列 给定一个未排序的整数数组，找出最长连续增序列的长度。 要求算法复杂度O（n） 示例 输入：[100,4,200,1,3,2] 输出：4 解释：最长连续序列是[1,2,3,4]。长度为4 思路 使用hashmap来保存数组中已经遍历过的元素，key对应元素的值，value表示该元素所在的连续子数组的长度。如果hash中存在此元素，则遍历下一个元素。如果不存在，则看hashmap中是否存在在此元素的前一个元素，比如如果遍历到5时，看看hash中是否存在4，如果存在则取该连续子数组的子一个元素，将它value值+1，并将该元素放到hashmap中，value值与第一个元素值相同，都表示该连续子数组的长度。如果hashmap中存在的该元素遍历到5时，hashmap中是否存在6，将次元素加入到最后一个连续的子数组中，并且和2中一样，找到子数组的第一个和最后一个元素，将它们的value值更新为子数组的长度。 swift解法简单，先排好序，然后判断i-1的值+1是否等于i的值，是的话，则继续向后，否则，当前和记录的最大值比较，currentstreak=1初始化 解法 func longestConsecutive(_ nums: [Int]) -&gt; Int { guard nums.count &gt; 0 else { return 0 } let nums = nums.sorted(){$0 &lt; $1} var longestStreak = 1 var currentStreak = 1 for i in 1..&lt;nums.count { if nums[i] != nums[i - 1] { if nums[i - 1] + 1 == nums[i] { currentStreak += 1 } else { longestStreak = max(longestStreak, currentStreak) currentStreak = 1 } } } return max(longestStreak, currentStreak) } 按频率对整数数组进行排序 应该按频率对数组排序，如果相同的频率则对整数排序 示例 输入：1 1 1 1 1 2 1 2 3 3 3 3 3 输出：1 1 1 1 1 1 3 3 3 3 3 2 2 思路 用hashmap存放数字出现的次数，然后对hashmap的value进行排序 代码实现： func sortFrequencyArray(source: [Int]) -&gt; [Int] { if source.count &lt;= 1 { return source } //key是数字，value是出现的频率 var hashTable: Dictionary&lt;Int, Int&gt; = [Int:Int]() for i in 0..&lt;source.count { let key: Int = source[i] if hashTable.keys.contains(key) { //更新数值 var value = hashTable[key] value! += 1 hashTable[key] = value } else { hashTable[key] = 1 } } let values = hashTable.sorted{ if $0.1 == $1.1 { //如果value（频率）相等，则按照key倒序 return $0.0 &gt; $1.0 } //如果value（频率）不等，则按照value倒序 return $0.1 &gt; $1.1 } var result: [Int] = [Int]() for i in 0..&lt;values.count { for _ in 0..&lt;values[i].1 { result.append(values[i].0) } } return result } 测试 let array6 = [8,8,8,8,8,8,8,8,8,8,8,8,8,7,7,1,1,6,6,1,1,1,2,1,2,4,4,3,3,5,5] let array7 = solution.sortFrequencyArray(source: array6) print(array7) 结果 [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 1, 1, 1, 1, 1, 1, 7, 7, 6, 6, 5, 5, 4, 4, 3, 3, 2, 2]]]></summary></entry><entry><title type="html">字符串算法</title><link href="http://localhost:4000/algorithm/2022/03/08/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AE%97%E6%B3%95.html" rel="alternate" type="text/html" title="字符串算法" /><published>2022-03-08T03:00:00+00:00</published><updated>2022-03-08T03:00:00+00:00</updated><id>http://localhost:4000/algorithm/2022/03/08/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AE%97%E6%B3%95</id><content type="html" xml:base="http://localhost:4000/algorithm/2022/03/08/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AE%97%E6%B3%95.html"><![CDATA[<p>一些算法举例</p>

<h2 id="字符串">字符串</h2>

<h3 id="复原ip地址">复原IP地址</h3>

<p>给定一个只包含数字的字符串，复原它并返回所有可能的IP地址格式。</p>

<p>有效的IP地址正好由四个整数（0到255之间组成），整数之间用’.’分隔。</p>

<ul>
  <li>示例</li>
</ul>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code>输入： "25525511135"
输出：["255.255.11.135", "255.255.111.35"]
</code></pre></div></div>

<ul>
  <li>思路</li>
</ul>

<p>回溯法</p>

<p>1、一开始，字符串的长度小于 4 或者大于 12 ，一定不能拼凑出合法的 ip 地址（这一点可以一般化到中间结点的判断中，以产生剪枝行为）；</p>

<p>2、每一个结点可以选择截取的方法只有 3 种：截 1 位、截 2 位、截 3 位，因此每一个结点可以生长出的分支最多只有 3 条分支；</p>

<p>根据截取出来的字符串判断是否是合理的 ip 段，这里写法比较多，可以先截取，再转换成 int ，再判断。我采用的做法是先转成 int，是合法的 ip 段数值以后，再截取。</p>

<p>3、由于 ip 段最多就 4 个段，因此这棵三叉树最多 4 层，这个条件作为递归终止条件之一；</p>

<ul>
  <li>解法</li>
</ul>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">restoreIpAddresses</span><span class="p">(</span><span class="n">_</span> <span class="nv">s</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="kt">String</span><span class="p">]</span> <span class="p">{</span>
  <span class="c1">//回溯法</span>
  <span class="k">var</span> <span class="nv">res</span><span class="p">:[</span><span class="kt">String</span><span class="p">]</span><span class="o">=</span><span class="p">[]</span>
  <span class="k">var</span> <span class="nv">tmp</span><span class="p">:[</span><span class="kt">String</span><span class="p">]</span><span class="o">=</span><span class="p">[]</span>
  <span class="k">let</span> <span class="nv">chs</span><span class="p">:[</span><span class="kt">Character</span><span class="p">]</span><span class="o">=</span><span class="p">[</span><span class="kt">Character</span><span class="p">](</span><span class="n">s</span><span class="p">)</span>
  <span class="nf">backTrace</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="p">,</span><span class="o">&amp;</span><span class="n">tmp</span><span class="p">,</span><span class="n">chs</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">res</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">backTrace</span><span class="p">(</span><span class="n">_</span> <span class="nv">res</span><span class="p">:</span><span class="k">inout</span> <span class="p">[</span><span class="kt">String</span><span class="p">],</span><span class="n">_</span> <span class="nv">tmp</span><span class="p">:</span><span class="k">inout</span> <span class="p">[</span><span class="kt">String</span><span class="p">],</span><span class="n">_</span> <span class="nv">chs</span><span class="p">:[</span><span class="kt">Character</span><span class="p">],</span><span class="n">_</span> <span class="nv">ind</span><span class="p">:</span><span class="kt">Int</span><span class="p">,</span><span class="n">_</span> <span class="nv">has</span><span class="p">:</span><span class="kt">Int</span><span class="p">){</span>
  <span class="k">if</span> <span class="n">ind</span> <span class="o">==</span> <span class="n">chs</span><span class="o">.</span><span class="n">count</span> <span class="o">&amp;&amp;</span> <span class="n">has</span> <span class="o">==</span> <span class="mi">4</span><span class="p">{</span>
    <span class="k">var</span> <span class="nv">str</span><span class="p">:</span><span class="kt">String</span><span class="o">=</span><span class="s">""</span>
    <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="n">tmp</span><span class="p">{</span>
      <span class="n">str</span> <span class="o">+=</span> <span class="n">i</span><span class="o">+</span><span class="s">"."</span>
    <span class="p">}</span>
    <span class="n">str</span><span class="o">.</span><span class="nf">removeLast</span><span class="p">()</span>
    <span class="n">res</span><span class="o">.</span><span class="nf">append</span><span class="p">(</span><span class="n">str</span><span class="p">)</span>
    <span class="k">return</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">has</span> <span class="o">==</span> <span class="mi">4</span> <span class="o">&amp;&amp;</span> <span class="n">ind</span> <span class="o">&lt;</span> <span class="n">chs</span><span class="o">.</span><span class="n">count</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">ind</span> <span class="o">==</span> <span class="n">chs</span><span class="o">.</span><span class="n">count</span> <span class="o">&amp;&amp;</span> <span class="n">has</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">){</span><span class="k">return</span><span class="p">}</span>
  <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="n">ind</span><span class="o">...</span><span class="n">ind</span><span class="o">+</span><span class="mi">2</span><span class="p">{</span>
    <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">chs</span><span class="o">.</span><span class="n">count</span><span class="p">{</span><span class="k">break</span><span class="p">}</span>    <span class="c1">//确保i是一个有效的下标</span>
    <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">ind</span> <span class="o">&amp;&amp;</span> <span class="n">chs</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">==</span> <span class="s">"0"</span><span class="p">{</span><span class="k">break</span><span class="p">}</span>
    <span class="k">let</span> <span class="nv">str</span><span class="p">:</span><span class="kt">String</span><span class="o">=</span><span class="kt">String</span><span class="p">(</span><span class="n">chs</span><span class="p">[</span><span class="n">ind</span><span class="o">...</span><span class="n">i</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">str</span><span class="o">.</span><span class="n">count</span> <span class="o">==</span> <span class="mi">3</span> <span class="o">&amp;&amp;</span> <span class="n">str</span> <span class="o">&gt;</span> <span class="s">"255"</span><span class="p">{</span><span class="k">continue</span><span class="p">}</span>  <span class="c1">//长度为1和2的数都可以，为3的话需要筛选</span>
    <span class="n">tmp</span><span class="o">.</span><span class="nf">append</span><span class="p">(</span><span class="n">str</span><span class="p">)</span>
    <span class="nf">backTrace</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="p">,</span><span class="o">&amp;</span><span class="n">tmp</span><span class="p">,</span><span class="n">chs</span><span class="p">,</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">has</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">tmp</span><span class="o">.</span><span class="nf">removeLast</span><span class="p">()</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>结果</li>
</ul>

<blockquote>
  <p>let ress = solution.restoreIpAddresses(“25525511135”)</p>

  <p>print(ress)</p>

  <p><strong>[“255.255.11.135”, “255.255.111.35”]</strong></p>
</blockquote>

<h3 id="字符串相乘">字符串相乘</h3>

<ul>
  <li>示例</li>
</ul>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code>输入：num1="123"，num2="456"
输出："56088"
num1,num2均不以0开头，除非是数字0本身
</code></pre></div></div>

<ul>
  <li>思路</li>
</ul>

<p>第i位和第j位相乘，结果会在第i+j上面，如果有进位，则i+j-1上也有，结果是倒序的</p>

<ul>
  <li>解法</li>
</ul>

<p>代码实现：</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">multiply</span><span class="p">(</span><span class="n">_</span> <span class="nv">num1</span><span class="p">:</span> <span class="kt">String</span><span class="p">,</span> <span class="n">_</span> <span class="nv">num2</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">String</span> <span class="p">{</span>
        <span class="k">if</span> <span class="kt">Int</span><span class="p">(</span><span class="n">num1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="kt">Int</span><span class="p">(</span><span class="n">num2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span><span class="k">return</span> <span class="s">"0"</span><span class="p">}</span>
        <span class="k">var</span> <span class="nv">result</span> <span class="o">=</span> <span class="s">""</span>
        <span class="k">var</span> <span class="nv">resultArray</span><span class="p">:</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span><span class="o">.</span><span class="nf">init</span><span class="p">(</span><span class="nf">repeatElement</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nv">count</span><span class="p">:</span> <span class="n">num1</span><span class="o">.</span><span class="n">count</span><span class="o">+</span><span class="n">num2</span><span class="o">.</span><span class="n">count</span><span class="p">))</span>
        <span class="c1">//这两个for执行完，结果数组里面是未处理过进位的结果</span>
        <span class="k">for</span> <span class="n">i</span> <span class="nf">in</span> <span class="p">(</span><span class="mi">0</span><span class="o">..&lt;</span><span class="n">num1</span><span class="o">.</span><span class="n">count</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">for</span> <span class="n">j</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..&lt;</span><span class="n">num2</span><span class="o">.</span><span class="n">count</span> <span class="p">{</span>
                <span class="k">let</span> <span class="nv">c1</span> <span class="o">=</span> <span class="kt">Int</span><span class="p">(</span><span class="kt">String</span><span class="p">(</span><span class="n">num1</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span><span class="o">!</span>
                <span class="k">let</span> <span class="nv">c2</span> <span class="o">=</span> <span class="kt">Int</span><span class="p">(</span><span class="kt">String</span><span class="p">(</span><span class="n">num2</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span><span class="o">!</span>
                
                <span class="k">let</span> <span class="nv">res</span> <span class="o">=</span> <span class="n">c1</span><span class="o">*</span><span class="n">c2</span>
                <span class="n">resultArray</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">res</span>
            <span class="p">}</span>
        <span class="p">}</span>
        
        <span class="c1">//处理进位</span>
        <span class="k">var</span> <span class="nv">carrys</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="nf">in</span> <span class="p">(</span><span class="mi">0</span><span class="o">..&lt;</span><span class="n">resultArray</span><span class="o">.</span><span class="n">count</span><span class="p">)</span><span class="o">.</span><span class="nf">reversed</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">resultArray</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="k">continue</span>
            <span class="p">}</span>
            
            <span class="k">let</span> <span class="nv">tmp</span> <span class="o">=</span> <span class="n">resultArray</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="n">carrys</span>
            
            <span class="n">carrys</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">/</span><span class="mi">10</span>
            <span class="n">resultArray</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">%</span><span class="mi">10</span>
        <span class="p">}</span>
        
        <span class="c1">//最后一位如果是0，则需要舍弃</span>
        <span class="k">let</span> <span class="nv">end</span> <span class="o">=</span> <span class="n">resultArray</span><span class="o">.</span><span class="n">last</span><span class="o">!==</span><span class="mi">0</span> <span class="p">?</span> <span class="n">resultArray</span><span class="o">.</span><span class="n">count</span><span class="o">-</span><span class="mi">1</span> <span class="p">:</span> <span class="n">resultArray</span><span class="o">.</span><span class="n">count</span>
        <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..&lt;</span><span class="n">end</span> <span class="p">{</span>
            <span class="n">result</span> <span class="o">+=</span> <span class="kt">String</span><span class="p">(</span><span class="n">resultArray</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="p">}</span>
        
        <span class="k">return</span> <span class="n">result</span>
    <span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>测试</li>
</ul>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">print</span><span class="p">(</span><span class="n">solution</span><span class="o">.</span><span class="nf">multiply</span><span class="p">(</span><span class="s">"123"</span><span class="p">,</span> <span class="s">"3128"</span><span class="p">))</span>
</code></pre></div></div>

<ul>
  <li>结果</li>
</ul>

<blockquote>
  <p>384744</p>
</blockquote>

<h3 id="字符串s1和s2判断s2中是否包含s1的排列">字符串s1和s2，判断s2中是否包含s1的排列</h3>

<ul>
  <li>示例</li>
</ul>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code>输入："abo"和"eidboammnj"
输出：true
如果是"abb"则false，字符串都是小写，长度1-10000
</code></pre></div></div>

<ul>
  <li>思路</li>
</ul>

<p>采用窗口滑动法，从开始的空窗口从左向右滑动</p>

<ul>
  <li>解法</li>
</ul>

<p>代码实现：</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//保证了字符串都是小写字母，97是小写的a，65是大写的A</span>
    <span class="kd">func</span> <span class="nf">checkInclusion</span><span class="p">(</span><span class="n">_</span> <span class="nv">s1</span><span class="p">:</span> <span class="kt">String</span><span class="p">,</span> <span class="n">_</span> <span class="nv">s2</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Bool</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">s1</span><span class="o">.</span><span class="n">isEmpty</span> <span class="o">||</span> <span class="n">s2</span><span class="o">.</span><span class="n">isEmpty</span> <span class="p">{</span><span class="k">return</span> <span class="kc">false</span><span class="p">}</span>
        <span class="k">guard</span> <span class="n">s1</span><span class="o">.</span><span class="n">count</span> <span class="o">&lt;=</span> <span class="n">s2</span><span class="o">.</span><span class="n">count</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">false</span>
        <span class="p">}</span>

        <span class="kd">func</span> <span class="nf">allZero</span><span class="p">(</span><span class="n">_</span> <span class="nv">counts</span><span class="p">:</span> <span class="p">[</span><span class="kt">Int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kt">Bool</span> <span class="p">{</span>
            <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">0</span> <span class="o">..&lt;</span> <span class="mi">26</span> <span class="p">{</span>
                <span class="k">if</span> <span class="n">counts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
                    <span class="k">return</span> <span class="kc">false</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="kc">true</span>
        <span class="p">}</span>

        <span class="k">let</span> <span class="nv">chars1</span> <span class="o">=</span> <span class="kt">Array</span><span class="p">(</span><span class="n">s1</span><span class="o">.</span><span class="n">unicodeScalars</span><span class="p">)</span>
        <span class="k">let</span> <span class="nv">chars2</span> <span class="o">=</span> <span class="kt">Array</span><span class="p">(</span><span class="n">s2</span><span class="o">.</span><span class="n">unicodeScalars</span><span class="p">)</span>
        <span class="k">let</span> <span class="nv">len1</span> <span class="o">=</span> <span class="n">chars1</span><span class="o">.</span><span class="n">count</span>
        <span class="k">let</span> <span class="nv">len2</span> <span class="o">=</span> <span class="n">chars2</span><span class="o">.</span><span class="n">count</span>
        <span class="k">var</span> <span class="nv">counts</span> <span class="o">=</span> <span class="p">[</span><span class="kt">Int</span><span class="p">](</span><span class="nf">repeatElement</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nv">count</span><span class="p">:</span> <span class="mi">26</span><span class="p">))</span>

        <span class="c1">//可以简单理解有两个同时滑动的窗口，都向右滑，上面一个窗口后面会为空</span>
        <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">0</span> <span class="o">..&lt;</span> <span class="n">len1</span> <span class="p">{</span>
            <span class="c1">//s1从右边滑进的+1，从右边滑出的-1</span>
            <span class="n">counts</span><span class="p">[</span><span class="kt">Int</span><span class="p">(</span><span class="n">chars1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">value</span> <span class="o">-</span> <span class="mi">97</span><span class="p">)]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="c1">//s2从右边滑进的-1，从右边滑出的-1</span>
            <span class="n">counts</span><span class="p">[</span><span class="kt">Int</span><span class="p">(</span><span class="n">chars2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">value</span> <span class="o">-</span> <span class="mi">97</span><span class="p">)]</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="nf">allZero</span><span class="p">(</span><span class="n">counts</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="kc">true</span><span class="p">}</span>
        
        <span class="c1">//因为都是s2，所以只看滑进还是滑出</span>
        <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="n">len1</span> <span class="o">..&lt;</span> <span class="n">len2</span> <span class="p">{</span>
            <span class="c1">//从右边滑进，-1</span>
            <span class="n">counts</span><span class="p">[</span><span class="kt">Int</span><span class="p">(</span><span class="n">chars2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">value</span> <span class="o">-</span> <span class="mi">97</span><span class="p">)]</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="c1">//从右边滑出，+1</span>
            <span class="n">counts</span><span class="p">[</span><span class="kt">Int</span><span class="p">(</span><span class="n">chars2</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">len1</span><span class="p">]</span><span class="o">.</span><span class="n">value</span> <span class="o">-</span> <span class="mi">97</span><span class="p">)]</span> <span class="o">+=</span> <span class="mi">1</span>
            
            <span class="k">if</span> <span class="nf">allZero</span><span class="p">(</span><span class="n">counts</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="kc">true</span><span class="p">}</span>
        <span class="p">}</span>

        <span class="c1">//窗口的大小是短串的长度，必须要这样，否则肯定是false</span>
        <span class="k">return</span> <span class="kc">false</span>
    <span class="p">}</span>
</code></pre></div></div>

<h3 id="有一个字符串和一组子字符串请返回覆盖率最高单词最多的子字符串列表">有一个字符串和一组子字符串，请返回覆盖率最高，单词最多的子字符串列表</h3>

<p>示例：</p>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code>字符串: abcdefg
子字符串: ((ab，0, 1), (cd, 2, 3)，(efg，4, 6), (abc，0，2)，(abcd, 0, 3), (cdef, 2, 5))
期望: {ab, cd, efg}
</code></pre></div></div>

<ul>
  <li>分析</li>
</ul>

<h3 id="最长不重复子串">最长不重复子串</h3>

<p>给定一个字符串，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。
示例：</p>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code> 输入："adbdeacdmmm"
 输出：5
 解释：因为无重复的最长子串是"bdeac"或者"eacdm"
</code></pre></div></div>

<ul>
  <li>分析</li>
</ul>

<p>首先本体如果使用两层for循环当然可以轻松搞定，但是时间复杂度也是O（n^2），显然不是很满意，所以需要想个法子将复杂度调整到O（n）。
因为是子串，不是子序列，所以肯定是一串连续的字符区域。头设定为start，尾设定为end。那么在仅仅遍历一遍的情况下，start是会不断往后涨的，end就是当前遍历的位置。
    1. 如果当前遍历的字符在start后面没有出现过，则接着遍历，start往后移
    2. 如果当前遍历的字符已经出现了（这里可以使用hash表记录，key是character，value是index），则说明肯定有字符重复，需要将start移到这个重复字符处，也就是遍历的字符上一次出现的位置的下一个位置（index）
    3. 在这个过程中，时刻更新最大长度</p>

<ul>
  <li>解法</li>
</ul>

<p>代码实现：</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//code1</span>
<span class="kd">extension</span> <span class="kt">String</span> <span class="p">{</span>
    <span class="nf">subscript</span><span class="p">(</span><span class="n">_</span> <span class="nv">i</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span><span class="o">-&gt;</span><span class="kt">Character</span> <span class="p">{</span>
        <span class="k">get</span> <span class="p">{</span><span class="k">return</span> <span class="k">self</span><span class="p">[</span><span class="nf">index</span><span class="p">(</span><span class="n">startIndex</span><span class="p">,</span> <span class="nv">offsetBy</span><span class="p">:</span> <span class="n">i</span><span class="p">)]}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>code1是为了给string添加subscript操作，真正功能代码是：</p>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">//code2</span>
    <span class="kd">func</span> <span class="nf">lengthOfLongestSubstring</span><span class="p">(</span><span class="n">_</span> <span class="nv">s</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="kt">Int</span><span class="p">,</span> <span class="kt">String</span><span class="p">?)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">isEmpty</span> <span class="p">{</span>
            <span class="nf">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="k">var</span> <span class="nv">maxLength</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">var</span> <span class="nv">start</span> <span class="o">=</span> <span class="n">maxLength</span>
        
        <span class="k">var</span> <span class="nv">retString</span><span class="p">:</span> <span class="kt">String</span><span class="p">?</span> <span class="o">=</span> <span class="s">" "</span>
        
        <span class="k">var</span> <span class="nv">hashTable</span><span class="p">:</span> <span class="kt">Dictionary</span><span class="o">&lt;</span><span class="kt">Character</span><span class="p">,</span> <span class="kt">Int</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">[</span><span class="kt">Character</span><span class="p">:</span><span class="kt">Int</span><span class="p">]()</span>
                
        <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..&lt;</span><span class="n">s</span><span class="o">.</span><span class="n">count</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">hashTable</span><span class="o">.</span><span class="n">keys</span><span class="o">.</span><span class="nf">contains</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&amp;&amp;</span> <span class="n">hashTable</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">!</span> <span class="o">&gt;=</span> <span class="n">start</span> <span class="p">{</span>
                <span class="n">start</span> <span class="o">=</span> <span class="n">hashTable</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">!+</span><span class="mi">1</span>
            <span class="p">}</span>
            
            <span class="n">hashTable</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">i</span>
            
            <span class="n">maxLength</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span><span class="n">maxLength</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">-</span><span class="n">start</span><span class="p">)</span>
        <span class="p">}</span>
        
        <span class="nf">return</span> <span class="p">(</span><span class="n">maxLength</span><span class="p">,</span> <span class="n">retString</span><span class="o">!</span><span class="p">)</span>
    <span class="p">}</span>
</code></pre></div></div>
<p>当然code2实际上只是输出长度并没有输出子字符串，我们尝试着输出长度和子字符串，其实就是在code2的基础上稍微改一下：</p>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">//code3</span>
    <span class="kd">func</span> <span class="nf">lengthOfLongestSubstring</span><span class="p">(</span><span class="n">_</span> <span class="nv">s</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="kt">Int</span><span class="p">,</span> <span class="kt">String</span><span class="p">?)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">isEmpty</span> <span class="p">{</span>
            <span class="nf">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
        <span class="p">}</span>
        
        <span class="k">var</span> <span class="nv">maxLength</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">var</span> <span class="nv">start</span> <span class="o">=</span> <span class="n">maxLength</span>
        
        <span class="k">var</span> <span class="nv">retString</span><span class="p">:</span> <span class="kt">String</span><span class="p">?</span> <span class="o">=</span> <span class="s">" "</span>
        <span class="k">let</span> <span class="nv">strArray</span> <span class="o">=</span> <span class="kt">Array</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        
        <span class="k">var</span> <span class="nv">hashTable</span><span class="p">:</span> <span class="kt">Dictionary</span><span class="o">&lt;</span><span class="kt">Character</span><span class="p">,</span> <span class="kt">Int</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">[</span><span class="kt">Character</span><span class="p">:</span><span class="kt">Int</span><span class="p">]()</span>
                
        <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..&lt;</span><span class="n">s</span><span class="o">.</span><span class="n">count</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">hashTable</span><span class="o">.</span><span class="n">keys</span><span class="o">.</span><span class="nf">contains</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&amp;&amp;</span> <span class="n">hashTable</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">!</span> <span class="o">&gt;=</span> <span class="n">start</span> <span class="p">{</span>
                <span class="n">start</span> <span class="o">=</span> <span class="n">hashTable</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">!+</span><span class="mi">1</span>
            <span class="p">}</span>
            
            <span class="n">hashTable</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">i</span>
            
            <span class="c1">//此处就是获取子串，由于会一直遍历到最后，所以如果有多个相等长度的子串，会停留在最后一个子串，返回</span>
            <span class="k">if</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">-</span><span class="n">start</span> <span class="o">&gt;=</span> <span class="n">maxLength</span> <span class="p">{</span>
                <span class="k">let</span> <span class="nv">subArr</span> <span class="o">=</span> <span class="n">strArray</span><span class="p">[</span><span class="n">start</span><span class="o">..&lt;</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">let</span> <span class="nv">subStr</span><span class="p">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">subArr</span><span class="o">.</span><span class="n">map</span><span class="p">{</span><span class="kt">String</span><span class="o">.</span><span class="nf">init</span><span class="p">(</span><span class="nv">$0</span><span class="p">)}</span><span class="o">.</span><span class="nf">joined</span><span class="p">()</span>
                <span class="n">retString</span> <span class="o">=</span> <span class="n">subStr</span>
            <span class="p">}</span>
            
            <span class="n">maxLength</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span><span class="n">maxLength</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">-</span><span class="n">start</span><span class="p">)</span>
        <span class="p">}</span>

        <span class="nf">return</span> <span class="p">(</span><span class="n">maxLength</span><span class="p">,</span> <span class="n">retString</span><span class="o">!</span><span class="p">)</span>
    <span class="p">}</span>
</code></pre></div></div>

<p>示例代码如下:</p>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="nv">solution</span> <span class="o">=</span> <span class="kt">Solution</span><span class="p">()</span>
<span class="k">var</span> <span class="nv">turple1</span> <span class="o">=</span> <span class="n">solution</span><span class="o">.</span><span class="nf">lengthOfLongestSubstring</span><span class="p">(</span><span class="s">"adbdeacdmmm"</span><span class="p">)</span>

<span class="nf">print</span><span class="p">(</span><span class="n">turple1</span><span class="p">)</span>
</code></pre></div></div>
<p>以“adbdeacdmmm”为例，则长度为5，子串为：”bdeac”或者”eacdm”，但是由于“eacdm”在后面，所以输出的是“eacdm”
可以看到：</p>

<p><img src="http://localhost:4000/assets/images/posts/leetcode_lengthOfLongestSubstring.jpg" alt="lengthOfLongestSubstring" /></p>

<h3 id="最长公共前缀">最长公共前缀</h3>
<p>编写一个函数来查找字符串数组中的最长公共前缀。
如果不存在公共前缀，返回空字符串”” 
示例：</p>
<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code>输入：["flower","flow","flight"]
输出："fl"
</code></pre></div></div>
<p><em>说明</em>
所有的输入只包含小写字母<code class="language-plaintext highlighter-rouge">a-z</code></p>
<ul>
  <li>解法一</li>
</ul>

<p>暴力循环法，从题目可知：<strong>最长公共前缀的长度一定是字符串数组中长度最短的哪个字符串</strong></p>
<ol>
  <li>首先找出长度最短的字符串str，比如str=”abcf”。</li>
  <li>以此对’abcf’,’abc’,’ab’,’a’进行筛选，判断哪个是所有的其他字符串的前缀。</li>
</ol>

<ul>
  <li>解法二</li>
</ul>

<p>看下图：</p>

<p><img src="http://localhost:4000/assets/images/posts/leetcode_longestCommonPrefix.jpg" alt="longestCommonPrefix" /></p>

<p>对str[0]按照字符遍历，与其他字符串以此比较对应位置上的字符，并记录查找位置，如果找到不相等或者对应字符串的长度到了限制，就找到了。</p>

<p>代码如下：</p>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">func</span> <span class="nf">longestCommonPrefix</span><span class="p">(</span><span class="n">_</span> <span class="nv">strs</span><span class="p">:</span> <span class="p">[</span><span class="kt">String</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kt">String</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">strs</span><span class="o">.</span><span class="n">count</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="k">return</span> <span class="s">""</span>
        <span class="p">}</span>
        
        <span class="k">if</span> <span class="n">strs</span><span class="o">.</span><span class="n">count</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">strs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="p">}</span>
        
        <span class="k">let</span> <span class="nv">str</span> <span class="o">=</span> <span class="n">strs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..&lt;</span><span class="n">str</span><span class="o">.</span><span class="n">count</span> <span class="p">{</span>
            <span class="k">let</span> <span class="nv">c</span><span class="p">:</span> <span class="kt">Character</span> <span class="o">=</span> <span class="n">str</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">j</span> <span class="k">in</span> <span class="mi">1</span><span class="o">..&lt;</span><span class="n">strs</span><span class="o">.</span><span class="n">count</span> <span class="p">{</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">strs</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">count</span> <span class="o">||</span> <span class="n">c</span> <span class="o">!=</span> <span class="n">strs</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="p">{</span>
                    <span class="k">let</span> <span class="nv">rightIndex</span> <span class="o">=</span> <span class="n">strs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="nf">index</span><span class="p">(</span><span class="n">strs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">startIndex</span><span class="p">,</span> <span class="nv">offsetBy</span><span class="p">:</span> <span class="n">i</span><span class="p">)</span>
                    <span class="k">return</span> <span class="kt">String</span><span class="p">(</span><span class="n">strs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">strs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">startIndex</span><span class="o">..&lt;</span><span class="n">rightIndex</span><span class="p">])</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
        
        <span class="k">return</span> <span class="n">strs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="p">}</span>
</code></pre></div></div>
<p>测试：</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">strs2</span><span class="p">:</span> <span class="p">[</span><span class="kt">String</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s">"abcdfj"</span><span class="p">,</span> <span class="s">"abc"</span><span class="p">,</span> <span class="s">"abcmnihiuh"</span><span class="p">,</span> <span class="s">"abcmunh"</span><span class="p">]</span>
<span class="k">let</span> <span class="nv">str2</span><span class="p">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">solution</span><span class="o">.</span><span class="nf">longestCommonPrefix</span><span class="p">(</span><span class="n">strs2</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">str2</span><span class="p">)</span>
</code></pre></div></div>

<p>结果：</p>
<blockquote>
  <p>abc</p>
</blockquote>]]></content><author><name>Cambria Yang</name><email>cambriayang@qq.com</email></author><category term="Algorithm" /><category term="算法" /><summary type="html"><![CDATA[一些算法举例 字符串 复原IP地址 给定一个只包含数字的字符串，复原它并返回所有可能的IP地址格式。 有效的IP地址正好由四个整数（0到255之间组成），整数之间用’.’分隔。 示例 输入： "25525511135" 输出：["255.255.11.135", "255.255.111.35"] 思路 回溯法 1、一开始，字符串的长度小于 4 或者大于 12 ，一定不能拼凑出合法的 ip 地址（这一点可以一般化到中间结点的判断中，以产生剪枝行为）； 2、每一个结点可以选择截取的方法只有 3 种：截 1 位、截 2 位、截 3 位，因此每一个结点可以生长出的分支最多只有 3 条分支； 根据截取出来的字符串判断是否是合理的 ip 段，这里写法比较多，可以先截取，再转换成 int ，再判断。我采用的做法是先转成 int，是合法的 ip 段数值以后，再截取。 3、由于 ip 段最多就 4 个段，因此这棵三叉树最多 4 层，这个条件作为递归终止条件之一； 解法 func restoreIpAddresses(_ s: String) -&gt; [String] { //回溯法 var res:[String]=[] var tmp:[String]=[] let chs:[Character]=[Character](s) backTrace(&amp;res,&amp;tmp,chs,0,0) return res } func backTrace(_ res:inout [String],_ tmp:inout [String],_ chs:[Character],_ ind:Int,_ has:Int){ if ind == chs.count &amp;&amp; has == 4{ var str:String="" for i in tmp{ str += i+"." } str.removeLast() res.append(str) return } if (has == 4 &amp;&amp; ind &lt; chs.count) || (ind == chs.count &amp;&amp; has &lt; 4){return} for i in ind...ind+2{ if i &gt;= chs.count{break} //确保i是一个有效的下标 if i &gt; ind &amp;&amp; chs[ind] == "0"{break} let str:String=String(chs[ind...i]) if str.count == 3 &amp;&amp; str &gt; "255"{continue} //长度为1和2的数都可以，为3的话需要筛选 tmp.append(str) backTrace(&amp;res,&amp;tmp,chs,i+1,has+1) tmp.removeLast() } } 结果 let ress = solution.restoreIpAddresses(“25525511135”) print(ress) [“255.255.11.135”, “255.255.111.35”] 字符串相乘 示例 输入：num1="123"，num2="456" 输出："56088" num1,num2均不以0开头，除非是数字0本身 思路 第i位和第j位相乘，结果会在第i+j上面，如果有进位，则i+j-1上也有，结果是倒序的 解法 代码实现： func multiply(_ num1: String, _ num2: String) -&gt; String { if Int(num1) == 0 || Int(num2) == 0 {return "0"} var result = "" var resultArray: [Int] = [Int].init(repeatElement(0, count: num1.count+num2.count)) //这两个for执行完，结果数组里面是未处理过进位的结果 for i in (0..&lt;num1.count) { for j in 0..&lt;num2.count { let c1 = Int(String(num1[i]))! let c2 = Int(String(num2[j]))! let res = c1*c2 resultArray[i+j] += res } } //处理进位 var carrys = 0 for i in (0..&lt;resultArray.count).reversed() { if resultArray[i] == 0 { continue } let tmp = resultArray[i]+carrys carrys = tmp/10 resultArray[i] = tmp%10 } //最后一位如果是0，则需要舍弃 let end = resultArray.last!==0 ? resultArray.count-1 : resultArray.count for i in 0..&lt;end { result += String(resultArray[i]) } return result } 测试 print(solution.multiply("123", "3128")) 结果 384744 字符串s1和s2，判断s2中是否包含s1的排列 示例 输入："abo"和"eidboammnj" 输出：true 如果是"abb"则false，字符串都是小写，长度1-10000 思路 采用窗口滑动法，从开始的空窗口从左向右滑动 解法 代码实现： //保证了字符串都是小写字母，97是小写的a，65是大写的A func checkInclusion(_ s1: String, _ s2: String) -&gt; Bool { if s1.isEmpty || s2.isEmpty {return false} guard s1.count &lt;= s2.count else { return false } func allZero(_ counts: [Int]) -&gt; Bool { for i in 0 ..&lt; 26 { if counts[i] != 0 { return false } } return true } let chars1 = Array(s1.unicodeScalars) let chars2 = Array(s2.unicodeScalars) let len1 = chars1.count let len2 = chars2.count var counts = [Int](repeatElement(0, count: 26)) //可以简单理解有两个同时滑动的窗口，都向右滑，上面一个窗口后面会为空 for i in 0 ..&lt; len1 { //s1从右边滑进的+1，从右边滑出的-1 counts[Int(chars1[i].value - 97)] += 1 //s2从右边滑进的-1，从右边滑出的-1 counts[Int(chars2[i].value - 97)] -= 1 } if allZero(counts) {return true} //因为都是s2，所以只看滑进还是滑出 for i in len1 ..&lt; len2 { //从右边滑进，-1 counts[Int(chars2[i].value - 97)] -= 1 //从右边滑出，+1 counts[Int(chars2[i - len1].value - 97)] += 1 if allZero(counts) {return true} } //窗口的大小是短串的长度，必须要这样，否则肯定是false return false } 有一个字符串和一组子字符串，请返回覆盖率最高，单词最多的子字符串列表 示例： 字符串: abcdefg 子字符串: ((ab，0, 1), (cd, 2, 3)，(efg，4, 6), (abc，0，2)，(abcd, 0, 3), (cdef, 2, 5)) 期望: {ab, cd, efg} 分析 最长不重复子串 给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 示例： 输入："adbdeacdmmm" 输出：5 解释：因为无重复的最长子串是"bdeac"或者"eacdm" 分析 首先本体如果使用两层for循环当然可以轻松搞定，但是时间复杂度也是O（n^2），显然不是很满意，所以需要想个法子将复杂度调整到O（n）。 因为是子串，不是子序列，所以肯定是一串连续的字符区域。头设定为start，尾设定为end。那么在仅仅遍历一遍的情况下，start是会不断往后涨的，end就是当前遍历的位置。 1. 如果当前遍历的字符在start后面没有出现过，则接着遍历，start往后移 2. 如果当前遍历的字符已经出现了（这里可以使用hash表记录，key是character，value是index），则说明肯定有字符重复，需要将start移到这个重复字符处，也就是遍历的字符上一次出现的位置的下一个位置（index） 3. 在这个过程中，时刻更新最大长度 解法 代码实现： //code1 extension String { subscript(_ i: Int)-&gt;Character { get {return self[index(startIndex, offsetBy: i)]} } } code1是为了给string添加subscript操作，真正功能代码是： //code2 func lengthOfLongestSubstring(_ s: String) -&gt; (Int, String?) { if s.isEmpty { return (0, nil) } var maxLength = 0 var start = maxLength var retString: String? = " " var hashTable: Dictionary&lt;Character, Int&gt; = [Character:Int]() for i in 0..&lt;s.count { if hashTable.keys.contains(s[i]) &amp;&amp; hashTable[s[i]]! &gt;= start { start = hashTable[s[i]]!+1 } hashTable[s[i]] = i maxLength = max(maxLength, i+1-start) } return (maxLength, retString!) } 当然code2实际上只是输出长度并没有输出子字符串，我们尝试着输出长度和子字符串，其实就是在code2的基础上稍微改一下： //code3 func lengthOfLongestSubstring(_ s: String) -&gt; (Int, String?) { if s.isEmpty { return (0, nil) } var maxLength = 0 var start = maxLength var retString: String? = " " let strArray = Array(s) var hashTable: Dictionary&lt;Character, Int&gt; = [Character:Int]() for i in 0..&lt;s.count { if hashTable.keys.contains(s[i]) &amp;&amp; hashTable[s[i]]! &gt;= start { start = hashTable[s[i]]!+1 } hashTable[s[i]] = i //此处就是获取子串，由于会一直遍历到最后，所以如果有多个相等长度的子串，会停留在最后一个子串，返回 if i+1-start &gt;= maxLength { let subArr = strArray[start..&lt;i+1] let subStr: String = subArr.map{String.init($0)}.joined() retString = subStr } maxLength = max(maxLength, i+1-start) } return (maxLength, retString!) } 示例代码如下: var solution = Solution() var turple1 = solution.lengthOfLongestSubstring("adbdeacdmmm") print(turple1) 以“adbdeacdmmm”为例，则长度为5，子串为：”bdeac”或者”eacdm”，但是由于“eacdm”在后面，所以输出的是“eacdm” 可以看到： 最长公共前缀 编写一个函数来查找字符串数组中的最长公共前缀。 如果不存在公共前缀，返回空字符串”” 示例： 输入：["flower","flow","flight"] 输出："fl" 说明 所有的输入只包含小写字母a-z 解法一 暴力循环法，从题目可知：最长公共前缀的长度一定是字符串数组中长度最短的哪个字符串 首先找出长度最短的字符串str，比如str=”abcf”。 以此对’abcf’,’abc’,’ab’,’a’进行筛选，判断哪个是所有的其他字符串的前缀。 解法二 看下图： 对str[0]按照字符遍历，与其他字符串以此比较对应位置上的字符，并记录查找位置，如果找到不相等或者对应字符串的长度到了限制，就找到了。 代码如下： func longestCommonPrefix(_ strs: [String]) -&gt; String { if strs.count &lt;= 0 { return "" } if strs.count == 1 { return strs[0] } let str = strs[0] for i in 0..&lt;str.count { let c: Character = str[i] for j in 1..&lt;strs.count { if i == strs[j].count || c != strs[j][i] { let rightIndex = strs[0].index(strs[0].startIndex, offsetBy: i) return String(strs[0][strs[0].startIndex..&lt;rightIndex]) } } } return strs[0] } 测试： let strs2: [String] = ["abcdfj", "abc", "abcmnihiuh", "abcmunh"] let str2: String = solution.longestCommonPrefix(strs2) print(str2) 结果： abc]]></summary></entry><entry><title type="html">排序算法</title><link href="http://localhost:4000/algorithm/2022/03/08/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.html" rel="alternate" type="text/html" title="排序算法" /><published>2022-03-08T02:00:00+00:00</published><updated>2022-03-08T02:00:00+00:00</updated><id>http://localhost:4000/algorithm/2022/03/08/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95</id><content type="html" xml:base="http://localhost:4000/algorithm/2022/03/08/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.html"><![CDATA[<p>一些算法举例</p>

<h2 id="排序算法">排序算法</h2>
<p>首先看一张图：</p>

<p><img src="http://localhost:4000/assets/images/posts/sort_algorithm.jpg" alt="sort_algorithm" class="rounded border shadow" /></p>

<p>这里就不多解释了，下面抽几个排序简单讲下。</p>

<p class="success">成功</p>

<p class="info">信息</p>

<p class="warning">Warning Text.</p>

<p class="error">Error Text.</p>

<p><code class="language-plaintext success highlighter-rouge">success</code> <code class="language-plaintext info highlighter-rouge">info</code> <code class="language-plaintext warning highlighter-rouge">warning</code> <code class="language-plaintext error highlighter-rouge">error</code></p>

<h3 id="冒泡排序">冒泡排序</h3>
<ul>
  <li>算法步骤</li>
</ul>

<p>比较相邻的元素。如果第一个比第二个大，就交换他们两个。
对每一对相邻元素作同样的工作，从开始第一队到结尾的最后一对。这步做完后，最后的元素会是最大的数。
针对所有的元素重复以上的步骤，除了最后一个。
持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</p>

<ul>
  <li>动图演示</li>
</ul>

<p><img src="http://localhost:4000/assets/images/posts/bubbleSort.gif" alt="bubbleSort" /></p>

<ul>
  <li>代码实现：</li>
</ul>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">func</span> <span class="nf">bubleSort</span><span class="p">(</span><span class="nv">source</span><span class="p">:</span> <span class="k">inout</span> <span class="p">[</span><span class="kt">Int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"bubleSort before: </span><span class="se">\(</span><span class="n">source</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..&lt;</span><span class="n">source</span><span class="o">.</span><span class="n">count</span> <span class="p">{</span>
        <span class="k">for</span> <span class="n">j</span> <span class="k">in</span> <span class="n">i</span><span class="o">..&lt;</span><span class="n">source</span><span class="o">.</span><span class="n">count</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">source</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">&lt;</span><span class="n">source</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">{</span>
                <span class="n">source</span><span class="o">.</span><span class="nf">swapAt</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="nf">print</span><span class="p">(</span><span class="s">"bubleSort after: </span><span class="se">\(</span><span class="n">source</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">source</span>
<span class="p">}</span>
</code></pre></div></div>

<p>i的循环是计数用，j的循环是当次将最大的数放到最后。</p>

<h3 id="插入排序">插入排序</h3>
<ul>
  <li>算法步骤</li>
</ul>

<p>将第一待排序的第一个元素看过一个有序序列，把第二个元素到最后一个元素当成未排序序列。
从头到位以此扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面）</p>

<ul>
  <li>动图演示</li>
</ul>

<p>由于很好理解就不放动图演示了。</p>

<ul>
  <li>代码实现</li>
</ul>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">func</span> <span class="nf">insertSort</span><span class="p">(</span><span class="nv">arr</span><span class="p">:</span> <span class="k">inout</span> <span class="p">[</span><span class="kt">Int</span><span class="p">])</span> <span class="p">{</span>
        <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">1</span><span class="o">..&lt;</span><span class="n">arr</span><span class="o">.</span><span class="n">endIndex</span> <span class="p">{</span>
            <span class="k">let</span> <span class="nv">temp</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">j</span> <span class="nf">in</span> <span class="p">(</span><span class="mi">0</span><span class="o">..&lt;</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="nf">reversed</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">if</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">temp</span> <span class="p">{</span>
                    <span class="n">arr</span><span class="o">.</span><span class="nf">swapAt</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div></div>

<h3 id="快速排序">快速排序</h3>
<p>平均状况下，排序n个项目要O（nlogn）次比较。在最坏的状况下则需要O（n^2）次比较，但这种状况并不多见。事实上，快排通常明显比其他O（nlogn）算法更快一个，因为它的内部循环可以在大部分的架构上很有效率地被实现出来。
快排使用分治法（Divide and conquer）策略来把一个串行（list）分为两个子串行（sub-lists）。
快速排序本质上是冒泡排序基础上的递归分治法。它是处理大数据排序最快的算法之一了。
《算法艺术与信息学竞赛》上说：</p>
<blockquote>
  <p>快速排序最坏的情况是O（n^2），比如顺序数列额快排。但它的平摊期望时间是O（nlogn），且O（nlogn）记号中隐含的常数因子很小，比复杂度稳定等于O（nlogn）的归并排序要小很多。所以，对绝大多数树顺序性较弱的随机数列而言，快速排序总是优于归并排序。</p>
</blockquote>

<ul>
  <li>算法步骤</li>
</ul>

<ol>
  <li>从数列中挑出一个元素，称为“基准”（pivot）；</li>
  <li>重新排序数列，所有元素比基准值小的摆放在基准面前，所有比基准大的摆在基准后面（相同的可以放到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li>
  <li>递归的（recursive）把小于基准值的元素的子数列和大于基准值元素的子数列排序。</li>
</ol>

<ul>
  <li>动图演示</li>
</ul>

<p><img src="http://localhost:4000/assets/images/posts/quickSort.gif" alt="quickSort" /></p>

<ul>
  <li>代码实现</li>
</ul>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">//寻找pivot的函数</span>
    <span class="kd">func</span> <span class="nf">partition</span><span class="p">(</span><span class="nv">arr</span><span class="p">:</span> <span class="k">inout</span> <span class="p">[</span><span class="kt">Int</span><span class="p">],</span> <span class="nv">left</span><span class="p">:</span> <span class="kt">Int</span><span class="p">,</span> <span class="nv">right</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">pivot</span> <span class="o">=</span> <span class="n">left</span>
        <span class="k">var</span> <span class="nv">index</span> <span class="o">=</span> <span class="n">pivot</span><span class="o">+</span><span class="mi">1</span>
        <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="n">index</span><span class="o">...</span><span class="n">right</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">pivot</span><span class="p">]</span> <span class="p">{</span>
                <span class="n">arr</span><span class="o">.</span><span class="nf">swapAt</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
                <span class="n">index</span><span class="o">+=</span><span class="mi">1</span>
                <span class="c1">//i和index都更新，以pivot为分隔，两边都冒泡，后面再将假设的pivot替换为真正的pivot，然后继续递归</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="c1">//此处相当于pivot需要更新</span>
        <span class="n">arr</span><span class="o">.</span><span class="nf">swapAt</span><span class="p">(</span><span class="n">pivot</span><span class="p">,</span> <span class="n">index</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">index</span><span class="o">-</span><span class="mi">1</span>
    <span class="p">}</span>
    
    <span class="kd">func</span> <span class="nf">quickSort</span><span class="p">(</span><span class="nv">arr</span><span class="p">:</span> <span class="k">inout</span> <span class="p">[</span><span class="kt">Int</span><span class="p">],</span> <span class="nv">left</span><span class="p">:</span> <span class="kt">Int</span><span class="p">,</span> <span class="nv">right</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">arr</span><span class="o">.</span><span class="n">count</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="p">{</span>
            <span class="c1">//nothing, live it alone</span>
        <span class="p">}</span>
        
        <span class="k">let</span> <span class="nv">left</span> <span class="o">=</span> <span class="n">left</span>
        <span class="k">let</span> <span class="nv">right</span> <span class="o">=</span> <span class="n">right</span>
        <span class="k">if</span> <span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span> <span class="p">{</span>
            <span class="k">let</span> <span class="nv">partitionIndex</span> <span class="o">=</span> <span class="nf">partition</span><span class="p">(</span><span class="nv">arr</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">arr</span><span class="p">,</span> <span class="nv">left</span><span class="p">:</span> <span class="n">left</span><span class="p">,</span> <span class="nv">right</span><span class="p">:</span> <span class="n">right</span><span class="p">)</span>
            <span class="nf">quickSort</span><span class="p">(</span><span class="nv">arr</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">arr</span><span class="p">,</span> <span class="nv">left</span><span class="p">:</span> <span class="n">left</span><span class="p">,</span> <span class="nv">right</span><span class="p">:</span> <span class="n">partitionIndex</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="nf">quickSort</span><span class="p">(</span><span class="nv">arr</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">arr</span><span class="p">,</span> <span class="nv">left</span><span class="p">:</span> <span class="n">partitionIndex</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nv">right</span><span class="p">:</span> <span class="n">right</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div></div>]]></content><author><name>Cambria Yang</name><email>cambriayang@qq.com</email></author><category term="Algorithm" /><category term="算法" /><summary type="html"><![CDATA[一些算法举例 排序算法 首先看一张图： 这里就不多解释了，下面抽几个排序简单讲下。 成功 信息 Warning Text. Error Text. success info warning error 冒泡排序 算法步骤 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 对每一对相邻元素作同样的工作，从开始第一队到结尾的最后一对。这步做完后，最后的元素会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 动图演示 代码实现： func bubleSort(source: inout [Int]) -&gt; [Int] { print("bubleSort before: \(source)") for i in 0..&lt;source.count { for j in i..&lt;source.count { if source[j]&lt;source[i] { source.swapAt(i, j) } } } print("bubleSort after: \(source)") return source } i的循环是计数用，j的循环是当次将最大的数放到最后。 插入排序 算法步骤 将第一待排序的第一个元素看过一个有序序列，把第二个元素到最后一个元素当成未排序序列。 从头到位以此扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面） 动图演示 由于很好理解就不放动图演示了。 代码实现 func insertSort(arr: inout [Int]) { for i in 1..&lt;arr.endIndex { let temp = arr[i] for j in (0..&lt;i).reversed() { if arr[j] &gt; temp { arr.swapAt(j, j+1) } } } } 快速排序 平均状况下，排序n个项目要O（nlogn）次比较。在最坏的状况下则需要O（n^2）次比较，但这种状况并不多见。事实上，快排通常明显比其他O（nlogn）算法更快一个，因为它的内部循环可以在大部分的架构上很有效率地被实现出来。 快排使用分治法（Divide and conquer）策略来把一个串行（list）分为两个子串行（sub-lists）。 快速排序本质上是冒泡排序基础上的递归分治法。它是处理大数据排序最快的算法之一了。 《算法艺术与信息学竞赛》上说： 快速排序最坏的情况是O（n^2），比如顺序数列额快排。但它的平摊期望时间是O（nlogn），且O（nlogn）记号中隐含的常数因子很小，比复杂度稳定等于O（nlogn）的归并排序要小很多。所以，对绝大多数树顺序性较弱的随机数列而言，快速排序总是优于归并排序。 算法步骤 从数列中挑出一个元素，称为“基准”（pivot）； 重新排序数列，所有元素比基准值小的摆放在基准面前，所有比基准大的摆在基准后面（相同的可以放到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作； 递归的（recursive）把小于基准值的元素的子数列和大于基准值元素的子数列排序。 动图演示 代码实现 //寻找pivot的函数 func partition(arr: inout [Int], left: Int, right: Int) -&gt; Int { let pivot = left var index = pivot+1 for i in index...right { if arr[i] &lt; arr[pivot] { arr.swapAt(i, index) index+=1 //i和index都更新，以pivot为分隔，两边都冒泡，后面再将假设的pivot替换为真正的pivot，然后继续递归 } } //此处相当于pivot需要更新 arr.swapAt(pivot, index-1) return index-1 } func quickSort(arr: inout [Int], left: Int, right: Int) { if arr.count &lt;= 1 { //nothing, live it alone } let left = left let right = right if left &lt; right { let partitionIndex = partition(arr: &amp;arr, left: left, right: right) quickSort(arr: &amp;arr, left: left, right: partitionIndex-1) quickSort(arr: &amp;arr, left: partitionIndex+1, right: right) } }]]></summary></entry><entry><title type="html">开发过程中的UI差异(flutter版)</title><link href="http://localhost:4000/flutter/2021/03/08/%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84UI%E5%B7%AE%E5%BC%82(flutter%E7%89%88).html" rel="alternate" type="text/html" title="开发过程中的UI差异(flutter版)" /><published>2021-03-08T07:09:00+00:00</published><updated>2021-03-08T07:09:00+00:00</updated><id>http://localhost:4000/flutter/2021/03/08/%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84UI%E5%B7%AE%E5%BC%82(flutter%E7%89%88)</id><content type="html" xml:base="http://localhost:4000/flutter/2021/03/08/%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84UI%E5%B7%AE%E5%BC%82(flutter%E7%89%88).html"><![CDATA[<h2 id="开发过程中的ui差异flutter版">开发过程中的UI差异(flutter版)</h2>

<p>一个App的从无到有一定绕不开UI的还原问题，通常有设计师设计好根据时下主流的机型产出UI稿交于开发人员去还原视觉稿。比如设计稿的规范为：375(width)<em>667(height)。通常开发人员按照设计稿设置的控件（100</em>40）以及字体fontSize：18。但是经常会有设计师来说，怎么Android和iOS上面的表现形式不一样呢？或者怎么oppo上面的字号显得比较大呢？其实，底层逻辑都是由于物理设备到开发语言的映射差异化导致的。</p>

<h3 id="原理介绍">原理介绍</h3>

<h4 id="几个名词">几个名词</h4>

<h5 id="屏幕尺寸">屏幕尺寸</h5>

<p>屏幕尺寸(screen size)，是屏幕的对角线长度，一般讲的大小单位都是英寸。</p>

<h5 id="dpi-dots-per-inch">DPI (dots per inch)</h5>

<p>　　dpi 是（英文Dots Per Inch）（每英寸所打印的点数）的缩写，是打印机、鼠标等设备分辨率的单位。国际上都是计算一平方英寸面积内像素的多少。这是衡量打印机打印精度的主要参数之一，一般来说，该值越大，表明打印机的打印精度越高。如果对于扫描设备，dpi越大，则采样点越高，扫描的图片越清晰。
　　可以理解为像素的密度，即单位面长度上的所打印点的数量。</p>

<h5 id="ppi-pixels-per-inch">PPI (pixels per inch)</h5>

<p>　　PPI (pixels per inch)（每英寸的像素数量）的缩写，也就是像素密度。</p>

<p><strong>PPI=√（X^2+Y^2）/ Z （X：长度像素数；Y：宽度像素数；Z：屏幕大小）</strong></p>

<h5 id="关于像素">关于像素</h5>

<p>像素是计算机设备显示的基本单位，它可以表示图形尺寸的大小。英文名为Pixel，简写为PX。</p>

<p>相同的分辨率，则PPI高的的设备，图片显示起来（物理尺寸）更小。</p>

<p>相同的物理尺寸，PPI低的设配，分辨率低。</p>

<p>简单的来说，图像分辨率(每英寸像素数)和PPI(每英寸点数)两者相互影响。</p>]]></content><author><name>Cambria Yang</name><email>cambriayang@qq.com</email></author><category term="flutter" /><category term="flutter" /><summary type="html"><![CDATA[开发过程中的UI差异(flutter版) 一个App的从无到有一定绕不开UI的还原问题，通常有设计师设计好根据时下主流的机型产出UI稿交于开发人员去还原视觉稿。比如设计稿的规范为：375(width)667(height)。通常开发人员按照设计稿设置的控件（10040）以及字体fontSize：18。但是经常会有设计师来说，怎么Android和iOS上面的表现形式不一样呢？或者怎么oppo上面的字号显得比较大呢？其实，底层逻辑都是由于物理设备到开发语言的映射差异化导致的。 原理介绍 几个名词 屏幕尺寸 屏幕尺寸(screen size)，是屏幕的对角线长度，一般讲的大小单位都是英寸。 DPI (dots per inch) 　　dpi 是（英文Dots Per Inch）（每英寸所打印的点数）的缩写，是打印机、鼠标等设备分辨率的单位。国际上都是计算一平方英寸面积内像素的多少。这是衡量打印机打印精度的主要参数之一，一般来说，该值越大，表明打印机的打印精度越高。如果对于扫描设备，dpi越大，则采样点越高，扫描的图片越清晰。 　　可以理解为像素的密度，即单位面长度上的所打印点的数量。 PPI (pixels per inch) 　　PPI (pixels per inch)（每英寸的像素数量）的缩写，也就是像素密度。 PPI=√（X^2+Y^2）/ Z （X：长度像素数；Y：宽度像素数；Z：屏幕大小） 关于像素 像素是计算机设备显示的基本单位，它可以表示图形尺寸的大小。英文名为Pixel，简写为PX。 相同的分辨率，则PPI高的的设备，图片显示起来（物理尺寸）更小。 相同的物理尺寸，PPI低的设配，分辨率低。 简单的来说，图像分辨率(每英寸像素数)和PPI(每英寸点数)两者相互影响。]]></summary></entry><entry><title type="html">flutter开发初探</title><link href="http://localhost:4000/flutter/2021/01/14/flutter%E5%BC%80%E5%8F%91%E5%88%9D%E6%8E%A2.html" rel="alternate" type="text/html" title="flutter开发初探" /><published>2021-01-14T08:00:00+00:00</published><updated>2021-01-14T08:00:00+00:00</updated><id>http://localhost:4000/flutter/2021/01/14/flutter%E5%BC%80%E5%8F%91%E5%88%9D%E6%8E%A2</id><content type="html" xml:base="http://localhost:4000/flutter/2021/01/14/flutter%E5%BC%80%E5%8F%91%E5%88%9D%E6%8E%A2.html"><![CDATA[<h2 id="flutter开发初探">flutter开发初探</h2>

<p><strong>作为时下最火的跨端技术，虽然现在才能才入局有点晚的感觉，但是本人是喜欢稳定版的，目前1.22.x也已经官方release了，这篇初探就简单记录下，一枚小白的使用心得和入门吧</strong></p>

<h2 id="国际惯例">国际惯例</h2>

<p><img src="http://localhost:4000/assets/images/posts/flutter_arch.jpg" alt="flutter_arch" /></p>

<p>摆出这张图，还是简单从整体上来先认识了一下什么是 Flutter，否则容易陷入“盲人摸象”的境地。</p>

<ul>
  <li><strong>Embedder</strong> 操作系统适配层，提供线程模型，事件循环模型</li>
  <li><strong>Engine</strong>：和底层OS无关了，一般是渲染层包括了 Skia 图形绘制库、Dart VM、Text 等，其中 Skia 和 Text 为上层接口提供了调用底层渲染和排版的能力</li>
  <li><strong>Framework</strong>：是一个用 Dart 实现的 UI SDK，从上之下包括了两大风格组件库（iOS和Android）、基础组件库、图形绘制、手势识别、动画等功能</li>
</ul>

<h2 id="flutter绘制">Flutter绘制</h2>

<p>首先是用户操作，触发 Widget Tree 的更新，然后构建 Element Tree，计算重绘区后将信息同步给 RenderObject Tree，之后实现组件布局、组件绘制、图层合成、引擎渲染。</p>

<p>渲染过程中有3棵树比较重要：</p>

<p><em>Widget Tree</em>, <em>Element Tree</em>, <em>RenderObject Tree</em></p>

<h3 id="widget-tree">Widget Tree</h3>

<p>基本逻辑单位，是用户对界面 UI 的描述方式。其实<strong>Widget是不可变的</strong>，只是通过重绘来更新<code class="language-plaintext highlighter-rouge">state </code></p>

<h3 id="element-tree">Element Tree</h3>

<p>它是 Widget 的实例化对象，<code class="language-plaintext highlighter-rouge">createElement</code> 工厂方法来创建Element。</p>

<p>Element Tree 的重新创建和重新渲染的开销会非常大， 所以 Element Tree 到 RenderObject Tree 也有一个 Diff 环节，来计算最小重绘区域。</p>

<p>需要注意的是，Element 同时持有 Widget 和 RenderObject， 但无论是 Widget 还是 Element，其实都不负责最后的渲染，它们只是“发号施令”，真正对配置信息进行渲染的是 RenderObject。</p>

<h3 id="renderobject-tree">RenderObject Tree</h3>

<p>RenderObject Tree 在 Flutter 的展示过程分为四个阶段：</p>

<ol>
  <li>布局</li>
  <li>绘制</li>
  <li>合成</li>
  <li>渲染</li>
</ol>

<p>其中，布局和绘制在 RenderObject 中完成，Flutter 采用深度优先机制遍历渲染对象树，确定树中各个对象的位置和尺寸，并把它们绘制到不同的图层上。绘制完毕后，合成和渲染的工作则交给 Skia 处理。</p>

<p>理论上可以直接让Widget和RenderObject通信，不过因为Widget设计为不可变的，但是最终在屏幕上的object不可能一直不变。如果每次改变都去全局渲染object，会损耗大量性能。所以Element实际上是对Widget做了抽象，只将变化的部分通知Render层，由此最大程度去降低重绘区域，提高渲染效率。</p>

<h3 id="flutter绘制流程拆解">Flutter绘制流程拆解</h3>

<ol>
  <li>Build</li>
  <li>Diff</li>
  <li>Layout</li>
  <li>Paint</li>
  <li>Composite</li>
  <li>Render</li>
</ol>

<h3 id="自绘引擎">自绘引擎</h3>

<ol>
  <li>通过Skia直接调用OpenGL渲染，保证性能同时抹平差异。</li>
  <li>Dart同时支持JIT和AOT。</li>
</ol>

<h2 id="flutter混合开发">Flutter混合开发</h2>

<h3 id="混合模式">混合模式</h3>

<ol>
  <li>
    <p>统一管理模式</p>

    <p>所谓统一管理模式，就是一个标准的 Flutter Application 工程，而其中 Flutter 的产物工程目录（ <code class="language-plaintext highlighter-rouge">ios/</code> 和 <code class="language-plaintext highlighter-rouge">android/</code> ）是可以进行原生混编的工程，如 React Native 进行混合开发那般，在工程项目中进行混合开发就好。但是这样的缺点是当原生项目业务庞大起来时，Flutter 工程对于原生工程的耦合就会非常严重，当工程进行升级时会比较麻烦。因此这种混合模式只适用于 Flutter 业务主导、原生功能为辅的项目。</p>
  </li>
  <li>
    <p>三端分离模式</p>

    <p>后来 Google 对混合开发有了更好的支持，除了 Flutter Application，还支持 Flutter Module。所谓 Flutter Module，恰如其名，就是支持以模块化的方式将 Flutter 引入原生工程中， 它的产物就是 iOS 下的 Framework 或 Pods、Android 下的 AAR，原生工程就像引入其他第三方 SDK 那样，使用 Maven 和 Cocoapods 引入 Flutter Module 即可。 从而实现真正意义上的三端分离的开发模式。</p>
  </li>
</ol>

<h3 id="混合栈原理">混合栈原理</h3>

<p>混合导航栈主要需要解决以下四种场景下的问题：</p>

<ul>
  <li>
    <p>Native 2 Native</p>

    <p>这种情况比较简单，Flutter Engine 已经为我们提供了现成的 Plugin，即 iOS 下的 FlutterViewController 与 Android 下的 FlutterView（自行包装一下可以实现 FlutterActivity），所以这种场景我们直接使用启动了的 Flutter Engine 来初始化 Flutter 容器，为其设置初始路由页面之后，就可以以原生的方式跳转至 Flutter 页面了。</p>
  </li>
  <li>
    <p>Flutter 2 Flutter</p>

    <ul>
      <li>使用 Flutter 本身的 Navigator 导航栈</li>
      <li>创建新的 Flutter 容器后，使用原生导航栈</li>
    </ul>
  </li>
  <li>
    <p>Flutter 2 Native</p>

    <p>这里的跳转其实是包含了两种情况，一是打开原生页面（open，包括但不限于 push），二是回退到原生页面（close，包括但不限于 pop）。</p>
  </li>
  <li>
    <p>Native 2 Native</p>
  </li>
</ul>]]></content><author><name>Cambria Yang</name><email>cambriayang@qq.com</email></author><category term="flutter" /><category term="flutter" /><summary type="html"><![CDATA[flutter开发初探 作为时下最火的跨端技术，虽然现在才能才入局有点晚的感觉，但是本人是喜欢稳定版的，目前1.22.x也已经官方release了，这篇初探就简单记录下，一枚小白的使用心得和入门吧 国际惯例 摆出这张图，还是简单从整体上来先认识了一下什么是 Flutter，否则容易陷入“盲人摸象”的境地。 Embedder 操作系统适配层，提供线程模型，事件循环模型 Engine：和底层OS无关了，一般是渲染层包括了 Skia 图形绘制库、Dart VM、Text 等，其中 Skia 和 Text 为上层接口提供了调用底层渲染和排版的能力 Framework：是一个用 Dart 实现的 UI SDK，从上之下包括了两大风格组件库（iOS和Android）、基础组件库、图形绘制、手势识别、动画等功能 Flutter绘制 首先是用户操作，触发 Widget Tree 的更新，然后构建 Element Tree，计算重绘区后将信息同步给 RenderObject Tree，之后实现组件布局、组件绘制、图层合成、引擎渲染。 渲染过程中有3棵树比较重要： Widget Tree, Element Tree, RenderObject Tree Widget Tree 基本逻辑单位，是用户对界面 UI 的描述方式。其实Widget是不可变的，只是通过重绘来更新state Element Tree 它是 Widget 的实例化对象，createElement 工厂方法来创建Element。 Element Tree 的重新创建和重新渲染的开销会非常大， 所以 Element Tree 到 RenderObject Tree 也有一个 Diff 环节，来计算最小重绘区域。 需要注意的是，Element 同时持有 Widget 和 RenderObject， 但无论是 Widget 还是 Element，其实都不负责最后的渲染，它们只是“发号施令”，真正对配置信息进行渲染的是 RenderObject。 RenderObject Tree RenderObject Tree 在 Flutter 的展示过程分为四个阶段： 布局 绘制 合成 渲染 其中，布局和绘制在 RenderObject 中完成，Flutter 采用深度优先机制遍历渲染对象树，确定树中各个对象的位置和尺寸，并把它们绘制到不同的图层上。绘制完毕后，合成和渲染的工作则交给 Skia 处理。 理论上可以直接让Widget和RenderObject通信，不过因为Widget设计为不可变的，但是最终在屏幕上的object不可能一直不变。如果每次改变都去全局渲染object，会损耗大量性能。所以Element实际上是对Widget做了抽象，只将变化的部分通知Render层，由此最大程度去降低重绘区域，提高渲染效率。 Flutter绘制流程拆解 Build Diff Layout Paint Composite Render 自绘引擎 通过Skia直接调用OpenGL渲染，保证性能同时抹平差异。 Dart同时支持JIT和AOT。 Flutter混合开发 混合模式 统一管理模式 所谓统一管理模式，就是一个标准的 Flutter Application 工程，而其中 Flutter 的产物工程目录（ ios/ 和 android/ ）是可以进行原生混编的工程，如 React Native 进行混合开发那般，在工程项目中进行混合开发就好。但是这样的缺点是当原生项目业务庞大起来时，Flutter 工程对于原生工程的耦合就会非常严重，当工程进行升级时会比较麻烦。因此这种混合模式只适用于 Flutter 业务主导、原生功能为辅的项目。 三端分离模式 后来 Google 对混合开发有了更好的支持，除了 Flutter Application，还支持 Flutter Module。所谓 Flutter Module，恰如其名，就是支持以模块化的方式将 Flutter 引入原生工程中， 它的产物就是 iOS 下的 Framework 或 Pods、Android 下的 AAR，原生工程就像引入其他第三方 SDK 那样，使用 Maven 和 Cocoapods 引入 Flutter Module 即可。 从而实现真正意义上的三端分离的开发模式。 混合栈原理 混合导航栈主要需要解决以下四种场景下的问题： Native 2 Native 这种情况比较简单，Flutter Engine 已经为我们提供了现成的 Plugin，即 iOS 下的 FlutterViewController 与 Android 下的 FlutterView（自行包装一下可以实现 FlutterActivity），所以这种场景我们直接使用启动了的 Flutter Engine 来初始化 Flutter 容器，为其设置初始路由页面之后，就可以以原生的方式跳转至 Flutter 页面了。 Flutter 2 Flutter 使用 Flutter 本身的 Navigator 导航栈 创建新的 Flutter 容器后，使用原生导航栈 Flutter 2 Native 这里的跳转其实是包含了两种情况，一是打开原生页面（open，包括但不限于 push），二是回退到原生页面（close，包括但不限于 pop）。 Native 2 Native]]></summary></entry></feed>